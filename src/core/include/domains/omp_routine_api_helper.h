/**
 * @file omp_routine_api_helper.h
 * @brief Helper functions for managing OMP_ROUTINE API calls in the profiling framework.
 *
 * This file contains various utility functions used to handle OMP_ROUTINE API calls 
 * within the profiling system, including retrieving argument values and 
 * managing function identifiers.
 * 
 * @note THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 * 
 */

#ifndef OMP_ROUTINE_API_HELPER_H
#define OMP_ROUTINE_API_HELPER_H

#include <string.h>
#include <stdbool.h>
#include "domains/fun_proto/omp_routine_profiled_functions.h"
#include "omp.h" 

#define OMP_ROUTINE_STRING_SIZE_MAX 128

#ifdef ADD_API_PREFIX
#undef ADD_API_PREFIX
#endif
#define ADD_API_PREFIX(str) OMP_ROUTINE_API_##str


#define FOR_EACH_OMP_ROUTINE_FUNC(macro) \
IF_ENABLED(omp_target_memset, macro)               \
IF_ENABLED(omp_target_memcpy_async, macro)         \
IF_ENABLED(omp_target_memcpy_rect_async, macro)    \
IF_ENABLED(omp_target_alloc, macro)                \
IF_ENABLED(omp_target_free, macro)                 \
IF_ENABLED(omp_target_memcpy_rect, macro)          \
IF_ENABLED(omp_target_disassociate_ptr, macro)     \
IF_ENABLED(omp_target_memcpy, macro)               \
IF_ENABLED(omp_target_memset_async, macro)         \
IF_ENABLED(omp_target_is_present, macro)           \
IF_ENABLED(omp_target_associate_ptr, macro)        \
IF_ENABLED(omp_get_initial_device, macro)          \
IF_ENABLED(llvm_omp_target_dynamic_shared_alloc, macro) \
IF_ENABLED(omp_get_interop_int, macro)             \
IF_ENABLED(omp_get_interop_name, macro)            \
IF_ENABLED(omp_get_interop_ptr, macro)             \
IF_ENABLED(omp_get_interop_str, macro)             \
IF_ENABLED(omp_get_interop_type_desc, macro)       \
IF_ENABLED(omp_get_mapped_ptr, macro)              \
IF_ENABLED(omp_get_num_devices, macro)             \
IF_ENABLED(omp_is_coarse_grain_mem_region, macro)  \


/**
 * @enum omp_routine_api_id_t 
 * @brief Enumeration of OMP_ROUTINE API function identifiers.
 *
 * This enumeration defines unique identifiers for various OMP_ROUTINE API functions. 
 * These identifiers are used for profiling, tracking, and identifying specific OMP_ROUTINE function calls.
 */
typedef enum omp_routine_api_id_e {
    FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNC_API_ID)
    OMP_ROUTINE_API_ID_NB_FUNCTION,
    OMP_ROUTINE_API_ID_UNKNOWN,
} omp_routine_api_id_t;


/**
 * @brief Retrieves the function name corresponding to a given OMP_ROUTINE API function ID.
 *
 * This function maps a OMP_ROUTINE API function identifier (`omp_routine_api_id_t`) to its corresponding function name
 * as a string. If the provided function ID does not match any known functions, the function returns `NULL`.
 *
 * @param id The OMP_ROUTINE API function identifier of type `omp_routine_api_id_t`.
 * @return A constant string representing the function name, or `NULL` if the ID is unknown.
 */
static inline const char* get_omp_routine_funame_by_id(omp_routine_api_id_t id) 
{
    switch(id) {
        FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNAME_BY_ID_OF)
        default : return NULL;
    }
    return NULL;
}


/**
 * @brief Retrieves the function pointer corresponding to a given OMP_ROUTINE API function ID.
 *
 * This function maps a OMP_ROUTINE API function ID (`omp_routine_api_id_t`) to its corresponding function address.
 * If the provided function ID does not match any known functions, the function returns `NULL`.
 *
 * @param id The function ID of type `omp_routine_api_id_t`.
 * @return A pointer to the corresponding OMP_ROUTINE API function, or `NULL` if not found.
 */
static inline void* get_omp_routine_funaddr_by_id(omp_routine_api_id_t id) 
{
    switch(id) {
        FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNADDR_BY_ID_OF)
        default : return NULL;
    }
    return NULL;
}


/**
 * @brief Retrieves the OMP_ROUTINE API function ID corresponding to a given function name.
 *
 * This function maps a OMP_ROUTINE API function name (string) to its corresponding function ID (`omp_routine_api_id_t`).
 * If the provided function name does not match any known functions, the function returns `OMP_ROUTINE_API_ID_UNKNOWN`.
 *
 * @param name The function name as a null-terminated string.
 * @return The corresponding OMP_ROUTINE API function ID of type `omp_routine_api_id_t`, or `OMP_ROUTINE_API_ID_UNKNOWN` if not found.
 */
static inline omp_routine_api_id_t get_omp_routine_funid_by_name(const char* name) 
{
    if (name == NULL) return OMP_ROUTINE_API_ID_UNKNOWN;
    FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNID_BY_NAME_OF)
    return OMP_ROUTINE_API_ID_UNKNOWN;
}


// OMP_ROUTINE API Args Data
/**
 * @brief Structure to hold the arguments for the `omp_target_memset` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memset` function call.
 *
 * @struct args_omp_target_memset_t
 *
 * @note 
 *	void *
 *	omp_target_memset (
 *			void * ptr (void *)
 *			int value (int)
 *			size_t size (unsigned long)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_memset
struct args_omp_target_memset_t {
	void * ptr;
	int value;
	size_t size;
	int device_num;
	void * retval;
};

#define GET_ARGS_VALUE_omp_target_memset(activity) { \
	activity->omp_routine_args.omp_target_memset.ptr = (void *) ptr; \
	activity->omp_routine_args.omp_target_memset.value = (int) value; \
	activity->omp_routine_args.omp_target_memset.size = (size_t) size; \
	activity->omp_routine_args.omp_target_memset.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy_async` function call.
 *
 * @struct args_omp_target_memcpy_async_t
 *
 * @note 
 *	int
 *	omp_target_memcpy_async (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t size (unsigned long)
 *			size_t dst_offset (unsigned long)
 *			size_t src_offset (unsigned long)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *			int async_depend_info (int)
 *			omp_depend_t * depend (void **)
 *	)
 */
#if HAVE_omp_target_memcpy_async
struct args_omp_target_memcpy_async_t {
	void * dst;
	void * src;
	size_t size;
	size_t dst_offset;
	size_t src_offset;
	int dst_device_num;
	int src_device_num;
	int async_depend_info;
	void ** depend;
	struct {
		void* ptr1;
	} depend__ref;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_memcpy_async(activity) { \
	activity->omp_routine_args.omp_target_memcpy_async.dst = (void *) dst; \
	activity->omp_routine_args.omp_target_memcpy_async.src = (void *) src; \
	activity->omp_routine_args.omp_target_memcpy_async.size = (size_t) size; \
	activity->omp_routine_args.omp_target_memcpy_async.dst_offset = (size_t) dst_offset; \
	activity->omp_routine_args.omp_target_memcpy_async.src_offset = (size_t) src_offset; \
	activity->omp_routine_args.omp_target_memcpy_async.dst_device_num = (int) dst_device_num; \
	activity->omp_routine_args.omp_target_memcpy_async.src_device_num = (int) src_device_num; \
	activity->omp_routine_args.omp_target_memcpy_async.async_depend_info = (int) async_depend_info; \
	activity->omp_routine_args.omp_target_memcpy_async.depend = (void **) depend; \
};

#define GET_PTRS_VALUE_omp_target_memcpy_async(args) { \
	if (args->omp_target_memcpy_async.depend != NULL) { \
		args->omp_target_memcpy_async.depend__ref.ptr1 = *args->omp_target_memcpy_async.depend; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy_rect_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy_rect_async` function call.
 *
 * @struct args_omp_target_memcpy_rect_async_t
 *
 * @note 
 *	int
 *	omp_target_memcpy_rect_async (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t element_size (unsigned long)
 *			int num_dims (int)
 *			const size_t * volume (const unsigned long *)
 *			const size_t * dst_offsets (const unsigned long *)
 *			const size_t * src_offsets (const unsigned long *)
 *			const size_t * dst_dimensions (const unsigned long *)
 *			const size_t * src_dimensions (const unsigned long *)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *			int depobj_count (int)
 *			omp_depend_t * depobj_list (void **)
 *	)
 */
#if HAVE_omp_target_memcpy_rect_async
struct args_omp_target_memcpy_rect_async_t {
	void * dst;
	void * src;
	size_t element_size;
	int num_dims;
	size_t * volume;
	struct {
		size_t val;
	} volume__ref;
	size_t * dst_offsets;
	struct {
		size_t val;
	} dst_offsets__ref;
	size_t * src_offsets;
	struct {
		size_t val;
	} src_offsets__ref;
	size_t * dst_dimensions;
	struct {
		size_t val;
	} dst_dimensions__ref;
	size_t * src_dimensions;
	struct {
		size_t val;
	} src_dimensions__ref;
	int dst_device_num;
	int src_device_num;
	int depobj_count;
	void ** depobj_list;
	struct {
		void* ptr1;
	} depobj_list__ref;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_memcpy_rect_async(activity) { \
	activity->omp_routine_args.omp_target_memcpy_rect_async.dst = (void *) dst; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.src = (void *) src; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.element_size = (size_t) element_size; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.num_dims = (int) num_dims; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.volume = (size_t *) volume; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.dst_offsets = (size_t *) dst_offsets; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.src_offsets = (size_t *) src_offsets; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.dst_dimensions = (size_t *) dst_dimensions; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.src_dimensions = (size_t *) src_dimensions; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.dst_device_num = (int) dst_device_num; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.src_device_num = (int) src_device_num; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.depobj_count = (int) depobj_count; \
	activity->omp_routine_args.omp_target_memcpy_rect_async.depobj_list = (void **) depobj_list; \
};

#define GET_PTRS_VALUE_omp_target_memcpy_rect_async(args) { \
	if (args->omp_target_memcpy_rect_async.volume != NULL) { \
		args->omp_target_memcpy_rect_async.volume__ref.val = *args->omp_target_memcpy_rect_async.volume; \
	} \
	if (args->omp_target_memcpy_rect_async.dst_offsets != NULL) { \
		args->omp_target_memcpy_rect_async.dst_offsets__ref.val = *args->omp_target_memcpy_rect_async.dst_offsets; \
	} \
	if (args->omp_target_memcpy_rect_async.src_offsets != NULL) { \
		args->omp_target_memcpy_rect_async.src_offsets__ref.val = *args->omp_target_memcpy_rect_async.src_offsets; \
	} \
	if (args->omp_target_memcpy_rect_async.dst_dimensions != NULL) { \
		args->omp_target_memcpy_rect_async.dst_dimensions__ref.val = *args->omp_target_memcpy_rect_async.dst_dimensions; \
	} \
	if (args->omp_target_memcpy_rect_async.src_dimensions != NULL) { \
		args->omp_target_memcpy_rect_async.src_dimensions__ref.val = *args->omp_target_memcpy_rect_async.src_dimensions; \
	} \
	if (args->omp_target_memcpy_rect_async.depobj_list != NULL) { \
		args->omp_target_memcpy_rect_async.depobj_list__ref.ptr1 = *args->omp_target_memcpy_rect_async.depobj_list; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_alloc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_alloc` function call.
 *
 * @struct args_omp_target_alloc_t
 *
 * @note 
 *	void *
 *	omp_target_alloc (
 *			size_t size (unsigned long)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_alloc
struct args_omp_target_alloc_t {
	size_t size;
	int device_num;
	void * retval;
};

#define GET_ARGS_VALUE_omp_target_alloc(activity) { \
	activity->omp_routine_args.omp_target_alloc.size = (size_t) size; \
	activity->omp_routine_args.omp_target_alloc.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_free` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_free` function call.
 *
 * @struct args_omp_target_free_t
 *
 * @note 
 *	void
 *	omp_target_free (
 *			void * device_ptr (void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_free
struct args_omp_target_free_t {
	void * device_ptr;
	int device_num;
};

#define GET_ARGS_VALUE_omp_target_free(activity) { \
	activity->omp_routine_args.omp_target_free.device_ptr = (void *) device_ptr; \
	activity->omp_routine_args.omp_target_free.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy_rect` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy_rect` function call.
 *
 * @struct args_omp_target_memcpy_rect_t
 *
 * @note 
 *	int
 *	omp_target_memcpy_rect (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t element_size (unsigned long)
 *			int num_dims (int)
 *			const size_t * volume (const unsigned long *)
 *			const size_t * dst_offsets (const unsigned long *)
 *			const size_t * src_offsets (const unsigned long *)
 *			const size_t * dst_dimensions (const unsigned long *)
 *			const size_t * src_dimensions (const unsigned long *)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *	)
 */
#if HAVE_omp_target_memcpy_rect
struct args_omp_target_memcpy_rect_t {
	void * dst;
	void * src;
	size_t element_size;
	int num_dims;
	size_t * volume;
	struct {
		size_t val;
	} volume__ref;
	size_t * dst_offsets;
	struct {
		size_t val;
	} dst_offsets__ref;
	size_t * src_offsets;
	struct {
		size_t val;
	} src_offsets__ref;
	size_t * dst_dimensions;
	struct {
		size_t val;
	} dst_dimensions__ref;
	size_t * src_dimensions;
	struct {
		size_t val;
	} src_dimensions__ref;
	int dst_device_num;
	int src_device_num;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_memcpy_rect(activity) { \
	activity->omp_routine_args.omp_target_memcpy_rect.dst = (void *) dst; \
	activity->omp_routine_args.omp_target_memcpy_rect.src = (void *) src; \
	activity->omp_routine_args.omp_target_memcpy_rect.element_size = (size_t) element_size; \
	activity->omp_routine_args.omp_target_memcpy_rect.num_dims = (int) num_dims; \
	activity->omp_routine_args.omp_target_memcpy_rect.volume = (size_t *) volume; \
	activity->omp_routine_args.omp_target_memcpy_rect.dst_offsets = (size_t *) dst_offsets; \
	activity->omp_routine_args.omp_target_memcpy_rect.src_offsets = (size_t *) src_offsets; \
	activity->omp_routine_args.omp_target_memcpy_rect.dst_dimensions = (size_t *) dst_dimensions; \
	activity->omp_routine_args.omp_target_memcpy_rect.src_dimensions = (size_t *) src_dimensions; \
	activity->omp_routine_args.omp_target_memcpy_rect.dst_device_num = (int) dst_device_num; \
	activity->omp_routine_args.omp_target_memcpy_rect.src_device_num = (int) src_device_num; \
};

#define GET_PTRS_VALUE_omp_target_memcpy_rect(args) { \
	if (args->omp_target_memcpy_rect.volume != NULL) { \
		args->omp_target_memcpy_rect.volume__ref.val = *args->omp_target_memcpy_rect.volume; \
	} \
	if (args->omp_target_memcpy_rect.dst_offsets != NULL) { \
		args->omp_target_memcpy_rect.dst_offsets__ref.val = *args->omp_target_memcpy_rect.dst_offsets; \
	} \
	if (args->omp_target_memcpy_rect.src_offsets != NULL) { \
		args->omp_target_memcpy_rect.src_offsets__ref.val = *args->omp_target_memcpy_rect.src_offsets; \
	} \
	if (args->omp_target_memcpy_rect.dst_dimensions != NULL) { \
		args->omp_target_memcpy_rect.dst_dimensions__ref.val = *args->omp_target_memcpy_rect.dst_dimensions; \
	} \
	if (args->omp_target_memcpy_rect.src_dimensions != NULL) { \
		args->omp_target_memcpy_rect.src_dimensions__ref.val = *args->omp_target_memcpy_rect.src_dimensions; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_disassociate_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_disassociate_ptr` function call.
 *
 * @struct args_omp_target_disassociate_ptr_t
 *
 * @note 
 *	int
 *	omp_target_disassociate_ptr (
 *			const void * host_ptr (const void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_disassociate_ptr
struct args_omp_target_disassociate_ptr_t {
	void * host_ptr;
	int device_num;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_disassociate_ptr(activity) { \
	activity->omp_routine_args.omp_target_disassociate_ptr.host_ptr = (void *) host_ptr; \
	activity->omp_routine_args.omp_target_disassociate_ptr.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy` function call.
 *
 * @struct args_omp_target_memcpy_t
 *
 * @note 
 *	int
 *	omp_target_memcpy (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t size (unsigned long)
 *			size_t dst_offset (unsigned long)
 *			size_t src_offset (unsigned long)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *	)
 */
#if HAVE_omp_target_memcpy
struct args_omp_target_memcpy_t {
	void * dst;
	void * src;
	size_t size;
	size_t dst_offset;
	size_t src_offset;
	int dst_device_num;
	int src_device_num;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_memcpy(activity) { \
	activity->omp_routine_args.omp_target_memcpy.dst = (void *) dst; \
	activity->omp_routine_args.omp_target_memcpy.src = (void *) src; \
	activity->omp_routine_args.omp_target_memcpy.size = (size_t) size; \
	activity->omp_routine_args.omp_target_memcpy.dst_offset = (size_t) dst_offset; \
	activity->omp_routine_args.omp_target_memcpy.src_offset = (size_t) src_offset; \
	activity->omp_routine_args.omp_target_memcpy.dst_device_num = (int) dst_device_num; \
	activity->omp_routine_args.omp_target_memcpy.src_device_num = (int) src_device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memset_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memset_async` function call.
 *
 * @struct args_omp_target_memset_async_t
 *
 * @note 
 *	void *
 *	omp_target_memset_async (
 *			void * ptr (void *)
 *			int value (int)
 *			size_t size (unsigned long)
 *			int device_num (int)
 *			int async_depend_info (int)
 *			omp_depend_t * depend (void **)
 *	)
 */
#if HAVE_omp_target_memset_async
struct args_omp_target_memset_async_t {
	void * ptr;
	int value;
	size_t size;
	int device_num;
	int async_depend_info;
	void ** depend;
	struct {
		void* ptr1;
	} depend__ref;
	void * retval;
};

#define GET_ARGS_VALUE_omp_target_memset_async(activity) { \
	activity->omp_routine_args.omp_target_memset_async.ptr = (void *) ptr; \
	activity->omp_routine_args.omp_target_memset_async.value = (int) value; \
	activity->omp_routine_args.omp_target_memset_async.size = (size_t) size; \
	activity->omp_routine_args.omp_target_memset_async.device_num = (int) device_num; \
	activity->omp_routine_args.omp_target_memset_async.async_depend_info = (int) async_depend_info; \
	activity->omp_routine_args.omp_target_memset_async.depend = (void **) depend; \
};

#define GET_PTRS_VALUE_omp_target_memset_async(args) { \
	if (args->omp_target_memset_async.depend != NULL) { \
		args->omp_target_memset_async.depend__ref.ptr1 = *args->omp_target_memset_async.depend; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_is_present` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_is_present` function call.
 *
 * @struct args_omp_target_is_present_t
 *
 * @note 
 *	int
 *	omp_target_is_present (
 *			const void * host_ptr (const void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_is_present
struct args_omp_target_is_present_t {
	void * host_ptr;
	int device_num;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_is_present(activity) { \
	activity->omp_routine_args.omp_target_is_present.host_ptr = (void *) host_ptr; \
	activity->omp_routine_args.omp_target_is_present.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_associate_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_associate_ptr` function call.
 *
 * @struct args_omp_target_associate_ptr_t
 *
 * @note 
 *	int
 *	omp_target_associate_ptr (
 *			const void * host_ptr (const void *)
 *			const void * device_ptr (const void *)
 *			size_t size (unsigned long)
 *			size_t alignment (unsigned long)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_associate_ptr
struct args_omp_target_associate_ptr_t {
	void * host_ptr;
	void * device_ptr;
	size_t size;
	size_t alignment;
	int device_num;
	int retval;
};

#define GET_ARGS_VALUE_omp_target_associate_ptr(activity) { \
	activity->omp_routine_args.omp_target_associate_ptr.host_ptr = (void *) host_ptr; \
	activity->omp_routine_args.omp_target_associate_ptr.device_ptr = (void *) device_ptr; \
	activity->omp_routine_args.omp_target_associate_ptr.size = (size_t) size; \
	activity->omp_routine_args.omp_target_associate_ptr.alignment = (size_t) alignment; \
	activity->omp_routine_args.omp_target_associate_ptr.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_initial_device` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_initial_device` function call.
 *
 * @struct args_omp_get_initial_device_t
 *
 * @note 
 *	int
 *	omp_get_initial_device (
 *	)
 */
#if HAVE_omp_get_initial_device
struct args_omp_get_initial_device_t {
	int retval;
};

#endif

/**
 * @brief Structure to hold the arguments for the `llvm_omp_target_dynamic_shared_alloc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `llvm_omp_target_dynamic_shared_alloc` function call.
 *
 * @struct args_llvm_omp_target_dynamic_shared_alloc_t
 *
 * @note 
 *	void *
 *	llvm_omp_target_dynamic_shared_alloc (
 *	)
 */
#if HAVE_llvm_omp_target_dynamic_shared_alloc
struct args_llvm_omp_target_dynamic_shared_alloc_t {
	void * retval;
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_int` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_int` function call.
 *
 * @struct args_omp_get_interop_int_t
 *
 * @note 
 *	omp_intptr_t
 *	omp_get_interop_int (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *			int * exists (int *)
 *	)
 */
#if HAVE_omp_get_interop_int
struct args_omp_get_interop_int_t {
	void * interop;
	omp_interop_property_t prop;
	int * exists;
	struct {
		int val;
	} exists__ref;
	omp_intptr_t retval;
};

#define GET_ARGS_VALUE_omp_get_interop_int(activity) { \
	activity->omp_routine_args.omp_get_interop_int.interop = (void *) interop; \
	activity->omp_routine_args.omp_get_interop_int.prop = (omp_interop_property_t) prop; \
	activity->omp_routine_args.omp_get_interop_int.exists = (int *) exists; \
};

#define GET_PTRS_VALUE_omp_get_interop_int(args) { \
	if (args->omp_get_interop_int.exists != NULL) { \
		args->omp_get_interop_int.exists__ref.val = *args->omp_get_interop_int.exists; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_name` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_name` function call.
 *
 * @struct args_omp_get_interop_name_t
 *
 * @note 
 *	const char *
 *	omp_get_interop_name (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *	)
 */
#if HAVE_omp_get_interop_name
struct args_omp_get_interop_name_t {
	void * interop;
	omp_interop_property_t prop;
	char * retval;
	struct {
		char val[OMP_ROUTINE_STRING_SIZE_MAX];
	} retval__ref;
};

#define GET_ARGS_VALUE_omp_get_interop_name(activity) { \
	activity->omp_routine_args.omp_get_interop_name.interop = (void *) interop; \
	activity->omp_routine_args.omp_get_interop_name.prop = (omp_interop_property_t) prop; \
};

#define GET_PTRS_RET_VALUE_omp_get_interop_name(args) { \
	if (args->omp_get_interop_name.retval != NULL) { \
		strncpy(args->omp_get_interop_name.retval__ref.val, args->omp_get_interop_name.retval, OMP_ROUTINE_STRING_SIZE_MAX-1); \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_ptr` function call.
 *
 * @struct args_omp_get_interop_ptr_t
 *
 * @note 
 *	void *
 *	omp_get_interop_ptr (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *			int * exists (int *)
 *	)
 */
#if HAVE_omp_get_interop_ptr
struct args_omp_get_interop_ptr_t {
	void * interop;
	omp_interop_property_t prop;
	int * exists;
	struct {
		int val;
	} exists__ref;
	void * retval;
};

#define GET_ARGS_VALUE_omp_get_interop_ptr(activity) { \
	activity->omp_routine_args.omp_get_interop_ptr.interop = (void *) interop; \
	activity->omp_routine_args.omp_get_interop_ptr.prop = (omp_interop_property_t) prop; \
	activity->omp_routine_args.omp_get_interop_ptr.exists = (int *) exists; \
};

#define GET_PTRS_VALUE_omp_get_interop_ptr(args) { \
	if (args->omp_get_interop_ptr.exists != NULL) { \
		args->omp_get_interop_ptr.exists__ref.val = *args->omp_get_interop_ptr.exists; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_str` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_str` function call.
 *
 * @struct args_omp_get_interop_str_t
 *
 * @note 
 *	const char *
 *	omp_get_interop_str (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *			int * exists (int *)
 *	)
 */
#if HAVE_omp_get_interop_str
struct args_omp_get_interop_str_t {
	void * interop;
	omp_interop_property_t prop;
	int * exists;
	struct {
		int val;
	} exists__ref;
	char * retval;
	struct {
		char val[OMP_ROUTINE_STRING_SIZE_MAX];
	} retval__ref;
};

#define GET_ARGS_VALUE_omp_get_interop_str(activity) { \
	activity->omp_routine_args.omp_get_interop_str.interop = (void *) interop; \
	activity->omp_routine_args.omp_get_interop_str.prop = (omp_interop_property_t) prop; \
	activity->omp_routine_args.omp_get_interop_str.exists = (int *) exists; \
};

#define GET_PTRS_VALUE_omp_get_interop_str(args) { \
	if (args->omp_get_interop_str.exists != NULL) { \
		args->omp_get_interop_str.exists__ref.val = *args->omp_get_interop_str.exists; \
	} \
};

#define GET_PTRS_RET_VALUE_omp_get_interop_str(args) { \
	if (args->omp_get_interop_str.retval != NULL) { \
		strncpy(args->omp_get_interop_str.retval__ref.val, args->omp_get_interop_str.retval, OMP_ROUTINE_STRING_SIZE_MAX-1); \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_type_desc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_type_desc` function call.
 *
 * @struct args_omp_get_interop_type_desc_t
 *
 * @note 
 *	const char *
 *	omp_get_interop_type_desc (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *	)
 */
#if HAVE_omp_get_interop_type_desc
struct args_omp_get_interop_type_desc_t {
	void * interop;
	omp_interop_property_t prop;
	char * retval;
	struct {
		char val[OMP_ROUTINE_STRING_SIZE_MAX];
	} retval__ref;
};

#define GET_ARGS_VALUE_omp_get_interop_type_desc(activity) { \
	activity->omp_routine_args.omp_get_interop_type_desc.interop = (void *) interop; \
	activity->omp_routine_args.omp_get_interop_type_desc.prop = (omp_interop_property_t) prop; \
};

#define GET_PTRS_RET_VALUE_omp_get_interop_type_desc(args) { \
	if (args->omp_get_interop_type_desc.retval != NULL) { \
		strncpy(args->omp_get_interop_type_desc.retval__ref.val, args->omp_get_interop_type_desc.retval, OMP_ROUTINE_STRING_SIZE_MAX-1); \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_mapped_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_mapped_ptr` function call.
 *
 * @struct args_omp_get_mapped_ptr_t
 *
 * @note 
 *	void *
 *	omp_get_mapped_ptr (
 *			const void * ptr (const void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_get_mapped_ptr
struct args_omp_get_mapped_ptr_t {
	void * ptr;
	int device_num;
	void * retval;
};

#define GET_ARGS_VALUE_omp_get_mapped_ptr(activity) { \
	activity->omp_routine_args.omp_get_mapped_ptr.ptr = (void *) ptr; \
	activity->omp_routine_args.omp_get_mapped_ptr.device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_num_devices` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_num_devices` function call.
 *
 * @struct args_omp_get_num_devices_t
 *
 * @note 
 *	int
 *	omp_get_num_devices (
 *	)
 */
#if HAVE_omp_get_num_devices
struct args_omp_get_num_devices_t {
	int retval;
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_is_coarse_grain_mem_region` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_is_coarse_grain_mem_region` function call.
 *
 * @struct args_omp_is_coarse_grain_mem_region_t
 *
 * @note 
 *	int
 *	omp_is_coarse_grain_mem_region (
 *			void * ptr (void *)
 *			size_t size (unsigned long)
 *	)
 */
#if HAVE_omp_is_coarse_grain_mem_region
struct args_omp_is_coarse_grain_mem_region_t {
	void * ptr;
	size_t size;
	int retval;
};

#define GET_ARGS_VALUE_omp_is_coarse_grain_mem_region(activity) { \
	activity->omp_routine_args.omp_is_coarse_grain_mem_region.ptr = (void *) ptr; \
	activity->omp_routine_args.omp_is_coarse_grain_mem_region.size = (size_t) size; \
};

#endif



/**
 * @brief Union representing argument structures for different OMP_ROUTINE API calls.
 *
 * This union allows storing parameters for various OMP_ROUTINE API functions,
 * ensuring type safety and efficient memory usage.
 *
 * @union omp_routine_api_args_u 
 * @typedef omp_routine_api_args_t 
 */
typedef union omp_routine_api_args_u {
    FOR_EACH_OMP_ROUTINE_FUNC(GET_ARGS_STRUCT_OF)
} omp_routine_api_args_t;


/**
 * @brief Retrieves pointer-based argument values for OMP_ROUTINE API calls.
 *
 * This function extracts pointer-based arguments from the provided `omp_routine_api_args_t`
 * structure based on the given OMP_ROUTINE API ID.
 *
 * @param[in] id The OMP_ROUTINE API function identifier.
 * @param[in,out] args Pointer to the OMP_ROUTINE API arguments structure.
 * @param[in] is_enter Boolean flag indicating whether this function is handling an "enter" or "exit" event.
 */
static inline void get_omp_routine_pointed_args_for(omp_routine_api_id_t id, omp_routine_api_args_t* args, bool is_enter) 
{
    if (!is_enter) {
        switch(id) {
			#if HAVE_omp_target_memcpy_async
			case OMP_ROUTINE_API_ID_omp_target_memcpy_async : 
				GET_PTRS_VALUE_omp_target_memcpy_async(args);
				return;
			#endif
			#if HAVE_omp_target_memcpy_rect_async
			case OMP_ROUTINE_API_ID_omp_target_memcpy_rect_async : 
				GET_PTRS_VALUE_omp_target_memcpy_rect_async(args);
				return;
			#endif
			#if HAVE_omp_target_memcpy_rect
			case OMP_ROUTINE_API_ID_omp_target_memcpy_rect : 
				GET_PTRS_VALUE_omp_target_memcpy_rect(args);
				return;
			#endif
			#if HAVE_omp_target_memset_async
			case OMP_ROUTINE_API_ID_omp_target_memset_async : 
				GET_PTRS_VALUE_omp_target_memset_async(args);
				return;
			#endif
			#if HAVE_omp_get_interop_int
			case OMP_ROUTINE_API_ID_omp_get_interop_int : 
				GET_PTRS_VALUE_omp_get_interop_int(args);
				return;
			#endif
			#if HAVE_omp_get_interop_name
			case OMP_ROUTINE_API_ID_omp_get_interop_name : 
				GET_PTRS_RET_VALUE_omp_get_interop_name(args);
				return;
			#endif
			#if HAVE_omp_get_interop_ptr
			case OMP_ROUTINE_API_ID_omp_get_interop_ptr : 
				GET_PTRS_VALUE_omp_get_interop_ptr(args);
				return;
			#endif
			#if HAVE_omp_get_interop_str
			case OMP_ROUTINE_API_ID_omp_get_interop_str : 
				GET_PTRS_VALUE_omp_get_interop_str(args);
				GET_PTRS_RET_VALUE_omp_get_interop_str(args);
				return;
			#endif
			#if HAVE_omp_get_interop_type_desc
			case OMP_ROUTINE_API_ID_omp_get_interop_type_desc : 
				GET_PTRS_RET_VALUE_omp_get_interop_type_desc(args);
				return;
			#endif
            default : break;
        }
    } else {
        switch(id) {

            default : break;
        }
    }
}
#endif // OMP_ROUTINE_API_HELPER_H