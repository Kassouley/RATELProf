/**
 * @file omp_routine_api_helper.h
 * @brief Helper functions for managing OMP_ROUTINE API calls in the profiling framework.
 *
 * This file contains various utility functions used to handle OMP_ROUTINE API calls 
 * within the profiling system, including retrieving argument values and 
 * managing function identifiers.
 * 
 * @note THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 * 
 */

#ifndef OMP_ROUTINE_API_HELPER_H
#define OMP_ROUTINE_API_HELPER_H

#include <string.h>
#include <stdbool.h>
#include "domains/fun_proto/omp_routine_profiled_functions.h"
#include "omp.h" 

#define OMP_ROUTINE_STRING_SIZE_MAX 128

#ifdef ADD_API_PREFIX
#undef ADD_API_PREFIX
#endif
#define ADD_API_PREFIX(str) OMP_ROUTINE_API_##str


#define FOR_EACH_OMP_ROUTINE_FUNC(macro) \
IF_ENABLED(omp_target_memset, macro)               \
IF_ENABLED(omp_target_memcpy_async, macro)         \
IF_ENABLED(omp_target_memcpy_rect_async, macro)    \
IF_ENABLED(omp_target_alloc, macro)                \
IF_ENABLED(omp_target_free, macro)                 \
IF_ENABLED(omp_target_memcpy_rect, macro)          \
IF_ENABLED(omp_target_disassociate_ptr, macro)     \
IF_ENABLED(omp_target_memcpy, macro)               \
IF_ENABLED(omp_target_memset_async, macro)         \
IF_ENABLED(omp_target_is_present, macro)           \
IF_ENABLED(omp_target_associate_ptr, macro)        \
IF_ENABLED(omp_get_initial_device, macro)          \
IF_ENABLED(llvm_omp_target_dynamic_shared_alloc, macro) \
IF_ENABLED(omp_get_interop_int, macro)             \
IF_ENABLED(omp_get_interop_name, macro)            \
IF_ENABLED(omp_get_interop_ptr, macro)             \
IF_ENABLED(omp_get_interop_str, macro)             \
IF_ENABLED(omp_get_interop_type_desc, macro)       \
IF_ENABLED(omp_get_mapped_ptr, macro)              \
IF_ENABLED(omp_get_num_devices, macro)             \
IF_ENABLED(omp_is_coarse_grain_mem_region, macro)  \


/**
 * @enum omp_routine_api_id_t 
 * @brief Enumeration of OMP_ROUTINE API function identifiers.
 *
 * This enumeration defines unique identifiers for various OMP_ROUTINE API functions. 
 * These identifiers are used for profiling, tracking, and identifying specific OMP_ROUTINE function calls.
 */
typedef enum omp_routine_api_id_e {
    FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNC_API_ID)
    OMP_ROUTINE_API_ID_NB_FUNCTION,
    OMP_ROUTINE_API_ID_UNKNOWN,
} omp_routine_api_id_t;


/**
 * @brief Retrieves the function name corresponding to a given OMP_ROUTINE API function ID.
 *
 * This function maps a OMP_ROUTINE API function identifier (`omp_routine_api_id_t`) to its corresponding function name
 * as a string. If the provided function ID does not match any known functions, the function returns `NULL`.
 *
 * @param id The OMP_ROUTINE API function identifier of type `omp_routine_api_id_t`.
 * @return A constant string representing the function name, or `NULL` if the ID is unknown.
 */
static inline const char* get_omp_routine_funame_by_id(omp_routine_api_id_t id) 
{
    switch(id) {
        FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNAME_BY_ID_OF)
        default : return NULL;
    }
    return NULL;
}


/**
 * @brief Retrieves the function pointer corresponding to a given OMP_ROUTINE API function ID.
 *
 * This function maps a OMP_ROUTINE API function ID (`omp_routine_api_id_t`) to its corresponding function address.
 * If the provided function ID does not match any known functions, the function returns `NULL`.
 *
 * @param id The function ID of type `omp_routine_api_id_t`.
 * @return A pointer to the corresponding OMP_ROUTINE API function, or `NULL` if not found.
 */
static inline void* get_omp_routine_funaddr_by_id(omp_routine_api_id_t id) 
{
    switch(id) {
        FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNADDR_BY_ID_OF)
        default : return NULL;
    }
    return NULL;
}


/**
 * @brief Retrieves the OMP_ROUTINE API function ID corresponding to a given function name.
 *
 * This function maps a OMP_ROUTINE API function name (string) to its corresponding function ID (`omp_routine_api_id_t`).
 * If the provided function name does not match any known functions, the function returns `OMP_ROUTINE_API_ID_UNKNOWN`.
 *
 * @param name The function name as a null-terminated string.
 * @return The corresponding OMP_ROUTINE API function ID of type `omp_routine_api_id_t`, or `OMP_ROUTINE_API_ID_UNKNOWN` if not found.
 */
static inline omp_routine_api_id_t get_omp_routine_funid_by_name(const char* name) 
{
    if (name == NULL) return OMP_ROUTINE_API_ID_UNKNOWN;
    FOR_EACH_OMP_ROUTINE_FUNC(GET_FUNID_BY_NAME_OF)
    return OMP_ROUTINE_API_ID_UNKNOWN;
}


// OMP_ROUTINE API Args Data
/**
 * @brief Structure to hold the arguments for the `omp_target_memset` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memset` function call.
 *
 * @struct args_omp_target_memset_t
 *
 * @note 
 *	void *
 *	omp_target_memset (
 *			void * ptr (void *)
 *			int value (int)
 *			size_t size (unsigned long)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_memset
typedef struct {
	void * ptr;
	int value;
	size_t size;
	int device_num;
	void * retval;
} args_omp_target_memset_t;

#define GET_ARGS_VALUE_omp_target_memset(activity) { \
	args_omp_target_memset_t* args = (args_omp_target_memset_t*) activity->args; \
	args->ptr = (void *) ptr; \
	args->value = (int) value; \
	args->size = (size_t) size; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy_async` function call.
 *
 * @struct args_omp_target_memcpy_async_t
 *
 * @note 
 *	int
 *	omp_target_memcpy_async (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t size (unsigned long)
 *			size_t dst_offset (unsigned long)
 *			size_t src_offset (unsigned long)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *			int async_depend_info (int)
 *			omp_depend_t * depend (void **)
 *	)
 */
#if HAVE_omp_target_memcpy_async
typedef struct {
	void * dst;
	void * src;
	size_t size;
	size_t dst_offset;
	size_t src_offset;
	int dst_device_num;
	int src_device_num;
	int async_depend_info;
	void ** depend;
	struct {
		void* ptr1;
	} depend__ref;
	int retval;
} args_omp_target_memcpy_async_t;

#define GET_ARGS_VALUE_omp_target_memcpy_async(activity) { \
	args_omp_target_memcpy_async_t* args = (args_omp_target_memcpy_async_t*) activity->args; \
	args->dst = (void *) dst; \
	args->src = (void *) src; \
	args->size = (size_t) size; \
	args->dst_offset = (size_t) dst_offset; \
	args->src_offset = (size_t) src_offset; \
	args->dst_device_num = (int) dst_device_num; \
	args->src_device_num = (int) src_device_num; \
	args->async_depend_info = (int) async_depend_info; \
	args->depend = (void **) depend; \
};

#define GET_PTRS_VALUE_omp_target_memcpy_async(args) { \
	args_omp_target_memcpy_async_t* pargs = (args_omp_target_memcpy_async_t*) args; \
	if (pargs->depend != NULL) { \
		pargs->depend__ref.ptr1 = *pargs->depend; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy_rect_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy_rect_async` function call.
 *
 * @struct args_omp_target_memcpy_rect_async_t
 *
 * @note 
 *	int
 *	omp_target_memcpy_rect_async (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t element_size (unsigned long)
 *			int num_dims (int)
 *			const size_t * volume (const unsigned long *)
 *			const size_t * dst_offsets (const unsigned long *)
 *			const size_t * src_offsets (const unsigned long *)
 *			const size_t * dst_dimensions (const unsigned long *)
 *			const size_t * src_dimensions (const unsigned long *)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *			int depobj_count (int)
 *			omp_depend_t * depobj_list (void **)
 *	)
 */
#if HAVE_omp_target_memcpy_rect_async
typedef struct {
	void * dst;
	void * src;
	size_t element_size;
	int num_dims;
	size_t * volume;
	struct {
		size_t val;
	} volume__ref;
	size_t * dst_offsets;
	struct {
		size_t val;
	} dst_offsets__ref;
	size_t * src_offsets;
	struct {
		size_t val;
	} src_offsets__ref;
	size_t * dst_dimensions;
	struct {
		size_t val;
	} dst_dimensions__ref;
	size_t * src_dimensions;
	struct {
		size_t val;
	} src_dimensions__ref;
	int dst_device_num;
	int src_device_num;
	int depobj_count;
	void ** depobj_list;
	struct {
		void* ptr1;
	} depobj_list__ref;
	int retval;
} args_omp_target_memcpy_rect_async_t;

#define GET_ARGS_VALUE_omp_target_memcpy_rect_async(activity) { \
	args_omp_target_memcpy_rect_async_t* args = (args_omp_target_memcpy_rect_async_t*) activity->args; \
	args->dst = (void *) dst; \
	args->src = (void *) src; \
	args->element_size = (size_t) element_size; \
	args->num_dims = (int) num_dims; \
	args->volume = (size_t *) volume; \
	args->dst_offsets = (size_t *) dst_offsets; \
	args->src_offsets = (size_t *) src_offsets; \
	args->dst_dimensions = (size_t *) dst_dimensions; \
	args->src_dimensions = (size_t *) src_dimensions; \
	args->dst_device_num = (int) dst_device_num; \
	args->src_device_num = (int) src_device_num; \
	args->depobj_count = (int) depobj_count; \
	args->depobj_list = (void **) depobj_list; \
};

#define GET_PTRS_VALUE_omp_target_memcpy_rect_async(args) { \
	args_omp_target_memcpy_rect_async_t* pargs = (args_omp_target_memcpy_rect_async_t*) args; \
	if (pargs->volume != NULL) { \
		pargs->volume__ref.val = *pargs->volume; \
	} \
	if (pargs->dst_offsets != NULL) { \
		pargs->dst_offsets__ref.val = *pargs->dst_offsets; \
	} \
	if (pargs->src_offsets != NULL) { \
		pargs->src_offsets__ref.val = *pargs->src_offsets; \
	} \
	if (pargs->dst_dimensions != NULL) { \
		pargs->dst_dimensions__ref.val = *pargs->dst_dimensions; \
	} \
	if (pargs->src_dimensions != NULL) { \
		pargs->src_dimensions__ref.val = *pargs->src_dimensions; \
	} \
	if (pargs->depobj_list != NULL) { \
		pargs->depobj_list__ref.ptr1 = *pargs->depobj_list; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_alloc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_alloc` function call.
 *
 * @struct args_omp_target_alloc_t
 *
 * @note 
 *	void *
 *	omp_target_alloc (
 *			size_t size (unsigned long)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_alloc
typedef struct {
	size_t size;
	int device_num;
	void * retval;
} args_omp_target_alloc_t;

#define GET_ARGS_VALUE_omp_target_alloc(activity) { \
	args_omp_target_alloc_t* args = (args_omp_target_alloc_t*) activity->args; \
	args->size = (size_t) size; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_free` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_free` function call.
 *
 * @struct args_omp_target_free_t
 *
 * @note 
 *	void
 *	omp_target_free (
 *			void * device_ptr (void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_free
typedef struct {
	void * device_ptr;
	int device_num;
} args_omp_target_free_t;

#define GET_ARGS_VALUE_omp_target_free(activity) { \
	args_omp_target_free_t* args = (args_omp_target_free_t*) activity->args; \
	args->device_ptr = (void *) device_ptr; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy_rect` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy_rect` function call.
 *
 * @struct args_omp_target_memcpy_rect_t
 *
 * @note 
 *	int
 *	omp_target_memcpy_rect (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t element_size (unsigned long)
 *			int num_dims (int)
 *			const size_t * volume (const unsigned long *)
 *			const size_t * dst_offsets (const unsigned long *)
 *			const size_t * src_offsets (const unsigned long *)
 *			const size_t * dst_dimensions (const unsigned long *)
 *			const size_t * src_dimensions (const unsigned long *)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *	)
 */
#if HAVE_omp_target_memcpy_rect
typedef struct {
	void * dst;
	void * src;
	size_t element_size;
	int num_dims;
	size_t * volume;
	struct {
		size_t val;
	} volume__ref;
	size_t * dst_offsets;
	struct {
		size_t val;
	} dst_offsets__ref;
	size_t * src_offsets;
	struct {
		size_t val;
	} src_offsets__ref;
	size_t * dst_dimensions;
	struct {
		size_t val;
	} dst_dimensions__ref;
	size_t * src_dimensions;
	struct {
		size_t val;
	} src_dimensions__ref;
	int dst_device_num;
	int src_device_num;
	int retval;
} args_omp_target_memcpy_rect_t;

#define GET_ARGS_VALUE_omp_target_memcpy_rect(activity) { \
	args_omp_target_memcpy_rect_t* args = (args_omp_target_memcpy_rect_t*) activity->args; \
	args->dst = (void *) dst; \
	args->src = (void *) src; \
	args->element_size = (size_t) element_size; \
	args->num_dims = (int) num_dims; \
	args->volume = (size_t *) volume; \
	args->dst_offsets = (size_t *) dst_offsets; \
	args->src_offsets = (size_t *) src_offsets; \
	args->dst_dimensions = (size_t *) dst_dimensions; \
	args->src_dimensions = (size_t *) src_dimensions; \
	args->dst_device_num = (int) dst_device_num; \
	args->src_device_num = (int) src_device_num; \
};

#define GET_PTRS_VALUE_omp_target_memcpy_rect(args) { \
	args_omp_target_memcpy_rect_t* pargs = (args_omp_target_memcpy_rect_t*) args; \
	if (pargs->volume != NULL) { \
		pargs->volume__ref.val = *pargs->volume; \
	} \
	if (pargs->dst_offsets != NULL) { \
		pargs->dst_offsets__ref.val = *pargs->dst_offsets; \
	} \
	if (pargs->src_offsets != NULL) { \
		pargs->src_offsets__ref.val = *pargs->src_offsets; \
	} \
	if (pargs->dst_dimensions != NULL) { \
		pargs->dst_dimensions__ref.val = *pargs->dst_dimensions; \
	} \
	if (pargs->src_dimensions != NULL) { \
		pargs->src_dimensions__ref.val = *pargs->src_dimensions; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_disassociate_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_disassociate_ptr` function call.
 *
 * @struct args_omp_target_disassociate_ptr_t
 *
 * @note 
 *	int
 *	omp_target_disassociate_ptr (
 *			const void * host_ptr (const void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_disassociate_ptr
typedef struct {
	void * host_ptr;
	int device_num;
	int retval;
} args_omp_target_disassociate_ptr_t;

#define GET_ARGS_VALUE_omp_target_disassociate_ptr(activity) { \
	args_omp_target_disassociate_ptr_t* args = (args_omp_target_disassociate_ptr_t*) activity->args; \
	args->host_ptr = (void *) host_ptr; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memcpy` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memcpy` function call.
 *
 * @struct args_omp_target_memcpy_t
 *
 * @note 
 *	int
 *	omp_target_memcpy (
 *			void * dst (void *)
 *			const void * src (const void *)
 *			size_t size (unsigned long)
 *			size_t dst_offset (unsigned long)
 *			size_t src_offset (unsigned long)
 *			int dst_device_num (int)
 *			int src_device_num (int)
 *	)
 */
#if HAVE_omp_target_memcpy
typedef struct {
	void * dst;
	void * src;
	size_t size;
	size_t dst_offset;
	size_t src_offset;
	int dst_device_num;
	int src_device_num;
	int retval;
} args_omp_target_memcpy_t;

#define GET_ARGS_VALUE_omp_target_memcpy(activity) { \
	args_omp_target_memcpy_t* args = (args_omp_target_memcpy_t*) activity->args; \
	args->dst = (void *) dst; \
	args->src = (void *) src; \
	args->size = (size_t) size; \
	args->dst_offset = (size_t) dst_offset; \
	args->src_offset = (size_t) src_offset; \
	args->dst_device_num = (int) dst_device_num; \
	args->src_device_num = (int) src_device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_memset_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_memset_async` function call.
 *
 * @struct args_omp_target_memset_async_t
 *
 * @note 
 *	void *
 *	omp_target_memset_async (
 *			void * ptr (void *)
 *			int value (int)
 *			size_t size (unsigned long)
 *			int device_num (int)
 *			int async_depend_info (int)
 *			omp_depend_t * depend (void **)
 *	)
 */
#if HAVE_omp_target_memset_async
typedef struct {
	void * ptr;
	int value;
	size_t size;
	int device_num;
	int async_depend_info;
	void ** depend;
	struct {
		void* ptr1;
	} depend__ref;
	void * retval;
} args_omp_target_memset_async_t;

#define GET_ARGS_VALUE_omp_target_memset_async(activity) { \
	args_omp_target_memset_async_t* args = (args_omp_target_memset_async_t*) activity->args; \
	args->ptr = (void *) ptr; \
	args->value = (int) value; \
	args->size = (size_t) size; \
	args->device_num = (int) device_num; \
	args->async_depend_info = (int) async_depend_info; \
	args->depend = (void **) depend; \
};

#define GET_PTRS_VALUE_omp_target_memset_async(args) { \
	args_omp_target_memset_async_t* pargs = (args_omp_target_memset_async_t*) args; \
	if (pargs->depend != NULL) { \
		pargs->depend__ref.ptr1 = *pargs->depend; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_is_present` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_is_present` function call.
 *
 * @struct args_omp_target_is_present_t
 *
 * @note 
 *	int
 *	omp_target_is_present (
 *			const void * host_ptr (const void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_is_present
typedef struct {
	void * host_ptr;
	int device_num;
	int retval;
} args_omp_target_is_present_t;

#define GET_ARGS_VALUE_omp_target_is_present(activity) { \
	args_omp_target_is_present_t* args = (args_omp_target_is_present_t*) activity->args; \
	args->host_ptr = (void *) host_ptr; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_target_associate_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_target_associate_ptr` function call.
 *
 * @struct args_omp_target_associate_ptr_t
 *
 * @note 
 *	int
 *	omp_target_associate_ptr (
 *			const void * host_ptr (const void *)
 *			const void * device_ptr (const void *)
 *			size_t size (unsigned long)
 *			size_t alignment (unsigned long)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_target_associate_ptr
typedef struct {
	void * host_ptr;
	void * device_ptr;
	size_t size;
	size_t alignment;
	int device_num;
	int retval;
} args_omp_target_associate_ptr_t;

#define GET_ARGS_VALUE_omp_target_associate_ptr(activity) { \
	args_omp_target_associate_ptr_t* args = (args_omp_target_associate_ptr_t*) activity->args; \
	args->host_ptr = (void *) host_ptr; \
	args->device_ptr = (void *) device_ptr; \
	args->size = (size_t) size; \
	args->alignment = (size_t) alignment; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_initial_device` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_initial_device` function call.
 *
 * @struct args_omp_get_initial_device_t
 *
 * @note 
 *	int
 *	omp_get_initial_device (
 *	)
 */
#if HAVE_omp_get_initial_device
typedef struct {
	int retval;
} args_omp_get_initial_device_t;

#endif

/**
 * @brief Structure to hold the arguments for the `llvm_omp_target_dynamic_shared_alloc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `llvm_omp_target_dynamic_shared_alloc` function call.
 *
 * @struct args_llvm_omp_target_dynamic_shared_alloc_t
 *
 * @note 
 *	void *
 *	llvm_omp_target_dynamic_shared_alloc (
 *	)
 */
#if HAVE_llvm_omp_target_dynamic_shared_alloc
typedef struct {
	void * retval;
} args_llvm_omp_target_dynamic_shared_alloc_t;

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_int` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_int` function call.
 *
 * @struct args_omp_get_interop_int_t
 *
 * @note 
 *	omp_intptr_t
 *	omp_get_interop_int (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *			int * exists (int *)
 *	)
 */
#if HAVE_omp_get_interop_int
typedef struct {
	void * interop;
	omp_interop_property_t prop;
	int * exists;
	struct {
		int val;
	} exists__ref;
	omp_intptr_t retval;
} args_omp_get_interop_int_t;

#define GET_ARGS_VALUE_omp_get_interop_int(activity) { \
	args_omp_get_interop_int_t* args = (args_omp_get_interop_int_t*) activity->args; \
	args->interop = (void *) interop; \
	args->prop = (omp_interop_property_t) prop; \
	args->exists = (int *) exists; \
};

#define GET_PTRS_VALUE_omp_get_interop_int(args) { \
	args_omp_get_interop_int_t* pargs = (args_omp_get_interop_int_t*) args; \
	if (pargs->exists != NULL) { \
		pargs->exists__ref.val = *pargs->exists; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_name` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_name` function call.
 *
 * @struct args_omp_get_interop_name_t
 *
 * @note 
 *	const char *
 *	omp_get_interop_name (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *	)
 */
#if HAVE_omp_get_interop_name
typedef struct {
	void * interop;
	omp_interop_property_t prop;
	char * retval;
	struct {
		char val[OMP_ROUTINE_STRING_SIZE_MAX];
	} retval__ref;
} args_omp_get_interop_name_t;

#define GET_ARGS_VALUE_omp_get_interop_name(activity) { \
	args_omp_get_interop_name_t* args = (args_omp_get_interop_name_t*) activity->args; \
	args->interop = (void *) interop; \
	args->prop = (omp_interop_property_t) prop; \
};

#define GET_PTRS_RET_VALUE_omp_get_interop_name(args) { \
	args_omp_get_interop_name_t* pargs = (args_omp_get_interop_name_t*) args; \
	if (pargs->retval != NULL) { \
		strncpy(pargs->retval__ref.val, pargs->retval, OMP_ROUTINE_STRING_SIZE_MAX-1); \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_ptr` function call.
 *
 * @struct args_omp_get_interop_ptr_t
 *
 * @note 
 *	void *
 *	omp_get_interop_ptr (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *			int * exists (int *)
 *	)
 */
#if HAVE_omp_get_interop_ptr
typedef struct {
	void * interop;
	omp_interop_property_t prop;
	int * exists;
	struct {
		int val;
	} exists__ref;
	void * retval;
} args_omp_get_interop_ptr_t;

#define GET_ARGS_VALUE_omp_get_interop_ptr(activity) { \
	args_omp_get_interop_ptr_t* args = (args_omp_get_interop_ptr_t*) activity->args; \
	args->interop = (void *) interop; \
	args->prop = (omp_interop_property_t) prop; \
	args->exists = (int *) exists; \
};

#define GET_PTRS_VALUE_omp_get_interop_ptr(args) { \
	args_omp_get_interop_ptr_t* pargs = (args_omp_get_interop_ptr_t*) args; \
	if (pargs->exists != NULL) { \
		pargs->exists__ref.val = *pargs->exists; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_str` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_str` function call.
 *
 * @struct args_omp_get_interop_str_t
 *
 * @note 
 *	const char *
 *	omp_get_interop_str (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *			int * exists (int *)
 *	)
 */
#if HAVE_omp_get_interop_str
typedef struct {
	void * interop;
	omp_interop_property_t prop;
	int * exists;
	struct {
		int val;
	} exists__ref;
	char * retval;
	struct {
		char val[OMP_ROUTINE_STRING_SIZE_MAX];
	} retval__ref;
} args_omp_get_interop_str_t;

#define GET_ARGS_VALUE_omp_get_interop_str(activity) { \
	args_omp_get_interop_str_t* args = (args_omp_get_interop_str_t*) activity->args; \
	args->interop = (void *) interop; \
	args->prop = (omp_interop_property_t) prop; \
	args->exists = (int *) exists; \
};

#define GET_PTRS_VALUE_omp_get_interop_str(args) { \
	args_omp_get_interop_str_t* pargs = (args_omp_get_interop_str_t*) args; \
	if (pargs->exists != NULL) { \
		pargs->exists__ref.val = *pargs->exists; \
	} \
};

#define GET_PTRS_RET_VALUE_omp_get_interop_str(args) { \
	args_omp_get_interop_str_t* pargs = (args_omp_get_interop_str_t*) args; \
	if (pargs->retval != NULL) { \
		strncpy(pargs->retval__ref.val, pargs->retval, OMP_ROUTINE_STRING_SIZE_MAX-1); \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_interop_type_desc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_interop_type_desc` function call.
 *
 * @struct args_omp_get_interop_type_desc_t
 *
 * @note 
 *	const char *
 *	omp_get_interop_type_desc (
 *			const omp_interop_t interop (const void *)
 *			omp_interop_property_t prop (enum omp_interop_property)
 *	)
 */
#if HAVE_omp_get_interop_type_desc
typedef struct {
	void * interop;
	omp_interop_property_t prop;
	char * retval;
	struct {
		char val[OMP_ROUTINE_STRING_SIZE_MAX];
	} retval__ref;
} args_omp_get_interop_type_desc_t;

#define GET_ARGS_VALUE_omp_get_interop_type_desc(activity) { \
	args_omp_get_interop_type_desc_t* args = (args_omp_get_interop_type_desc_t*) activity->args; \
	args->interop = (void *) interop; \
	args->prop = (omp_interop_property_t) prop; \
};

#define GET_PTRS_RET_VALUE_omp_get_interop_type_desc(args) { \
	args_omp_get_interop_type_desc_t* pargs = (args_omp_get_interop_type_desc_t*) args; \
	if (pargs->retval != NULL) { \
		strncpy(pargs->retval__ref.val, pargs->retval, OMP_ROUTINE_STRING_SIZE_MAX-1); \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_mapped_ptr` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_mapped_ptr` function call.
 *
 * @struct args_omp_get_mapped_ptr_t
 *
 * @note 
 *	void *
 *	omp_get_mapped_ptr (
 *			const void * ptr (const void *)
 *			int device_num (int)
 *	)
 */
#if HAVE_omp_get_mapped_ptr
typedef struct {
	void * ptr;
	int device_num;
	void * retval;
} args_omp_get_mapped_ptr_t;

#define GET_ARGS_VALUE_omp_get_mapped_ptr(activity) { \
	args_omp_get_mapped_ptr_t* args = (args_omp_get_mapped_ptr_t*) activity->args; \
	args->ptr = (void *) ptr; \
	args->device_num = (int) device_num; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `omp_get_num_devices` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_get_num_devices` function call.
 *
 * @struct args_omp_get_num_devices_t
 *
 * @note 
 *	int
 *	omp_get_num_devices (
 *	)
 */
#if HAVE_omp_get_num_devices
typedef struct {
	int retval;
} args_omp_get_num_devices_t;

#endif

/**
 * @brief Structure to hold the arguments for the `omp_is_coarse_grain_mem_region` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `omp_is_coarse_grain_mem_region` function call.
 *
 * @struct args_omp_is_coarse_grain_mem_region_t
 *
 * @note 
 *	int
 *	omp_is_coarse_grain_mem_region (
 *			void * ptr (void *)
 *			size_t size (unsigned long)
 *	)
 */
#if HAVE_omp_is_coarse_grain_mem_region
typedef struct {
	void * ptr;
	size_t size;
	int retval;
} args_omp_is_coarse_grain_mem_region_t;

#define GET_ARGS_VALUE_omp_is_coarse_grain_mem_region(activity) { \
	args_omp_is_coarse_grain_mem_region_t* args = (args_omp_is_coarse_grain_mem_region_t*) activity->args; \
	args->ptr = (void *) ptr; \
	args->size = (size_t) size; \
};

#endif



/**
 * @brief Retrieves pointer-based argument values for OMP_ROUTINE API calls.
 *
 * This function extracts pointer-based arguments based on the given OMP_ROUTINE API ID.
 *
 * @param[in] id The OMP_ROUTINE API function identifier.
 * @param[in,out] args Pointer to the OMP_ROUTINE API arguments structure.
 * @param[in] is_enter Boolean flag indicating whether this function is handling an "enter" or "exit" event.
 */
static inline void get_omp_routine_pointed_args_for(omp_routine_api_id_t id, void* args, bool is_enter) 
{
    if (!is_enter) {
        switch(id) {
			#if HAVE_omp_target_memcpy_async
			case OMP_ROUTINE_API_ID_omp_target_memcpy_async : {
				GET_PTRS_VALUE_omp_target_memcpy_async(args);
				return;
			}
			#endif
			#if HAVE_omp_target_memcpy_rect_async
			case OMP_ROUTINE_API_ID_omp_target_memcpy_rect_async : {
				GET_PTRS_VALUE_omp_target_memcpy_rect_async(args);
				return;
			}
			#endif
			#if HAVE_omp_target_memcpy_rect
			case OMP_ROUTINE_API_ID_omp_target_memcpy_rect : {
				GET_PTRS_VALUE_omp_target_memcpy_rect(args);
				return;
			}
			#endif
			#if HAVE_omp_target_memset_async
			case OMP_ROUTINE_API_ID_omp_target_memset_async : {
				GET_PTRS_VALUE_omp_target_memset_async(args);
				return;
			}
			#endif
			#if HAVE_omp_get_interop_int
			case OMP_ROUTINE_API_ID_omp_get_interop_int : {
				GET_PTRS_VALUE_omp_get_interop_int(args);
				return;
			}
			#endif
			#if HAVE_omp_get_interop_name
			case OMP_ROUTINE_API_ID_omp_get_interop_name : {
				GET_PTRS_RET_VALUE_omp_get_interop_name(args);
				return;
			}
			#endif
			#if HAVE_omp_get_interop_ptr
			case OMP_ROUTINE_API_ID_omp_get_interop_ptr : {
				GET_PTRS_VALUE_omp_get_interop_ptr(args);
				return;
			}
			#endif
			#if HAVE_omp_get_interop_str
			case OMP_ROUTINE_API_ID_omp_get_interop_str : {
				GET_PTRS_VALUE_omp_get_interop_str(args);
				GET_PTRS_RET_VALUE_omp_get_interop_str(args);
				return;
			}
			#endif
			#if HAVE_omp_get_interop_type_desc
			case OMP_ROUTINE_API_ID_omp_get_interop_type_desc : {
				GET_PTRS_RET_VALUE_omp_get_interop_type_desc(args);
				return;
			}
			#endif
            default : break;
        }
    } else {
        switch(id) {

            default : break;
        }
    }
}
#endif // OMP_ROUTINE_API_HELPER_H