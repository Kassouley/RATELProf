/**
 * @file omp_tgt_rtl_api_helper.h
 * @brief Helper functions for managing OMP_TGT_RTL API calls in the profiling framework.
 *
 * This file contains various utility functions used to handle OMP_TGT_RTL API calls 
 * within the profiling system, including retrieving argument values and 
 * managing function identifiers.
 * 
 * @note THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 * 
 */

#ifndef OMP_TGT_RTL_API_HELPER_H
#define OMP_TGT_RTL_API_HELPER_H

#include <string.h>
#include <stdbool.h>
#include "domains/fun_proto/omp_tgt_rtl_profiled_functions.h"
#include "omp_support.h" 

#define OMP_TGT_RTL_STRING_SIZE_MAX 128

#ifdef ADD_API_PREFIX
#undef ADD_API_PREFIX
#endif
#define ADD_API_PREFIX(str) OMP_TGT_RTL_API_##str


#define FOR_EACH_OMP_TGT_RTL_FUNC(macro) \
IF_ENABLED(__tgt_rtl_query_async, macro)           \
IF_ENABLED(__tgt_rtl_data_submit, macro)           \
IF_ENABLED(__tgt_rtl_are_allocations_for_maps_on_apus_disabled, macro) \
IF_ENABLED(__tgt_rtl_data_notify_mapped, macro)    \
IF_ENABLED(__tgt_rtl_data_submit_async, macro)     \
IF_ENABLED(__tgt_rtl_init_async_info, macro)       \
IF_ENABLED(__tgt_rtl_is_data_exchangable, macro)   \
IF_ENABLED(__tgt_rtl_data_retrieve_async, macro)   \
IF_ENABLED(__tgt_rtl_data_delete, macro)           \
IF_ENABLED(__tgt_rtl_data_exchange_async, macro)   \
IF_ENABLED(__tgt_rtl_prepopulate_page_table, macro) \
IF_ENABLED(__tgt_rtl_data_exchange, macro)         \
IF_ENABLED(__tgt_rtl_launch_kernel, macro)         \
IF_ENABLED(__tgt_rtl_is_valid_binary, macro)       \
IF_ENABLED(__tgt_rtl_data_retrieve, macro)         \
IF_ENABLED(__tgt_rtl_data_lock, macro)             \
IF_ENABLED(__tgt_rtl_supports_empty_images, macro) \
IF_ENABLED(__tgt_rtl_destroy_event, macro)         \
IF_ENABLED(__tgt_rtl_number_of_devices, macro)     \
IF_ENABLED(__tgt_rtl_init_requires, macro)         \
IF_ENABLED(__tgt_rtl_data_notify_unmapped, macro)  \
IF_ENABLED(__tgt_rtl_init_device_info, macro)      \
IF_ENABLED(__tgt_rtl_sync_event, macro)            \
IF_ENABLED(__tgt_rtl_synchronize, macro)           \
IF_ENABLED(__tgt_rtl_set_up_env, macro)            \
IF_ENABLED(__tgt_rtl_data_unlock, macro)           \
IF_ENABLED(__tgt_rtl_is_fine_grained_memory_enabled, macro) \
IF_ENABLED(__tgt_rtl_has_USM_capable_dGPU, macro)  \
IF_ENABLED(__tgt_rtl_has_apu_device, macro)        \
IF_ENABLED(__tgt_rtl_set_device_offset, macro)     \
IF_ENABLED(__tgt_rtl_launch_kernel_sync, macro)    \
IF_ENABLED(__tgt_rtl_record_event, macro)          \
IF_ENABLED(__tgt_rtl_set_info_flag, macro)         \
IF_ENABLED(__tgt_rtl_create_event, macro)          \
IF_ENABLED(__tgt_rtl_print_device_info, macro)     \
IF_ENABLED(__tgt_rtl_get_function, macro)          \
IF_ENABLED(__tgt_rtl_init_plugin, macro)           \
IF_ENABLED(__tgt_rtl_number_of_team_procs, macro)  \
IF_ENABLED(__tgt_rtl_wait_event, macro)            \
IF_ENABLED(__tgt_rtl_data_alloc, macro)            \
IF_ENABLED(__tgt_rtl_init_device, macro)           \
IF_ENABLED(__tgt_rtl_get_global, macro)            \
IF_ENABLED(__tgt_rtl_requested_prepopulate_gpu_page_table, macro) \


/**
 * @enum omp_tgt_rtl_api_id_t 
 * @brief Enumeration of OMP_TGT_RTL API function identifiers.
 *
 * This enumeration defines unique identifiers for various OMP_TGT_RTL API functions. 
 * These identifiers are used for profiling, tracking, and identifying specific OMP_TGT_RTL function calls.
 */
typedef enum omp_egt_rtl_api_id_e {
    FOR_EACH_OMP_TGT_RTL_FUNC(GET_FUNC_API_ID)
    OMP_TGT_RTL_API_ID_NB_FUNCTION,
    OMP_TGT_RTL_API_ID_UNKNOWN,
} omp_tgt_rtl_api_id_t;


/**
 * @brief Retrieves the function name corresponding to a given OMP_TGT_RTL API function ID.
 *
 * This function maps a OMP_TGT_RTL API function identifier (`omp_tgt_rtl_api_id_t`) to its corresponding function name
 * as a string. If the provided function ID does not match any known functions, the function returns `NULL`.
 *
 * @param id The OMP_TGT_RTL API function identifier of type `omp_tgt_rtl_api_id_t`.
 * @return A constant string representing the function name, or `NULL` if the ID is unknown.
 */
static inline const char* get_omp_tgt_rtl_funame_by_id(omp_tgt_rtl_api_id_t id) 
{
    switch(id) {
        FOR_EACH_OMP_TGT_RTL_FUNC(GET_FUNAME_BY_ID_OF)
        default : return NULL;
    }
    return NULL;
}


/**
 * @brief Retrieves the function pointer corresponding to a given OMP_TGT_RTL API function ID.
 *
 * This function maps a OMP_TGT_RTL API function ID (`omp_tgt_rtl_api_id_t`) to its corresponding function address.
 * If the provided function ID does not match any known functions, the function returns `NULL`.
 *
 * @param id The function ID of type `omp_tgt_rtl_api_id_t`.
 * @return A pointer to the corresponding OMP_TGT_RTL API function, or `NULL` if not found.
 */
static inline void* get_omp_tgt_rtl_funaddr_by_id(omp_tgt_rtl_api_id_t id) 
{
    switch(id) {
        FOR_EACH_OMP_TGT_RTL_FUNC(GET_FUNADDR_BY_ID_OF)
        default : return NULL;
    }
    return NULL;
}


/**
 * @brief Retrieves the OMP_TGT_RTL API function ID corresponding to a given function name.
 *
 * This function maps a OMP_TGT_RTL API function name (string) to its corresponding function ID (`omp_tgt_rtl_api_id_t`).
 * If the provided function name does not match any known functions, the function returns `OMP_TGT_RTL_API_ID_UNKNOWN`.
 *
 * @param name The function name as a null-terminated string.
 * @return The corresponding OMP_TGT_RTL API function ID of type `omp_tgt_rtl_api_id_t`, or `OMP_TGT_RTL_API_ID_UNKNOWN` if not found.
 */
static inline omp_tgt_rtl_api_id_t get_omp_tgt_rtl_funid_by_name(const char* name) 
{
    if (name == NULL) return OMP_TGT_RTL_API_ID_UNKNOWN;
    FOR_EACH_OMP_TGT_RTL_FUNC(GET_FUNID_BY_NAME_OF)
    return OMP_TGT_RTL_API_ID_UNKNOWN;
}


// OMP_TGT_RTL API Args Data
/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_query_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_query_async` function call.
 *
 * @struct args___tgt_rtl_query_async_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_query_async (
 *			int32_t device_id (int)
 *			__tgt_async_info * AsyncInfoPtr (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_query_async
typedef struct {
	int32_t device_id;
	__tgt_async_info * AsyncInfoPtr;
	struct {
		__tgt_async_info val;
	} AsyncInfoPtr__ref;
	int32_t retval;
} args___tgt_rtl_query_async_t;

#define GET_ARGS_VALUE___tgt_rtl_query_async(activity) { \
	args___tgt_rtl_query_async_t* args = (args___tgt_rtl_query_async_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->AsyncInfoPtr = (__tgt_async_info *) AsyncInfoPtr; \
};

#define GET_PTRS_VALUE___tgt_rtl_query_async(args) { \
	args___tgt_rtl_query_async_t* pargs = (args___tgt_rtl_query_async_t*) args; \
	if (pargs->AsyncInfoPtr != NULL) { \
		pargs->AsyncInfoPtr__ref.val = *pargs->AsyncInfoPtr; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_submit` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_submit` function call.
 *
 * @struct args___tgt_rtl_data_submit_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_submit (
 *			int32_t device_id (int)
 *			void * target_ptr (void *)
 *			void * host_ptr (void *)
 *			int64_t size (long)
 *	)
 */
#if HAVE___tgt_rtl_data_submit
typedef struct {
	int32_t device_id;
	void * target_ptr;
	void * host_ptr;
	int64_t size;
	int32_t retval;
} args___tgt_rtl_data_submit_t;

#define GET_ARGS_VALUE___tgt_rtl_data_submit(activity) { \
	args___tgt_rtl_data_submit_t* args = (args___tgt_rtl_data_submit_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->target_ptr = (void *) target_ptr; \
	args->host_ptr = (void *) host_ptr; \
	args->size = (int64_t) size; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_are_allocations_for_maps_on_apus_disabled` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_are_allocations_for_maps_on_apus_disabled` function call.
 *
 * @struct args___tgt_rtl_are_allocations_for_maps_on_apus_disabled_t
 *
 * @note 
 *	int
 *	__tgt_rtl_are_allocations_for_maps_on_apus_disabled (
 *	)
 */
#if HAVE___tgt_rtl_are_allocations_for_maps_on_apus_disabled
typedef struct {
	int retval;
} args___tgt_rtl_are_allocations_for_maps_on_apus_disabled_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_notify_mapped` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_notify_mapped` function call.
 *
 * @struct args___tgt_rtl_data_notify_mapped_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_notify_mapped (
 *			int32_t device_id (int)
 *			void * host_ptr (void *)
 *			int64_t size (long)
 *	)
 */
#if HAVE___tgt_rtl_data_notify_mapped
typedef struct {
	int32_t device_id;
	void * host_ptr;
	int64_t size;
	int32_t retval;
} args___tgt_rtl_data_notify_mapped_t;

#define GET_ARGS_VALUE___tgt_rtl_data_notify_mapped(activity) { \
	args___tgt_rtl_data_notify_mapped_t* args = (args___tgt_rtl_data_notify_mapped_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->host_ptr = (void *) host_ptr; \
	args->size = (int64_t) size; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_submit_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_submit_async` function call.
 *
 * @struct args___tgt_rtl_data_submit_async_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_submit_async (
 *			int32_t device_id (int)
 *			void * target_ptr (void *)
 *			void * host_ptr (void *)
 *			int64_t size (long)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_data_submit_async
typedef struct {
	int32_t device_id;
	void * target_ptr;
	void * host_ptr;
	int64_t size;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_data_submit_async_t;

#define GET_ARGS_VALUE___tgt_rtl_data_submit_async(activity) { \
	args___tgt_rtl_data_submit_async_t* args = (args___tgt_rtl_data_submit_async_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->target_ptr = (void *) target_ptr; \
	args->host_ptr = (void *) host_ptr; \
	args->size = (int64_t) size; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_data_submit_async(args) { \
	args___tgt_rtl_data_submit_async_t* pargs = (args___tgt_rtl_data_submit_async_t*) args; \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_init_async_info` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_init_async_info` function call.
 *
 * @struct args___tgt_rtl_init_async_info_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_init_async_info (
 *			int32_t device_id (int)
 *			__tgt_async_info ** async_info_ptr (struct __tgt_async_info**)
 *	)
 */
#if HAVE___tgt_rtl_init_async_info
typedef struct {
	int32_t device_id;
	__tgt_async_info ** async_info_ptr;
	struct {
		void* ptr1;
		__tgt_async_info val;
	} async_info_ptr__ref;
	int32_t retval;
} args___tgt_rtl_init_async_info_t;

#define GET_ARGS_VALUE___tgt_rtl_init_async_info(activity) { \
	args___tgt_rtl_init_async_info_t* args = (args___tgt_rtl_init_async_info_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->async_info_ptr = (__tgt_async_info **) async_info_ptr; \
};

#define GET_PTRS_VALUE___tgt_rtl_init_async_info(args) { \
	args___tgt_rtl_init_async_info_t* pargs = (args___tgt_rtl_init_async_info_t*) args; \
	if (pargs->async_info_ptr != NULL) { \
		pargs->async_info_ptr__ref.ptr1 = *pargs->async_info_ptr; \
		if (pargs->async_info_ptr__ref.ptr1 != NULL) { \
			pargs->async_info_ptr__ref.val = **pargs->async_info_ptr; \
		} \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_is_data_exchangable` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_is_data_exchangable` function call.
 *
 * @struct args___tgt_rtl_is_data_exchangable_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_is_data_exchangable (
 *			int32_t src_dev_id (int)
 *			int32_t dst_dev_id (int)
 *	)
 */
#if HAVE___tgt_rtl_is_data_exchangable
typedef struct {
	int32_t src_dev_id;
	int32_t dst_dev_id;
	int32_t retval;
} args___tgt_rtl_is_data_exchangable_t;

#define GET_ARGS_VALUE___tgt_rtl_is_data_exchangable(activity) { \
	args___tgt_rtl_is_data_exchangable_t* args = (args___tgt_rtl_is_data_exchangable_t*) activity->args; \
	args->src_dev_id = (int32_t) src_dev_id; \
	args->dst_dev_id = (int32_t) dst_dev_id; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_retrieve_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_retrieve_async` function call.
 *
 * @struct args___tgt_rtl_data_retrieve_async_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_retrieve_async (
 *			int32_t device_id (int)
 *			void * host_ptr (void *)
 *			void * target_ptr (void *)
 *			int64_t size (long)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_data_retrieve_async
typedef struct {
	int32_t device_id;
	void * host_ptr;
	void * target_ptr;
	int64_t size;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_data_retrieve_async_t;

#define GET_ARGS_VALUE___tgt_rtl_data_retrieve_async(activity) { \
	args___tgt_rtl_data_retrieve_async_t* args = (args___tgt_rtl_data_retrieve_async_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->host_ptr = (void *) host_ptr; \
	args->target_ptr = (void *) target_ptr; \
	args->size = (int64_t) size; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_data_retrieve_async(args) { \
	args___tgt_rtl_data_retrieve_async_t* pargs = (args___tgt_rtl_data_retrieve_async_t*) args; \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_delete` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_delete` function call.
 *
 * @struct args___tgt_rtl_data_delete_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_delete (
 *			int32_t device_id (int)
 *			void * target_ptr (void *)
 *			int32_t kind (int)
 *	)
 */
#if HAVE___tgt_rtl_data_delete
typedef struct {
	int32_t device_id;
	void * target_ptr;
	int32_t kind;
	int32_t retval;
} args___tgt_rtl_data_delete_t;

#define GET_ARGS_VALUE___tgt_rtl_data_delete(activity) { \
	args___tgt_rtl_data_delete_t* args = (args___tgt_rtl_data_delete_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->target_ptr = (void *) target_ptr; \
	args->kind = (int32_t) kind; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_exchange_async` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_exchange_async` function call.
 *
 * @struct args___tgt_rtl_data_exchange_async_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_exchange_async (
 *			int32_t src_dev_id (int)
 *			void * src_ptr (void *)
 *			int32_t dst_dev_id (int)
 *			void * dst_ptr (void *)
 *			int64_t size (long)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_data_exchange_async
typedef struct {
	int32_t src_dev_id;
	void * src_ptr;
	int32_t dst_dev_id;
	void * dst_ptr;
	int64_t size;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_data_exchange_async_t;

#define GET_ARGS_VALUE___tgt_rtl_data_exchange_async(activity) { \
	args___tgt_rtl_data_exchange_async_t* args = (args___tgt_rtl_data_exchange_async_t*) activity->args; \
	args->src_dev_id = (int32_t) src_dev_id; \
	args->src_ptr = (void *) src_ptr; \
	args->dst_dev_id = (int32_t) dst_dev_id; \
	args->dst_ptr = (void *) dst_ptr; \
	args->size = (int64_t) size; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_data_exchange_async(args) { \
	args___tgt_rtl_data_exchange_async_t* pargs = (args___tgt_rtl_data_exchange_async_t*) args; \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_prepopulate_page_table` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_prepopulate_page_table` function call.
 *
 * @struct args___tgt_rtl_prepopulate_page_table_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_prepopulate_page_table (
 *			int32_t device_id (int)
 *			void * ptr (void *)
 *			int64_t size (long)
 *	)
 */
#if HAVE___tgt_rtl_prepopulate_page_table
typedef struct {
	int32_t device_id;
	void * ptr;
	int64_t size;
	int32_t retval;
} args___tgt_rtl_prepopulate_page_table_t;

#define GET_ARGS_VALUE___tgt_rtl_prepopulate_page_table(activity) { \
	args___tgt_rtl_prepopulate_page_table_t* args = (args___tgt_rtl_prepopulate_page_table_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->ptr = (void *) ptr; \
	args->size = (int64_t) size; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_exchange` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_exchange` function call.
 *
 * @struct args___tgt_rtl_data_exchange_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_exchange (
 *			int32_t src_dev_id (int)
 *			void * src_ptr (void *)
 *			int32_t dst_dev_id (int)
 *			void * dst_ptr (void *)
 *			int64_t size (long)
 *	)
 */
#if HAVE___tgt_rtl_data_exchange
typedef struct {
	int32_t src_dev_id;
	void * src_ptr;
	int32_t dst_dev_id;
	void * dst_ptr;
	int64_t size;
	int32_t retval;
} args___tgt_rtl_data_exchange_t;

#define GET_ARGS_VALUE___tgt_rtl_data_exchange(activity) { \
	args___tgt_rtl_data_exchange_t* args = (args___tgt_rtl_data_exchange_t*) activity->args; \
	args->src_dev_id = (int32_t) src_dev_id; \
	args->src_ptr = (void *) src_ptr; \
	args->dst_dev_id = (int32_t) dst_dev_id; \
	args->dst_ptr = (void *) dst_ptr; \
	args->size = (int64_t) size; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_launch_kernel` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_launch_kernel` function call.
 *
 * @struct args___tgt_rtl_launch_kernel_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_launch_kernel (
 *			int32_t device_id (int)
 *			void * tgt_entry_ptr (void *)
 *			void ** tgt_args (void **)
 *			ptrdiff_t * tgt_offsets (long*)
 *			KernelArgsTy * KernelArgs (struct KernelArgsTy*)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_launch_kernel
typedef struct {
	int32_t device_id;
	void * tgt_entry_ptr;
	void ** tgt_args;
	struct {
		void* ptr1;
	} tgt_args__ref;
	ptrdiff_t * tgt_offsets;
	struct {
		ptrdiff_t val;
	} tgt_offsets__ref;
	KernelArgsTy * KernelArgs;
	struct {
		KernelArgsTy val;
	} KernelArgs__ref;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_launch_kernel_t;

#define GET_ARGS_VALUE___tgt_rtl_launch_kernel(activity) { \
	args___tgt_rtl_launch_kernel_t* args = (args___tgt_rtl_launch_kernel_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->tgt_entry_ptr = (void *) tgt_entry_ptr; \
	args->tgt_args = (void **) tgt_args; \
	args->tgt_offsets = (ptrdiff_t *) tgt_offsets; \
	args->KernelArgs = (KernelArgsTy *) KernelArgs; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_launch_kernel(args) { \
	args___tgt_rtl_launch_kernel_t* pargs = (args___tgt_rtl_launch_kernel_t*) args; \
	if (pargs->tgt_args != NULL) { \
		pargs->tgt_args__ref.ptr1 = *pargs->tgt_args; \
	} \
	if (pargs->tgt_offsets != NULL) { \
		pargs->tgt_offsets__ref.val = *pargs->tgt_offsets; \
	} \
	if (pargs->KernelArgs != NULL) { \
		pargs->KernelArgs__ref.val = *pargs->KernelArgs; \
	} \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_is_valid_binary` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_is_valid_binary` function call.
 *
 * @struct args___tgt_rtl_is_valid_binary_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_is_valid_binary (
 *			__tgt_device_image * image (struct __tgt_device_image*)
 *	)
 */
#if HAVE___tgt_rtl_is_valid_binary
typedef struct {
	__tgt_device_image * image;
	struct {
		__tgt_device_image val;
	} image__ref;
	int32_t retval;
} args___tgt_rtl_is_valid_binary_t;

#define GET_ARGS_VALUE___tgt_rtl_is_valid_binary(activity) { \
	args___tgt_rtl_is_valid_binary_t* args = (args___tgt_rtl_is_valid_binary_t*) activity->args; \
	args->image = (__tgt_device_image *) image; \
};

#define GET_PTRS_VALUE___tgt_rtl_is_valid_binary(args) { \
	args___tgt_rtl_is_valid_binary_t* pargs = (args___tgt_rtl_is_valid_binary_t*) args; \
	if (pargs->image != NULL) { \
		pargs->image__ref.val = *pargs->image; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_retrieve` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_retrieve` function call.
 *
 * @struct args___tgt_rtl_data_retrieve_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_retrieve (
 *			int32_t device_id (int)
 *			void * host_ptr (void *)
 *			void * target_ptr (void *)
 *			int64_t size (long)
 *	)
 */
#if HAVE___tgt_rtl_data_retrieve
typedef struct {
	int32_t device_id;
	void * host_ptr;
	void * target_ptr;
	int64_t size;
	int32_t retval;
} args___tgt_rtl_data_retrieve_t;

#define GET_ARGS_VALUE___tgt_rtl_data_retrieve(activity) { \
	args___tgt_rtl_data_retrieve_t* args = (args___tgt_rtl_data_retrieve_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->host_ptr = (void *) host_ptr; \
	args->target_ptr = (void *) target_ptr; \
	args->size = (int64_t) size; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_lock` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_lock` function call.
 *
 * @struct args___tgt_rtl_data_lock_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_lock (
 *			int32_t device_id (int)
 *			void * host_ptr (void *)
 *			int64_t size (long)
 *			void ** LockedHostPtr (void **)
 *	)
 */
#if HAVE___tgt_rtl_data_lock
typedef struct {
	int32_t device_id;
	void * host_ptr;
	int64_t size;
	void ** LockedHostPtr;
	struct {
		void* ptr1;
	} LockedHostPtr__ref;
	int32_t retval;
} args___tgt_rtl_data_lock_t;

#define GET_ARGS_VALUE___tgt_rtl_data_lock(activity) { \
	args___tgt_rtl_data_lock_t* args = (args___tgt_rtl_data_lock_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->host_ptr = (void *) host_ptr; \
	args->size = (int64_t) size; \
	args->LockedHostPtr = (void **) LockedHostPtr; \
};

#define GET_PTRS_VALUE___tgt_rtl_data_lock(args) { \
	args___tgt_rtl_data_lock_t* pargs = (args___tgt_rtl_data_lock_t*) args; \
	if (pargs->LockedHostPtr != NULL) { \
		pargs->LockedHostPtr__ref.ptr1 = *pargs->LockedHostPtr; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_supports_empty_images` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_supports_empty_images` function call.
 *
 * @struct args___tgt_rtl_supports_empty_images_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_supports_empty_images (
 *	)
 */
#if HAVE___tgt_rtl_supports_empty_images
typedef struct {
	int32_t retval;
} args___tgt_rtl_supports_empty_images_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_destroy_event` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_destroy_event` function call.
 *
 * @struct args___tgt_rtl_destroy_event_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_destroy_event (
 *			int32_t device_id (int)
 *			void * event (void *)
 *	)
 */
#if HAVE___tgt_rtl_destroy_event
typedef struct {
	int32_t device_id;
	void * event;
	int32_t retval;
} args___tgt_rtl_destroy_event_t;

#define GET_ARGS_VALUE___tgt_rtl_destroy_event(activity) { \
	args___tgt_rtl_destroy_event_t* args = (args___tgt_rtl_destroy_event_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->event = (void *) event; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_number_of_devices` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_number_of_devices` function call.
 *
 * @struct args___tgt_rtl_number_of_devices_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_number_of_devices (
 *	)
 */
#if HAVE___tgt_rtl_number_of_devices
typedef struct {
	int32_t retval;
} args___tgt_rtl_number_of_devices_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_init_requires` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_init_requires` function call.
 *
 * @struct args___tgt_rtl_init_requires_t
 *
 * @note 
 *	int64_t
 *	__tgt_rtl_init_requires (
 *			int64_t RequiresFlags (long)
 *	)
 */
#if HAVE___tgt_rtl_init_requires
typedef struct {
	int64_t RequiresFlags;
	int64_t retval;
} args___tgt_rtl_init_requires_t;

#define GET_ARGS_VALUE___tgt_rtl_init_requires(activity) { \
	args___tgt_rtl_init_requires_t* args = (args___tgt_rtl_init_requires_t*) activity->args; \
	args->RequiresFlags = (int64_t) RequiresFlags; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_notify_unmapped` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_notify_unmapped` function call.
 *
 * @struct args___tgt_rtl_data_notify_unmapped_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_notify_unmapped (
 *			int32_t device_id (int)
 *			void * host_ptr (void *)
 *	)
 */
#if HAVE___tgt_rtl_data_notify_unmapped
typedef struct {
	int32_t device_id;
	void * host_ptr;
	int32_t retval;
} args___tgt_rtl_data_notify_unmapped_t;

#define GET_ARGS_VALUE___tgt_rtl_data_notify_unmapped(activity) { \
	args___tgt_rtl_data_notify_unmapped_t* args = (args___tgt_rtl_data_notify_unmapped_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->host_ptr = (void *) host_ptr; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_init_device_info` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_init_device_info` function call.
 *
 * @struct args___tgt_rtl_init_device_info_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_init_device_info (
 *			int32_t device_id (int)
 *			__tgt_device_info * device_info_ptr (struct __tgt_device_info*)
 *			const char ** err_str (const char **)
 *	)
 */
#if HAVE___tgt_rtl_init_device_info
typedef struct {
	int32_t device_id;
	__tgt_device_info * device_info_ptr;
	struct {
		__tgt_device_info val;
	} device_info_ptr__ref;
	char ** err_str;
	struct {
		void* ptr1;
		char val[OMP_TGT_RTL_STRING_SIZE_MAX];
	} err_str__ref;
	int32_t retval;
} args___tgt_rtl_init_device_info_t;

#define GET_ARGS_VALUE___tgt_rtl_init_device_info(activity) { \
	args___tgt_rtl_init_device_info_t* args = (args___tgt_rtl_init_device_info_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->device_info_ptr = (__tgt_device_info *) device_info_ptr; \
	args->err_str = (char **) err_str; \
};

#define GET_PTRS_VALUE___tgt_rtl_init_device_info(args) { \
	args___tgt_rtl_init_device_info_t* pargs = (args___tgt_rtl_init_device_info_t*) args; \
	if (pargs->device_info_ptr != NULL) { \
		pargs->device_info_ptr__ref.val = *pargs->device_info_ptr; \
	} \
	if (pargs->err_str != NULL) { \
		pargs->err_str__ref.ptr1 = *pargs->err_str; \
		if (pargs->err_str__ref.ptr1 != NULL) { \
			strncpy(pargs->err_str__ref.val, pargs->err_str__ref.ptr1, OMP_TGT_RTL_STRING_SIZE_MAX-1); \
		} \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_sync_event` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_sync_event` function call.
 *
 * @struct args___tgt_rtl_sync_event_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_sync_event (
 *			int32_t device_id (int)
 *			void * event (void *)
 *	)
 */
#if HAVE___tgt_rtl_sync_event
typedef struct {
	int32_t device_id;
	void * event;
	int32_t retval;
} args___tgt_rtl_sync_event_t;

#define GET_ARGS_VALUE___tgt_rtl_sync_event(activity) { \
	args___tgt_rtl_sync_event_t* args = (args___tgt_rtl_sync_event_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->event = (void *) event; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_synchronize` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_synchronize` function call.
 *
 * @struct args___tgt_rtl_synchronize_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_synchronize (
 *			int32_t device_id (int)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_synchronize
typedef struct {
	int32_t device_id;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_synchronize_t;

#define GET_ARGS_VALUE___tgt_rtl_synchronize(activity) { \
	args___tgt_rtl_synchronize_t* args = (args___tgt_rtl_synchronize_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_synchronize(args) { \
	args___tgt_rtl_synchronize_t* pargs = (args___tgt_rtl_synchronize_t*) args; \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_set_up_env` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_set_up_env` function call.
 *
 * @struct args___tgt_rtl_set_up_env_t
 *
 * @note 
 *	void
 *	__tgt_rtl_set_up_env (
 *	)
 */
#if HAVE___tgt_rtl_set_up_env
typedef struct {

} args___tgt_rtl_set_up_env_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_unlock` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_unlock` function call.
 *
 * @struct args___tgt_rtl_data_unlock_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_data_unlock (
 *			int device_id (int)
 *			void * host_ptr (void *)
 *	)
 */
#if HAVE___tgt_rtl_data_unlock
typedef struct {
	int device_id;
	void * host_ptr;
	int32_t retval;
} args___tgt_rtl_data_unlock_t;

#define GET_ARGS_VALUE___tgt_rtl_data_unlock(activity) { \
	args___tgt_rtl_data_unlock_t* args = (args___tgt_rtl_data_unlock_t*) activity->args; \
	args->device_id = (int) device_id; \
	args->host_ptr = (void *) host_ptr; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_is_fine_grained_memory_enabled` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_is_fine_grained_memory_enabled` function call.
 *
 * @struct args___tgt_rtl_is_fine_grained_memory_enabled_t
 *
 * @note 
 *	int
 *	__tgt_rtl_is_fine_grained_memory_enabled (
 *	)
 */
#if HAVE___tgt_rtl_is_fine_grained_memory_enabled
typedef struct {
	int retval;
} args___tgt_rtl_is_fine_grained_memory_enabled_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_has_USM_capable_dGPU` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_has_USM_capable_dGPU` function call.
 *
 * @struct args___tgt_rtl_has_USM_capable_dGPU_t
 *
 * @note 
 *	int
 *	__tgt_rtl_has_USM_capable_dGPU (
 *	)
 */
#if HAVE___tgt_rtl_has_USM_capable_dGPU
typedef struct {
	int retval;
} args___tgt_rtl_has_USM_capable_dGPU_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_has_apu_device` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_has_apu_device` function call.
 *
 * @struct args___tgt_rtl_has_apu_device_t
 *
 * @note 
 *	int
 *	__tgt_rtl_has_apu_device (
 *	)
 */
#if HAVE___tgt_rtl_has_apu_device
typedef struct {
	int retval;
} args___tgt_rtl_has_apu_device_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_set_device_offset` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_set_device_offset` function call.
 *
 * @struct args___tgt_rtl_set_device_offset_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_set_device_offset (
 *			int32_t DeviceIdOffset (int)
 *	)
 */
#if HAVE___tgt_rtl_set_device_offset
typedef struct {
	int32_t DeviceIdOffset;
	int32_t retval;
} args___tgt_rtl_set_device_offset_t;

#define GET_ARGS_VALUE___tgt_rtl_set_device_offset(activity) { \
	args___tgt_rtl_set_device_offset_t* args = (args___tgt_rtl_set_device_offset_t*) activity->args; \
	args->DeviceIdOffset = (int32_t) DeviceIdOffset; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_launch_kernel_sync` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_launch_kernel_sync` function call.
 *
 * @struct args___tgt_rtl_launch_kernel_sync_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_launch_kernel_sync (
 *			int32_t device_id (int)
 *			void * tgt_entry_ptr (void *)
 *			void ** tgt_args (void **)
 *			ptrdiff_t * tgt_offsets (long*)
 *			KernelArgsTy * KernelArgs (struct KernelArgsTy*)
 *	)
 */
#if HAVE___tgt_rtl_launch_kernel_sync
typedef struct {
	int32_t device_id;
	void * tgt_entry_ptr;
	void ** tgt_args;
	struct {
		void* ptr1;
	} tgt_args__ref;
	ptrdiff_t * tgt_offsets;
	struct {
		ptrdiff_t val;
	} tgt_offsets__ref;
	KernelArgsTy * KernelArgs;
	struct {
		KernelArgsTy val;
	} KernelArgs__ref;
	int32_t retval;
} args___tgt_rtl_launch_kernel_sync_t;

#define GET_ARGS_VALUE___tgt_rtl_launch_kernel_sync(activity) { \
	args___tgt_rtl_launch_kernel_sync_t* args = (args___tgt_rtl_launch_kernel_sync_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->tgt_entry_ptr = (void *) tgt_entry_ptr; \
	args->tgt_args = (void **) tgt_args; \
	args->tgt_offsets = (ptrdiff_t *) tgt_offsets; \
	args->KernelArgs = (KernelArgsTy *) KernelArgs; \
};

#define GET_PTRS_VALUE___tgt_rtl_launch_kernel_sync(args) { \
	args___tgt_rtl_launch_kernel_sync_t* pargs = (args___tgt_rtl_launch_kernel_sync_t*) args; \
	if (pargs->tgt_args != NULL) { \
		pargs->tgt_args__ref.ptr1 = *pargs->tgt_args; \
	} \
	if (pargs->tgt_offsets != NULL) { \
		pargs->tgt_offsets__ref.val = *pargs->tgt_offsets; \
	} \
	if (pargs->KernelArgs != NULL) { \
		pargs->KernelArgs__ref.val = *pargs->KernelArgs; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_record_event` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_record_event` function call.
 *
 * @struct args___tgt_rtl_record_event_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_record_event (
 *			int32_t device_id (int)
 *			void * event (void *)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_record_event
typedef struct {
	int32_t device_id;
	void * event;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_record_event_t;

#define GET_ARGS_VALUE___tgt_rtl_record_event(activity) { \
	args___tgt_rtl_record_event_t* args = (args___tgt_rtl_record_event_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->event = (void *) event; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_record_event(args) { \
	args___tgt_rtl_record_event_t* pargs = (args___tgt_rtl_record_event_t*) args; \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_set_info_flag` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_set_info_flag` function call.
 *
 * @struct args___tgt_rtl_set_info_flag_t
 *
 * @note 
 *	void
 *	__tgt_rtl_set_info_flag (
 *			uint32_t NewInfoLevel (unsigned int)
 *	)
 */
#if HAVE___tgt_rtl_set_info_flag
typedef struct {
	uint32_t NewInfoLevel;
} args___tgt_rtl_set_info_flag_t;

#define GET_ARGS_VALUE___tgt_rtl_set_info_flag(activity) { \
	args___tgt_rtl_set_info_flag_t* args = (args___tgt_rtl_set_info_flag_t*) activity->args; \
	args->NewInfoLevel = (uint32_t) NewInfoLevel; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_create_event` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_create_event` function call.
 *
 * @struct args___tgt_rtl_create_event_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_create_event (
 *			int32_t device_id (int)
 *			void ** event (void **)
 *	)
 */
#if HAVE___tgt_rtl_create_event
typedef struct {
	int32_t device_id;
	void ** event;
	struct {
		void* ptr1;
	} event__ref;
	int32_t retval;
} args___tgt_rtl_create_event_t;

#define GET_ARGS_VALUE___tgt_rtl_create_event(activity) { \
	args___tgt_rtl_create_event_t* args = (args___tgt_rtl_create_event_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->event = (void **) event; \
};

#define GET_PTRS_VALUE___tgt_rtl_create_event(args) { \
	args___tgt_rtl_create_event_t* pargs = (args___tgt_rtl_create_event_t*) args; \
	if (pargs->event != NULL) { \
		pargs->event__ref.ptr1 = *pargs->event; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_print_device_info` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_print_device_info` function call.
 *
 * @struct args___tgt_rtl_print_device_info_t
 *
 * @note 
 *	void
 *	__tgt_rtl_print_device_info (
 *			int32_t device_id (int)
 *	)
 */
#if HAVE___tgt_rtl_print_device_info
typedef struct {
	int32_t device_id;
} args___tgt_rtl_print_device_info_t;

#define GET_ARGS_VALUE___tgt_rtl_print_device_info(activity) { \
	args___tgt_rtl_print_device_info_t* args = (args___tgt_rtl_print_device_info_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_get_function` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_get_function` function call.
 *
 * @struct args___tgt_rtl_get_function_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_get_function (
 *			__tgt_device_binary binary (struct __tgt_device_binary)
 *			const char * name (const char *)
 *			void ** kernel_ptr (void **)
 *	)
 */
#if HAVE___tgt_rtl_get_function
typedef struct {
	__tgt_device_binary binary;
	char * name;
	struct {
		char val[OMP_TGT_RTL_STRING_SIZE_MAX];
	} name__ref;
	void ** kernel_ptr;
	struct {
		void* ptr1;
	} kernel_ptr__ref;
	int32_t retval;
} args___tgt_rtl_get_function_t;

#define GET_ARGS_VALUE___tgt_rtl_get_function(activity) { \
	args___tgt_rtl_get_function_t* args = (args___tgt_rtl_get_function_t*) activity->args; \
	args->binary = (__tgt_device_binary) binary; \
	args->name = (char *) name; \
	args->kernel_ptr = (void **) kernel_ptr; \
};

#define GET_PTRS_VALUE___tgt_rtl_get_function(args) { \
	args___tgt_rtl_get_function_t* pargs = (args___tgt_rtl_get_function_t*) args; \
	if (pargs->name != NULL) { \
		strncpy(pargs->name__ref.val, pargs->name, OMP_TGT_RTL_STRING_SIZE_MAX-1); \
	} \
	if (pargs->kernel_ptr != NULL) { \
		pargs->kernel_ptr__ref.ptr1 = *pargs->kernel_ptr; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_init_plugin` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_init_plugin` function call.
 *
 * @struct args___tgt_rtl_init_plugin_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_init_plugin (
 *	)
 */
#if HAVE___tgt_rtl_init_plugin
typedef struct {
	int32_t retval;
} args___tgt_rtl_init_plugin_t;

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_number_of_team_procs` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_number_of_team_procs` function call.
 *
 * @struct args___tgt_rtl_number_of_team_procs_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_number_of_team_procs (
 *			int device_id (int)
 *	)
 */
#if HAVE___tgt_rtl_number_of_team_procs
typedef struct {
	int device_id;
	int32_t retval;
} args___tgt_rtl_number_of_team_procs_t;

#define GET_ARGS_VALUE___tgt_rtl_number_of_team_procs(activity) { \
	args___tgt_rtl_number_of_team_procs_t* args = (args___tgt_rtl_number_of_team_procs_t*) activity->args; \
	args->device_id = (int) device_id; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_wait_event` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_wait_event` function call.
 *
 * @struct args___tgt_rtl_wait_event_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_wait_event (
 *			int32_t device_id (int)
 *			void * event (void *)
 *			__tgt_async_info * AsyncInfo (struct __tgt_async_info*)
 *	)
 */
#if HAVE___tgt_rtl_wait_event
typedef struct {
	int32_t device_id;
	void * event;
	__tgt_async_info * AsyncInfo;
	struct {
		__tgt_async_info val;
	} AsyncInfo__ref;
	int32_t retval;
} args___tgt_rtl_wait_event_t;

#define GET_ARGS_VALUE___tgt_rtl_wait_event(activity) { \
	args___tgt_rtl_wait_event_t* args = (args___tgt_rtl_wait_event_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->event = (void *) event; \
	args->AsyncInfo = (__tgt_async_info *) AsyncInfo; \
};

#define GET_PTRS_VALUE___tgt_rtl_wait_event(args) { \
	args___tgt_rtl_wait_event_t* pargs = (args___tgt_rtl_wait_event_t*) args; \
	if (pargs->AsyncInfo != NULL) { \
		pargs->AsyncInfo__ref.val = *pargs->AsyncInfo; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_data_alloc` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_data_alloc` function call.
 *
 * @struct args___tgt_rtl_data_alloc_t
 *
 * @note 
 *	void *
 *	__tgt_rtl_data_alloc (
 *			int32_t device_id (int)
 *			int64_t size (long)
 *			void * host_ptr (void *)
 *			int32_t kind (int)
 *	)
 */
#if HAVE___tgt_rtl_data_alloc
typedef struct {
	int32_t device_id;
	int64_t size;
	void * host_ptr;
	int32_t kind;
	void * retval;
} args___tgt_rtl_data_alloc_t;

#define GET_ARGS_VALUE___tgt_rtl_data_alloc(activity) { \
	args___tgt_rtl_data_alloc_t* args = (args___tgt_rtl_data_alloc_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
	args->size = (int64_t) size; \
	args->host_ptr = (void *) host_ptr; \
	args->kind = (int32_t) kind; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_init_device` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_init_device` function call.
 *
 * @struct args___tgt_rtl_init_device_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_init_device (
 *			int32_t device_id (int)
 *	)
 */
#if HAVE___tgt_rtl_init_device
typedef struct {
	int32_t device_id;
	int32_t retval;
} args___tgt_rtl_init_device_t;

#define GET_ARGS_VALUE___tgt_rtl_init_device(activity) { \
	args___tgt_rtl_init_device_t* args = (args___tgt_rtl_init_device_t*) activity->args; \
	args->device_id = (int32_t) device_id; \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_get_global` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_get_global` function call.
 *
 * @struct args___tgt_rtl_get_global_t
 *
 * @note 
 *	int32_t
 *	__tgt_rtl_get_global (
 *			__tgt_device_binary binary (struct __tgt_device_binary)
 *			uint64_t size (unsigned long)
 *			const char * name (const char *)
 *			void ** device_ptr (void **)
 *	)
 */
#if HAVE___tgt_rtl_get_global
typedef struct {
	__tgt_device_binary binary;
	uint64_t size;
	char * name;
	struct {
		char val[OMP_TGT_RTL_STRING_SIZE_MAX];
	} name__ref;
	void ** device_ptr;
	struct {
		void* ptr1;
	} device_ptr__ref;
	int32_t retval;
} args___tgt_rtl_get_global_t;

#define GET_ARGS_VALUE___tgt_rtl_get_global(activity) { \
	args___tgt_rtl_get_global_t* args = (args___tgt_rtl_get_global_t*) activity->args; \
	args->binary = (__tgt_device_binary) binary; \
	args->size = (uint64_t) size; \
	args->name = (char *) name; \
	args->device_ptr = (void **) device_ptr; \
};

#define GET_PTRS_VALUE___tgt_rtl_get_global(args) { \
	args___tgt_rtl_get_global_t* pargs = (args___tgt_rtl_get_global_t*) args; \
	if (pargs->name != NULL) { \
		strncpy(pargs->name__ref.val, pargs->name, OMP_TGT_RTL_STRING_SIZE_MAX-1); \
	} \
	if (pargs->device_ptr != NULL) { \
		pargs->device_ptr__ref.ptr1 = *pargs->device_ptr; \
	} \
};

#endif

/**
 * @brief Structure to hold the arguments for the `__tgt_rtl_requested_prepopulate_gpu_page_table` function.
 *
 * This structure encapsulates the parameters and return value used in the 
 * `__tgt_rtl_requested_prepopulate_gpu_page_table` function call.
 *
 * @struct args___tgt_rtl_requested_prepopulate_gpu_page_table_t
 *
 * @note 
 *	int
 *	__tgt_rtl_requested_prepopulate_gpu_page_table (
 *	)
 */
#if HAVE___tgt_rtl_requested_prepopulate_gpu_page_table
typedef struct {
	int retval;
} args___tgt_rtl_requested_prepopulate_gpu_page_table_t;

#endif



/**
 * @brief Retrieves pointer-based argument values for OMP_TGT_RTL API calls.
 *
 * This function extracts pointer-based arguments based on the given OMP_TGT_RTL API ID.
 *
 * @param[in] id The OMP_TGT_RTL API function identifier.
 * @param[in,out] args Pointer to the OMP_TGT_RTL API arguments structure.
 * @param[in] is_enter Boolean flag indicating whether this function is handling an "enter" or "exit" event.
 */
static inline void get_omp_tgt_rtl_pointed_args_for(omp_tgt_rtl_api_id_t id, void* args, bool is_enter) 
{
    if (!is_enter) {
        switch(id) {
			#if HAVE___tgt_rtl_query_async
			case OMP_TGT_RTL_API_ID___tgt_rtl_query_async : {
				GET_PTRS_VALUE___tgt_rtl_query_async(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_data_submit_async
			case OMP_TGT_RTL_API_ID___tgt_rtl_data_submit_async : {
				GET_PTRS_VALUE___tgt_rtl_data_submit_async(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_init_async_info
			case OMP_TGT_RTL_API_ID___tgt_rtl_init_async_info : {
				GET_PTRS_VALUE___tgt_rtl_init_async_info(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_data_retrieve_async
			case OMP_TGT_RTL_API_ID___tgt_rtl_data_retrieve_async : {
				GET_PTRS_VALUE___tgt_rtl_data_retrieve_async(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_data_exchange_async
			case OMP_TGT_RTL_API_ID___tgt_rtl_data_exchange_async : {
				GET_PTRS_VALUE___tgt_rtl_data_exchange_async(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_launch_kernel
			case OMP_TGT_RTL_API_ID___tgt_rtl_launch_kernel : {
				GET_PTRS_VALUE___tgt_rtl_launch_kernel(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_is_valid_binary
			case OMP_TGT_RTL_API_ID___tgt_rtl_is_valid_binary : {
				GET_PTRS_VALUE___tgt_rtl_is_valid_binary(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_data_lock
			case OMP_TGT_RTL_API_ID___tgt_rtl_data_lock : {
				GET_PTRS_VALUE___tgt_rtl_data_lock(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_init_device_info
			case OMP_TGT_RTL_API_ID___tgt_rtl_init_device_info : {
				GET_PTRS_VALUE___tgt_rtl_init_device_info(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_synchronize
			case OMP_TGT_RTL_API_ID___tgt_rtl_synchronize : {
				GET_PTRS_VALUE___tgt_rtl_synchronize(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_launch_kernel_sync
			case OMP_TGT_RTL_API_ID___tgt_rtl_launch_kernel_sync : {
				GET_PTRS_VALUE___tgt_rtl_launch_kernel_sync(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_record_event
			case OMP_TGT_RTL_API_ID___tgt_rtl_record_event : {
				GET_PTRS_VALUE___tgt_rtl_record_event(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_create_event
			case OMP_TGT_RTL_API_ID___tgt_rtl_create_event : {
				GET_PTRS_VALUE___tgt_rtl_create_event(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_get_function
			case OMP_TGT_RTL_API_ID___tgt_rtl_get_function : {
				GET_PTRS_VALUE___tgt_rtl_get_function(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_wait_event
			case OMP_TGT_RTL_API_ID___tgt_rtl_wait_event : {
				GET_PTRS_VALUE___tgt_rtl_wait_event(args);
				return;
			}
			#endif
			#if HAVE___tgt_rtl_get_global
			case OMP_TGT_RTL_API_ID___tgt_rtl_get_global : {
				GET_PTRS_VALUE___tgt_rtl_get_global(args);
				return;
			}
			#endif
            default : break;
        }
    } else {
        switch(id) {

            default : break;
        }
    }
}
#endif // OMP_TGT_RTL_API_HELPER_H