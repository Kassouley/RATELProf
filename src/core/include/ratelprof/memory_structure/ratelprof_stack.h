/**
 * @file ratelprof_stack.h 
 * @brief Generic stack implementation for storing `uint64_t` elements.
 *
 * This header defines a stack data structure (`ratelprof_stack_t`) and provides a set 
 * of functions for stack operations such as initialization, push, pop, peek, 
 * and freeing the stack.
 *
 * Features:
 * - Supports dynamic resizing when the stack reaches capacity.
 * - Provides utility functions to check if the stack is full or empty.
 * - Allows safe retrieval of the top element without modifying the stack.
 * - Ensures proper memory management through initialization and cleanup functions.
 * 
 * @note THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 * 
 */

#ifndef RATELPROF_STACK_H 
#define RATELPROF_STACK_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include "ratelprof/ratelprof_status.h"

/**
 * @brief A structure representing a stack for storing `uint64_t` elements.
 *
 * This structure is used to manage a stack, which includes the array of elements, 
 * the current top index, and the maximum capacity of the stack. The stack grows 
 * dynamically as elements are pushed onto it and shrinks as elements are popped off.
 *
 * @struct ratelprof_stack_S
 * @typedef ratelprof_stack_t
 */
typedef struct ratelprof_stack_S {
    uint64_t* items;    /**< Pointer to the dynamically allocated array for storing stack elements. */
    int top;            /**< Index of the top element in the stack. */
    size_t capacity;    /**< Maximum size (capacity) of the stack. */
} ratelprof_stack_t;

/**
 * @brief Checks if a stack is full.
 *
 * This function determines whether the stack has reached its maximum capacity
 * by comparing the `top` index of the `ratelprof_stack_t` structure with 
 * `capacity - 1`. A stack is considered full when no additional items can 
 * be pushed onto it.
 *
 * @param[in] s Pointer to the `ratelprof_stack_t` structure to check.
 *
 * @return `true` if the stack is full, `false` otherwise.
 *
 * @note The stack must be properly initialized before calling this function.
 *       Undefined behavior may occur if the stack is not initialized.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * ratelprof_stack_init(&stack, 10);
 *
 * if (ratelprof_stack_is_full(&stack)) {
 *     printf("Stack is full.\n");
 * }
 * ```
 */
bool ratelprof_stack_is_full(ratelprof_stack_t* s);


/**
 * @brief Checks if a stack is empty.
 *
 * This function checks whether the stack is empty by comparing the `top` index 
 * of the `ratelprof_stack_t` structure to `-1`. A stack is considered empty if 
 * no items have been pushed onto it.
 *
 * @param[in] s Pointer to the `ratelprof_stack_t` structure to check.
 *
 * @return `true` if the stack is empty, `false` otherwise.
 *
 * @note The stack must be properly initialized before calling this function.
 *       Undefined behavior may occur if the stack is not initialized.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * ratelprof_stack_init(&stack, 10);
 *
 * if (ratelprof_stack_is_empty(&stack)) {
 *     printf("Stack is empty.\n");
 * }
 * ```
 */
bool ratelprof_stack_is_empty(ratelprof_stack_t* s);


/**
 * @brief Initializes a stack structure.
 *
 * This function initializes a `ratelprof_stack_t` structure by allocating memory 
 * for its items and setting the initial stack properties such as capacity and top index.
 * The stack is used to store `uint64_t` values, and the first item is initialized to 0.
 *
 * @param[out] s Pointer to the `ratelprof_stack_t` structure to initialize.
 * @param[in] capacity The maximum number of items the stack can hold.
 *
 * @return RATELPROF_STATUS_SUCCESS The stack was successfully initialized.
 * @return RATELPROF_STATUS_MALLOC_FAILED Memory allocation for the stack items failed.
 * @return RATELPROF_STATUS_ALLOC_SIZE_0 The `capacity` given in argument is 0.
 *
 * @note The caller is responsible for ensuring the stack is properly freed when it is no longer needed.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * size_t capacity = 100;
 * ratelprof_status_t status = ratelprof_stack_init(&stack, capacity);
 * if (status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle initialization error
 * }
 * 
 * // Use the stack...
 * ```
 */
ratelprof_status_t ratelprof_stack_init(ratelprof_stack_t* s, size_t capacity);


/**
 * @brief Pushes an element onto a stack.
 *
 * This function adds an element to the top of the stack. If the stack is full, it 
 * automatically resizes the stack to double its current capacity before adding 
 * the element.
 *
 * @param[in,out] s Pointer to the `ratelprof_stack_t` structure where the element will be pushed.
 * @param[in] e The element of type `uint64_t` to be pushed onto the stack.
 *
 * @return RATELPROF_STATUS_SUCCESS The element was successfully pushed onto the stack.
 * @return RATELPROF_STATUS_STACK_IS_NULL The stack pointer is NULL.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * ratelprof_stack_init(&stack, 10);
 *
 * // Push elements onto the stack
 * for (uint64_t i = 0; i < 20; i++) {
 *     ratelprof_stack_push(&stack, i);
 * }
 *
 * free(stack.items); // Free the allocated memory when done
 * ```
 */
ratelprof_status_t ratelprof_stack_push(ratelprof_stack_t* s, uint64_t el);


/**
 * @brief Pops the top element from a stack.
 *
 * This function removes and retrieves the top element of the stack. If the stack is empty, 
 * the function returns an error status.
 *
 * @param[in,out] s Pointer to the `ratelprof_stack_t` structure from which the element will be popped.
 * @param[out] poped_el Pointer to an integer where the popped element will be stored.
 *
 * @return RATELPROF_STATUS_SUCCESS The element was successfully popped from the stack.
 * @return RATELPROF_STATUS_STACK_IS_EMPTY The stack is empty, and no element could be popped.
 * @return RATELPROF_STATUS_STACK_IS_NULL The stack pointer is NULL.
 *
 * @warning If the `poped_el` pointer is NULL, the function may cause undefined behavior.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * ratelprof_stack_init(&stack, 10);
 *
 * ratelprof_stack_push(&stack, 42);
 *
 * int popped_element;
 * ratelprof_status_t status = ratelprof_stack_pop(&stack, &popped_element);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Popped element: %d\n", popped_element);
 * } else {
 *     printf("Failed to pop element: Stack is empty.\n");
 * }
 * ```
 */
ratelprof_status_t ratelprof_stack_pop(ratelprof_stack_t* s, uint64_t* poped_el);


/**
 * @brief Retrieves the top element of a stack without removing it.
 *
 * This function allows the user to access the top element of the stack without 
 * modifying the stack's state. If the stack is empty, the function returns an error status.
 *
 * @param[in] s Pointer to the `ratelprof_stack_t` structure to peek into.
 * @param[out] peeked_el Pointer to an integer where the top element will be stored.
 *
 * @return RATELPROF_STATUS_SUCCESS The top element was successfully retrieved.
 * @return RATELPROF_STATUS_STACK_IS_EMPTY The stack is empty, and no element could be retrieved.
 * @return RATELPROF_STATUS_STACK_IS_NULL The stack pointer is NULL.
 *
 * @warning If the `peeked_el` pointer is NULL, the function may cause undefined behavior.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * ratelprof_stack_init(&stack, 10);
 *
 * ratelprof_stack_push(&stack, 42);
 *
 * int peeked_element;
 * ratelprof_status_t status = ratelprof_stack_peek(&stack, &peeked_element);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Peeked element: %d\n", peeked_element);
 * } else {
 *     printf("Failed to peek: Stack is empty.\n");
 * }
 * ```
 */
ratelprof_status_t ratelprof_stack_peek(ratelprof_stack_t* s, uint64_t* peeked_el);


/**
 * @brief Frees the resources associated with a stack.
 *
 * This function deallocates the memory used by the stack's `items` and resets 
 * the stack's fields to indicate that it is no longer in use. After calling this 
 * function, the stack must be reinitialized before further use.
 *
 * @param[in,out] s Pointer to the `ratelprof_stack_t` structure to be freed.
 *
 * @return RATELPROF_STATUS_SUCCESS The stack was successfully freed.
 * @return RATELPROF_STATUS_STACK_IS_NULL The stack pointer is NULL.
 *
 * @note After freeing the stack, its `items` pointer is set to `NULL`, and its 
 *       `top` and `capacity` fields are reset to `-1` and `0`, respectively.
 *
 * @example
 * ```c
 * ratelprof_stack_t stack;
 * ratelprof_stack_init(&stack, 10);
 *
 * // Perform operations on the stack...
 *
 * ratelprof_status_t status = ratelprof_stack_free(&stack);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Stack successfully freed.\n");
 * }
 * ```
 */
ratelprof_status_t ratelprof_stack_free(ratelprof_stack_t* s);

#endif // RATELPROF_STACK_H
