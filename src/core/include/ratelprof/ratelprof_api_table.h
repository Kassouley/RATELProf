/**
 * @file ratelprof_api_table.h
 * @brief API Table Management Interface
 *
 * This header file defines the structures and function declarations for managing 
 * API tables. The API table is used to store and control function pointers dynamically, 
 * allowing interception, redirection, and fallback mechanisms for API functions.
 *
 * The API table consists of:
 * - A domain identifier (`domain`).
 * - A shared library handle (`handler`).
 * - Arrays for original and active function pointers (`api_fn` and `api_ptr`).
 * - A table size (`size`).
 * - A flag indicating whether the table has been populated (`is_populate`).
 *
 * The provided functions enable initialization, population, enabling, disabling, 
 * and cleanup of the API table.
 *
 * @note THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 *
 */

#ifndef RATELPROF_API_TABLE_H
#define RATELPROF_API_TABLE_H

#include <stddef.h>
#include <stdbool.h>
#include "ratelprof.h"

/**
 * @brief Represents the API table structure.
 *
 * The `ratelprof_api_table_t` structure is used to manage and store function pointers for 
 * APIs in a specific domain. It includes metadata about the domain, the handler 
 * for the shared library, arrays for function pointers, and the table size.
 *
 * @struct ratelprof_api_table_s
 * @typedef ratelprof_api_table_t
 *
 * @var ratelprof_api_table_t::domain
 * The domain to which the API table belongs. It is used to identify and manage 
 * the set of functions within the table.
 *
 * @var ratelprof_api_table_t::handler
 * A handle to the shared library containing the functions in the API table. This is 
 * typically initialized by `dlopen` and closed by `dlclose`.
 *
 * @var ratelprof_api_table_t::api_fn
 * An array of function pointers representing the original implementation of the API functions.
 * It is populated during initialization or population of the API table.
 *
 * @var ratelprof_api_table_t::api_ptr
 * An array of function pointers representing the currently active API functions. These may 
 * point to custom implementations, fallbacks, or the original functions in `api_fn`.
 *
 * @var ratelprof_api_table_t::size
 * The number of entries in the API table. This determines the size of the `api_fn` 
 * and `api_ptr` arrays.
 *
 * @var ratelprof_api_table_t::is_populate
 * A boolean flag indicating whether the API table has been populated with function pointers.
 *
 * @note The API table must be initialized using `ratelprof_init_api_table` before use.
 *       The memory allocated for `api_fn` and `api_ptr` should be freed during cleanup
 *       with `ratelprof_cleanup_api_table`.
 */
typedef struct ratelprof_api_table_s {
    ratelprof_domain_t domain;      /**< The domain of the API table. */
    void* handler;                              /**< Handle to the shared library. */
    void** api_fn;                              /**< Array of original API function pointers. */
    void** api_ptr;                             /**< Array of active API function pointers. */
    size_t size;                                /**< Number of functions in the API table. */
    bool is_populate;                           /**< Indicates if the table has been populated. */
} ratelprof_api_table_t;


/**
 * @brief Initializes the API table for a specific domain.
 *
 * This function sets up an API table with the specified size for the given domain.
 * It allocates memory for API pointers and function pointers and initializes
 * the table's properties. If the initialization is successful, the function 
 * returns `RATELPROF_STATUS_SUCCESS`. If any memory allocation fails, or if 
 * the provided pointer is invalid, the appropriate error code is returned.
 *
 * @param[in] domain The domain to which the API table belongs.
 * @param[out] api_table Pointer to the `ratelprof_api_table_t` structure to be initialized.
 * @param[in] size The number of entries in the API table.
 *
 * @return RATELPROF_STATUS_SUCCESS Initialization succeeded.
 * @return RATELPROF_STATUS_INVALID_PTR The `api_table` pointer is NULL.
 * @return RATELPROF_STATUS_ALLOC_SIZE_0 The `size` given in argument is 0.
 * @return RATELPROF_STATUS_MALLOC_FAILED Memory allocation for the API table failed.
 *
 * @note The caller is responsible for freeing the `api_table` with `ratelprof_cleanup_api_table` when it is no longer needed.
 *
 * @example
 * ```c
 * ratelprof_domain_t domain = SOME_DOMAIN;
 * ratelprof_api_table_t api_table;
 * size_t size = 10;
 * 
 * ratelprof_status_t status = ratelprof_init_api_table(domain, &api_table, size);
 * if (status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle error
 * }
 * ```
 */
ratelprof_status_t ratelprof_init_api_table(ratelprof_domain_t domain, ratelprof_api_table_t* api_table, size_t size);


/**
 * @brief Populates the API table with function pointers from a shared library.
 *
 * This function populates an existing API table by dynamically loading functions
 * from a shared library specified by the `lib_path`. If no `lib_path` is provided,
 * the function attempts to resolve symbols using the `RTLD_NEXT` handler. Each function 
 * in the table is resolved using its domain and ID, and fallback behavior is applied 
 * if a symbol cannot be resolved.
 *
 * @param[out] api_table Pointer to the `ratelprof_api_table_t` structure to be populated.
 * @param[in] lib_path Path to the shared library containing the API symbols.
 *                     If `NULL`, the `RTLD_NEXT` handler is used.
 *
 * @return RATELPROF_STATUS_SUCCESS The API table was successfully populated.
 * @return RATELPROF_STATUS_DLOPEN_FAILED Failed to open the shared library specified by `lib_path`.
 *
 * @note This function requires that the `api_table` is initialized using 
 *       `ratelprof_init_api_table()` before calling.
 *
 * @note If a function cannot be loaded from the shared library, a fallback function 
 *       is assigned to the respective entry in the table.
 *
 * @warning The caller must ensure that the API Table `domain` is valid.
 *
 * @example
 * ```c
 * ratelprof_api_table_t api_table;
 * ratelprof_status_t init_status = ratelprof_init_api_table(SOME_DOMAIN, &api_table, 10);
 * if (init_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle initialization error
 * }
 *
 * ratelprof_status_t populate_status = ratelprof_populate_api_table(&api_table, "libexample.so");
 * if (populate_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle population error
 * }
 * ```
 */
ratelprof_status_t ratelprof_populate_api_table(ratelprof_api_table_t* api_table, const char* lib_path);


/**
 * @brief Cleans up resources allocated for an API table.
 *
 * This function releases the memory and resources associated with an `ratelprof_api_table_t` 
 * structure, including closing the shared library handler (if applicable) and 
 * freeing dynamically allocated memory for API pointers and function pointers.
 *
 * @param[in,out] api_table Pointer to the `ratelprof_api_table_t` structure to be cleaned up.
 *
 * @return RATELPROF_STATUS_SUCCESS Cleanup was successful.
 * @return RATELPROF_STATUS_INVALID_PTR The `api_table` pointer is NULL.
 *
 * @note If the `handler` in the `api_table` was opened with `dlopen`, it is closed 
 *       using `dlclose`. If `RTLD_NEXT` was used as the handler, no action is taken.
 *
 * @warning After this function is called, the `api_table` structure should not be 
 *          used unless it is reinitialized.
 *
 * @example
 * ```c
 * ratelprof_api_table_t api_table;
 * ratelprof_status_t init_status = ratelprof_init_api_table(SOME_DOMAIN, &api_table, 10);
 * if (init_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle initialization error
 * }
 *
 * // Perform operations with the API table...
 *
 * ratelprof_status_t cleanup_status = ratelprof_cleanup_api_table(&api_table);
 * if (cleanup_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle cleanup error
 * }
 * ```
 */
ratelprof_status_t ratelprof_cleanup_api_table(ratelprof_api_table_t* api_table);


/**
 * @brief Enables the API table by setting up function pointers based on a filter or enabling all functions.
 *
 * This function enables function pointers in the API table based on the provided
 * filter. If a filter is specified, only the filtered
 * functions (by name) are enabled. Otherwise, all functions in the table are enabled.
 * Function pointers are resolved using the domain and function IDs.
 *
 * @param api_table Pointer to the `ratelprof_api_table_t` structure to be enabled.
 * @param filter_var_name The environment variable name that contains the list of 
 *                         function names to be used as a filter.
 * @param filter_type_name The environment variable name that specifies the type 
 *                          of filter.
 *
 * @return RATELPROF_STATUS_SUCCESS The API table was successfully enabled.
 * @return RATELPROF_STATUS_INVALID_PTR The `api_table` pointer is NULL.
 * @return RATELPROF_STATUS_API_TABLE_NOT_INIT The `api_table` has not been properly initialized.
 *
 * @note The environment variable `filter_var_name` should contain function names separated by commas (e.g., `"func1,func2,func3"`).
 * @note The function relies on helper functions like `get_filter_type`, `get_function_filter`, `get_funid_by_name`, 
 *       and `get_funaddr_by_id` to retrieve the necessary information for enabling functions.
 *
 * @example
 * ```c
 * ratelprof_api_table_t api_table;
 * ratelprof_status_t init_status = ratelprof_init_api_table(SOME_DOMAIN, &api_table, 10);
 * if (init_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle initialization error
 * }
 *
 * ratelprof_status_t populate_status = ratelprof_populate_api_table(&api_table, "libexample.so");
 * if (populate_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle population error
 * }
 *
 * // Enable specific functions based on the filter
 * ratelprof_status_t enable_status = ratelprof_enable_api_table(&api_table, "ENABLE_FUNCS", "FILTER_TYPE");
 * if (enable_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle enabling error
 * }
 * ```
 */
ratelprof_status_t ratelprof_enable_api_table(ratelprof_api_table_t* api_table, const char* filter_var_name, const char* filter_type_name);


/**
 * @brief Disables the API table by resetting function pointers to their original address.
 *
 * This function disables any custom behavior applied to the API table by restoring 
 * the `api_ptr` entries to their original values from the `api_fn` array. This ensures 
 * that the API table points to the default function implementations.
 *
 * @param[in,out] api_table Pointer to the `ratelprof_api_table_t` structure to be disabled.
 *
 * @return RATELPROF_STATUS_SUCCESS The API table was successfully disabled.
 * @return RATELPROF_STATUS_INVALID_PTR The `api_table` pointer is NULL.
 * @return RATELPROF_STATUS_API_TABLE_NOT_INIT The `api_table` has not been properly initialized.
 *
 * @note The function requires that the `api_table` is properly initialized and populated before use.
 *
 * @example
 * ```c
 * ratelprof_api_table_t api_table;
 * ratelprof_status_t init_status = ratelprof_init_api_table(SOME_DOMAIN, &api_table, 10);
 * if (init_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle initialization error
 * }
 *
 * ratelprof_status_t populate_status = ratelprof_populate_api_table(&api_table, "libexample.so");
 * if (populate_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle population error
 * }
 *
 * // Enable functions for specific use
 * ratelprof_enable_api_table(&api_table, "ENABLE_FUNCS");
 *
 * // Disable the API table, restoring original function pointers
 * ratelprof_status_t disable_status = ratelprof_disable_api_table(&api_table);
 * if (disable_status != RATELPROF_STATUS_SUCCESS) {
 *     // Handle disabling error
 * }
 * ```
 */
ratelprof_status_t ratelprof_disable_api_table(ratelprof_api_table_t* api_table);


/**
 * @brief Default fallback function invoked when a critical API function fails to load.
 *
 * This function is called as a last resort when a required function cannot be loaded 
 * from the shared library. It logs an error message to `stderr` and terminates the 
 * program with a failure status.
 *
 * @note The purpose of this function is to prevent further execution when a critical 
 *       API function is unavailable, ensuring the issue is noticed immediately.
 *
 * @warning This function terminates the program using `exit(EXIT_FAILURE)`.
 */
void fallback(void);

#endif // RATELPROF_API_TABLE_H
