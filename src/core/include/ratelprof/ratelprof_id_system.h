/**
 * @file ratelprof_id_system.h
 * @brief Thread-local Stack and Unique ID Management
 *
 * This header file defines an interface for managing thread-local stacks 
 * and generating globally unique identifiers (IDs). It provides functions 
 * for initializing, retrieving, and manipulating a stack that is specific 
 * to each thread using thread-local storage (TLS). The stack is used to 
 * store IDs.
 *
 * Features:
 * - A thread-local stack is created for each thread and automatically 
 *   cleaned up upon thread termination.
 * - Unique IDs are generated, pushed onto the stack, and retrieved as 
 *   needed to facilitate correlation tracking.
 * - The API provides mechanisms to create, retrieve, get, pop, and 
 *   obtain correlation IDs from the stack.
 *
 * @note THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 * 
 */

#ifndef RATELPROF_ID_SYSTEM_H
#define RATELPROF_ID_SYSTEM_H

#include <stdint.h>
#include "ratelprof/ratelprof_status.h"
#include "ratelprof/memory_structure/ratelprof_stack.h"


/**
 * @brief Cleans up and frees the memory used by the thread-local stack.
 *
 * This function is called when a thread exits. It deallocates the memory used by 
 * the stack's elements and the stack structure itself. It is intended to be used 
 * as a destructor for thread-local storage (TLS) to ensure that the stack is cleaned up 
 * properly when the thread terminates.
 *
 * @param[in] s Pointer to the thread-local stack to be cleaned up.
 *
 * @note This function is registered as a destructor for the thread-local storage (TLS) key 
 *       created in `init_id_system`. It will be called automatically when the thread exits.
 *
 * @warning This function should only be used with a valid thread-local stack pointer. 
 *          Passing a NULL pointer is safe, as the function checks for it before attempting cleanup.
 *
 * @note This function is automatically called when the thread exits and its TLS is destroyed.
 */
void cleanup_stack(void* s);


/**
 * @brief Retrieves the thread-local stack for the current thread.
 *
 * This function checks if a stack is already associated with the current thread using 
 * thread-local storage (TLS). If no stack is found, it creates and initializes a new 
 * stack for the thread.
 *
 * @param[out] s Pointer to a pointer where the address of the thread's `ratelprof_stack_t` 
 *               structure will be stored.
 *
 * @return RATELPROF_STATUS_SUCCESS The stack was successfully retrieved or created.
 * @return RATELPROF_STATUS_MALLOC_FAILED Memory allocation for the stack failed (if created).
 * @return RATELPROF_STATUS_ALLOC_SIZE_0 Allocation size is 0 for the stack (if created).
 *
 * @note This function ensures that each thread has its own stack by checking for an existing 
 *       stack and creating one if necessary. The stack is associated with the current thread 
 *       using TLS.
 *
 * @example
 * ```c
 * ratelprof_stack_t* thread_stack;
 * ratelprof_status_t status = get_thread_stack(&thread_stack);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Thread stack retrieved or created.\n");
 * } else {
 *     printf("Failed to retrieve or create thread stack.\n");
 * }
 * ```
 */
ratelprof_status_t get_thread_stack(ratelprof_stack_t** s);


/**
 * @brief Creates and initializes a thread-local stack for the current thread.
 *
 * This function allocates memory for a `ratelprof_stack_t` structure and initializes 
 * it with a capacity of 2048. It then associates this stack with the current thread 
 * using thread-local storage (TLS) via `pthread_setspecific`.
 *
 * @param[out] s Pointer to a pointer where the address of the initialized `ratelprof_stack_t` structure will be stored.
 *
 * @return RATELPROF_STATUS_SUCCESS The thread stack was successfully created and initialized.
 * @return RATELPROF_STATUS_MALLOC_FAILED Memory allocation for the stack failed.
 * @return RATELPROF_STATUS_ALLOC_SIZE_0 Allocation size is 0.
 *
 * @note The stack is associated with the current thread using TLS. The memory for 
 *       the stack is automatically freed when the thread exits (via the destructor).
 *
 * @example
 * ```c
 * ratelprof_stack_t* thread_stack;
 * ratelprof_status_t status = create_thread_stack(&thread_stack);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Thread stack created and initialized.\n");
 * } else {
 *     printf("Failed to create thread stack.\n");
 * }
 * ```
 */
ratelprof_status_t create_thread_stack(ratelprof_stack_t** s);


/**
 * @brief Get a globally unique ID from the thread-local stack and pushes a new one.
 *
 * This function generates a globally unique ID by incrementing a shared counter (`global_id_counter`), 
 * assigns the generated ID to the provided pointer, and then pushes it onto the thread-local stack.
 * The function ensures thread-safety by locking the mutex (`id_mutex`) during the increment of the counter.
 *
 * @param[out] id Pointer to a `uint64_t` variable where the generated ID will be stored.
 *
 * @return RATELPROF_STATUS_SUCCESS The ID was successfully generated and pushed onto the stack.
 * @return RATELPROF_STATUS_MALLOC_FAILED Memory allocation failed for the stack (if stack initialization was required).
 * @return RATELPROF_STATUS_STACK_NOT_INIT The stack is not init or null.
 *
 * @note The function uses thread-local storage (TLS) to access the stack associated with the current thread.
 *       It is guaranteed to retrieve or create the stack using `get_thread_stack` before performing operations.
 * 
 * @example
 * ```c
 * uint64_t id;
 * ratelprof_status_t status = get_id(&id);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Generated ID: %llu\n", id);
 * } else {
 *     printf("Failed to generate ID.\n");
 * }
 * ```
 */
ratelprof_status_t get_id(uint64_t *id);


/**
 * @brief Pops a globally unique ID from the thread-local stack.
 *
 * This function pops the top ID from the thread-local stack. It ensures that the 
 * stack is initialized for the current thread by calling `get_thread_stack`. If the stack is 
 * empty, an error status will be returned.
 *
 * @return RATELPROF_STATUS_SUCCESS The ID was successfully popped from the stack.
 * @return RATELPROF_STATUS_STACK_NOT_INIT The stack is not init or null.
 * @return RATELPROF_STATUS_STACK_IS_EMPTY The stack is empty, and no ID could be popped.
 *
 * @note The function relies on thread-local storage (TLS) to manage the stack. It ensures that each 
 *       thread operates on its own stack, without interference from other threads.
 * 
 * @example
 * ```c
 * ratelprof_status_t status = pop_id();
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Successfully popped an ID.\n");
 * } else {
 *     printf("Failed to pop ID.\n");
 * }
 * ```
 */
ratelprof_status_t pop_id(void);


/**
 * @brief Retrieves the correlation ID from the top of the thread-local stack.
 *
 * This function peeks at the top element of the thread-local stack to retrieve the correlation ID 
 * associated with the current thread, without modifying the stack.
 *
 * @param[out] corr_id Pointer to a `uint64_t` variable where the correlation ID will be stored.
 *
 * @return RATELPROF_STATUS_SUCCESS The correlation ID was successfully retrieved.
 * @return RATELPROF_STATUS_STACK_NOT_INIT The stack is not init or null.
 * @return RATELPROF_STATUS_STACK_IS_EMPTY The stack is empty.
 *
 * @note The function relies on thread-local storage (TLS) to manage the stack. It ensures that each 
 *       thread operates on its own stack, without interference from other threads.
 * 
 * @example
 * ```c
 * uint64_t corr_id;
 * ratelprof_status_t status = get_correlation_id(&corr_id);
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Retrieved correlation ID: %lld\n", corr_id);
 * } else {
 *     printf("Failed to retrieve correlation ID.\n");
 * }
 * ```
 */
ratelprof_status_t get_correlation_id(uint64_t *corr_id);


/**
 * @brief Initializes the thread-local storage (TLS) for the stack system.
 *
 * This function creates a thread-local storage key (`thread_stack_key`) with a destructor 
 * that will clean up the stack when the thread exits. It then initializes the thread stack 
 * by calling `create_thread_stack`.
 *
 * @return RATELPROF_STATUS_SUCCESS The thread-local storage and stack were successfully initialized.
 * @return RATELPROF_STATUS_MALLOC_FAILED Memory allocation for the stack failed.
 * @return RATELPROF_STATUS_ALLOC_SIZE_0 Allocation size is 0 for the stack initialization.
 * 
 * @note The TLS key created in this function is used to associate a stack with each thread. 
 *       The stack will be cleaned up automatically when the thread exits using the `ratelprof_stack_free` function.
 * 
 * @example
 * ```c
 * ratelprof_status_t status = init_id_system();
 * if (status == RATELPROF_STATUS_SUCCESS) {
 *     printf("Thread-local storage and stack system initialized.\n");
 * } else {
 *     printf("Failed to initialize thread-local storage and stack system.\n");
 * }
 * ```
 */
ratelprof_status_t init_id_system(void);

/**
 * @brief Cleans up and deletes the thread-local storage (TLS) key for the stack system.
 *
 * This function is called to delete the TLS key used for storing the thread-local stack when it 
 * is no longer needed (e.g., when the program exits). It ensures that any resources associated 
 * with the TLS key are properly cleaned up.
 *
 * @return None
 *
 * @note This function should be called when the thread-local storage key is no longer required, 
 *       typically during program shutdown or when the TLS data is no longer in use.
 * 
 * @warning Calling this function after the thread-local storage key has already been deleted 
 *          may result in undefined behavior.
 *
 * @example
 * ```c
 * cleanup_id_system();  // Clean up the TLS key when the program ends
 * ```
 */
void cleanup_id_system();

#endif // RATELPROF_ID_SYSTEM_H
