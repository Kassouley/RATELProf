/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include "ratelprof/memory_structure/ratelprof_stack.h"
#include "ratelprof/ratelprof_status.h"

// Check if the stack is full
bool ratelprof_stack_is_full(ratelprof_stack_t* s) {
    return s->top == s->capacity - 1;
}

// Check if the stack is empty
bool ratelprof_stack_is_empty(ratelprof_stack_t* s) {
    return s->top == -1;
}

// Function to initialize the stack with an initial capacity
ratelprof_status_t ratelprof_stack_init(ratelprof_stack_t* s, size_t capacity) {
    if (capacity == 0) return RATELPROF_STATUS_ALLOC_SIZE_0;
    s->capacity = capacity;
    s->top = 0;
    s->items = (uint64_t*)malloc(s->capacity * sizeof(uint64_t));  // Allocate memory for stack
    if (s->items == NULL) return RATELPROF_STATUS_MALLOC_FAILED;
    s->items[s->top] = 0;
    return RATELPROF_STATUS_SUCCESS;
}

// Push operation to add an element to the stack
ratelprof_status_t ratelprof_stack_push(ratelprof_stack_t* s, uint64_t el) {
    if (!s) return RATELPROF_STATUS_STACK_IS_NULL;
    if (ratelprof_stack_is_full(s)) {
        s->capacity *= 2;  // Double the capacity
        s->items = (uint64_t*)realloc(s->items, s->capacity * sizeof(uint64_t));  // Reallocate memory
        if (s->items == NULL) return RATELPROF_STATUS_MALLOC_FAILED;
    }
    s->items[++(s->top)] = el;  // Increment top and push el
    return RATELPROF_STATUS_SUCCESS;
}

// Pop operation to remove the top element from the stack
ratelprof_status_t ratelprof_stack_pop(ratelprof_stack_t* s, uint64_t* poped_el) {
    if (!s) return RATELPROF_STATUS_STACK_IS_NULL;
    if (ratelprof_stack_is_empty(s)) {
        return RATELPROF_STATUS_STACK_IS_EMPTY;
    }
    *poped_el = s->items[(s->top)--];  // Return the top element and decrement top
    return RATELPROF_STATUS_SUCCESS;
}

// Peek operation to get the top element without removing it
ratelprof_status_t ratelprof_stack_peek(ratelprof_stack_t* s, uint64_t* peeked_el) {
    if (!s) return RATELPROF_STATUS_STACK_IS_NULL;
    if (ratelprof_stack_is_empty(s)) {
        return RATELPROF_STATUS_STACK_IS_EMPTY;
    }
    *peeked_el = s->items[s->top];
    return RATELPROF_STATUS_SUCCESS;
}

// Function to free the allocated memory when done
ratelprof_status_t ratelprof_stack_free(ratelprof_stack_t* s) {
    if (!s) return RATELPROF_STATUS_STACK_IS_NULL;
    free(s->items);
    s->items = NULL;
    s->top = -1;
    s->capacity = 0;
    return RATELPROF_STATUS_SUCCESS;
}
