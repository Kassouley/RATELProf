/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
#include <stdbool.h>

#include "ratelprof.h"
#include "ratelprof/ratelprof_api_table.h"

#include "utils/logger.h"

ratelprof_status_t ratelprof_init_api_table(ratelprof_domain_t domain, ratelprof_api_table_t* api_table, size_t size) 
{
    if (size == 0) return RATELPROF_STATUS_ALLOC_SIZE_0;
    if (!api_table) return RATELPROF_STATUS_INVALID_PTR;
    api_table->size = size;
    api_table->domain = domain;
    api_table->api_ptr = (void**)malloc(size * sizeof(void*));
    if (!api_table->api_ptr) return RATELPROF_STATUS_MALLOC_FAILED;
    api_table->api_fn = (void**)malloc(size * sizeof(void*));
    if (!api_table->api_fn) return RATELPROF_STATUS_MALLOC_FAILED;
    api_table->handler = NULL;
    api_table->is_populate = false;
    
    return RATELPROF_STATUS_SUCCESS;
}

ratelprof_status_t ratelprof_populate_api_table(ratelprof_api_table_t* api_table, const char* lib_path) 
{
    void* handler = RTLD_NEXT;
    if (lib_path) {
        handler = dlopen(lib_path, RTLD_LOCAL | RTLD_LAZY);
        if (!handler) return RATELPROF_STATUS_DLOPEN_FAILED;
    } 
    for (ratelprof_api_id_t id = 0; id < api_table->size; id++)
    {
        const char* funame = ratelprof_get_funame_by_id(api_table->domain, id);
        void* fn = (void*)(dlsym(handler, funame));
        if (!fn) {
            LOG(LOG_LEVEL_WARN, "Failed to load \"%s\". (%s) Skipping.\n", funame, dlerror());
            fn = (void*)fallback;
        }
        api_table->api_fn[id] = fn;
        api_table->api_ptr[id] = fn;
    }
    api_table->handler = handler;
    api_table->is_populate = true;
    return RATELPROF_STATUS_SUCCESS;
}

ratelprof_status_t ratelprof_cleanup_api_table(ratelprof_api_table_t* api_table) 
{
    if (!api_table) return RATELPROF_STATUS_INVALID_PTR;
    if (api_table->handler && api_table->handler != RTLD_NEXT) 
        dlclose(api_table->handler);
    free(api_table->api_ptr);
    free(api_table->api_fn);
    return RATELPROF_STATUS_SUCCESS;
}

ratelprof_status_t ratelprof_enable_api_table(ratelprof_api_table_t* api_table, const char* filter_var_name, const char* filter_type_name) 
{
    if (!api_table) return RATELPROF_STATUS_INVALID_PTR;
    if (api_table->api_fn == NULL) return RATELPROF_STATUS_API_TABLE_NOT_INIT;
    if (api_table->api_ptr == NULL) return RATELPROF_STATUS_API_TABLE_NOT_INIT;

    const char *filtered_functions = get_function_filter(filter_var_name);
    filter_t filter = get_filter_type(filter_type_name);

    char *functions_list = NULL, *token = NULL;
    ratelprof_api_id_t id = 0;
    
    if (filter == NO_FILTER) {
        for (id = 0; id < api_table->size; id++) {
            api_table->api_ptr[id] = ratelprof_get_funaddr_by_id(api_table->domain, id);
        }
    }
    else {
        bool blacklist[api_table->size];
        memset(blacklist, 0, sizeof(blacklist));

        functions_list = strdup(filtered_functions);
        token = strtok(functions_list, ",");
        while (token)
        {
            id = ratelprof_get_funid_by_name(api_table->domain, token);
            if (id >= 0 && id < api_table->size) {
                if (filter == WHITELIST) {
                    api_table->api_ptr[id] = ratelprof_get_funaddr_by_id(api_table->domain, id);
                } else if (filter == BLACKLIST) {
                    blacklist[id] = true;
                }
            }
            token = strtok(NULL, ",");
        }
        free(functions_list);

        if (filter == BLACKLIST) {
            for (id = 0; id < api_table->size; id++) {
                if (!blacklist[id]) 
                    api_table->api_ptr[id] = ratelprof_get_funaddr_by_id(api_table->domain, id);
            }
        }
    }
    return RATELPROF_STATUS_SUCCESS;
}

ratelprof_status_t ratelprof_disable_api_table(ratelprof_api_table_t* api_table) 
{
    if (!api_table) return RATELPROF_STATUS_INVALID_PTR;
    if (api_table->api_fn == NULL) return RATELPROF_STATUS_API_TABLE_NOT_INIT;
    if (api_table->api_ptr == NULL) return RATELPROF_STATUS_API_TABLE_NOT_INIT;
    for (ratelprof_api_id_t id = 0; id < api_table->size; id++)
    {
        api_table->api_ptr[id] = api_table->api_fn[id];
    }
    return RATELPROF_STATUS_SUCCESS;
}

void fallback(void) {
    LOG(LOG_LEVEL_FATAL, "A function that hasn't been load by RATELProf has been called. See warning logs for more details.\n");
}
