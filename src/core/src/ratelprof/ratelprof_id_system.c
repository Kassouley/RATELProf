/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdint.h>

#include "ratelprof/ratelprof_id_system.h"
#include "ratelprof/ratelprof_status.h"

#include "utils/logger.h"

/**
 * @brief Mutex for synchronizing access to the global ID counter.
 * 
 * This mutex ensures that the `global_id_counter` is accessed in a thread-safe manner 
 * by synchronizing access to it, preventing race conditions when incrementing the counter 
 * across multiple threads.
 */
static pthread_mutex_t id_mutex = PTHREAD_MUTEX_INITIALIZER;

/**
 * @brief Global counter for generating unique IDs across threads.
 * 
 * This variable holds the next unique ID to be allocated. It is incremented each time 
 * a new ID is requested and is accessed in a thread-safe manner using the `id_mutex`.
 * 
 * @note This counter starts at 1 and increments with each call to `push_id()`.
 */
static size_t global_id_counter = 1;

/**
 * @brief TLS key for the thread-local stack.
 * 
 * This variable holds the key for associating each thread with its own stack using 
 * thread-local storage (TLS). The key is used with functions like `pthread_setspecific` 
 * and `pthread_getspecific` to store and retrieve the stack pointer for the current thread.
 * 
 * @note This key is initialized during the `init_id_system` function and destroyed when 
 *       `cleanup_id_system` is called.
 */
static pthread_key_t thread_stack_key;


// Destructor function that will be called when the thread exits
void cleanup_stack(void* s)
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    if (s != NULL) {
        status = ratelprof_stack_free((ratelprof_stack_t*)s);
        if (status != RATELPROF_STATUS_SUCCESS) {
            LOG(LOG_LEVEL_ERROR, "Failed to free the ID stack. %s (code %d)\n", get_error_string(status), status);
            return;
        }
        free(s);  // Free the stack structure itself
    }
}


// Ensure the stack is initialized for the current thread
ratelprof_status_t get_thread_stack(ratelprof_stack_t** s)
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    *s = (ratelprof_stack_t*)pthread_getspecific(thread_stack_key);
    if (*s == NULL) {
        status = create_thread_stack(s);  // Initialize the stack if not found
    }
    return status;
}

ratelprof_status_t create_thread_stack(ratelprof_stack_t** s)
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    *s = (ratelprof_stack_t*)malloc(sizeof(ratelprof_stack_t));
    if (*s == NULL) return RATELPROF_STATUS_MALLOC_FAILED;
    status = ratelprof_stack_init(*s, 2048);
    if (status != RATELPROF_STATUS_SUCCESS) return status;
    pthread_setspecific(thread_stack_key, *s);  // Associate this stack with the current thread
    return status;
}

// Push a unique ID to the current thread's stack
ratelprof_status_t get_id(uint64_t *id)
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    ratelprof_stack_t* s;

    RATELPROF_TRY(
        get_thread_stack(&s),
        LOG(LOG_LEVEL_FATAL, "Failed to get thread specific ID stack. %s (code %d)\n", get_error_string(status), status)
    );

    // Lock the mutex to ensure safe access to global_id_counter
    pthread_mutex_lock(&id_mutex);
    *id = global_id_counter++;
    pthread_mutex_unlock(&id_mutex);
    
    RATELPROF_TRY(
        ratelprof_stack_push(s, *id),
        LOG(LOG_LEVEL_ERROR, "Failed to push an ID onto stack. %s (code %d)\n", get_error_string(status), status)
    );
    return status;
}

// Pop an ID from the current thread's stack
ratelprof_status_t pop_id()
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    ratelprof_stack_t* s;
    
    RATELPROF_TRY(
        get_thread_stack(&s),
        LOG(LOG_LEVEL_FATAL, "Failed to get thread specific ID stack. %s (code %d)\n", get_error_string(status), status)
    );
    
    uint64_t e;
    RATELPROF_TRY(
        ratelprof_stack_pop(s, &e),
        LOG(LOG_LEVEL_ERROR, "Failed to pop an ID from stack. %s (code %d)\n", get_error_string(status), status)
    );
    return status;
}

// Get the next correlation ID for the global thread
ratelprof_status_t get_correlation_id(uint64_t *corr_id)
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    ratelprof_stack_t* s;
    
    RATELPROF_TRY(
        get_thread_stack(&s),
        LOG(LOG_LEVEL_FATAL, "Failed to get thread specific ID stack. %s (code %d)\n", get_error_string(status), status)
    );
    
    RATELPROF_TRY(
        ratelprof_stack_peek(s, corr_id),
        LOG(LOG_LEVEL_ERROR, "Failed to peek a correlation ID from stack. %s (code %d)\n", get_error_string(status), status)
    );
    return status;
}

// Initialize the thread-local storage for the stack
ratelprof_status_t init_id_system()
{
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    // Create a TLS key with a destructor that will clean up the stack when the thread exits
    pthread_key_create(&thread_stack_key, cleanup_stack);
    ratelprof_stack_t* s;

    RATELPROF_TRY(
        create_thread_stack(&s),
        LOG(LOG_LEVEL_ERROR, "Cannot create new ID stack. %s (code %d)\n", get_error_string(status), status)
    );

    return status; 
}

// Clean up resources related to the global ID system
void cleanup_id_system() 
{
    // Delete the TLS key when it's no longer needed (e.g., when the program exits)
    pthread_key_delete(thread_stack_key);
}