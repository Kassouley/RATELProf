/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <time.h>
#include <unistd.h>

#include "ratelprof/ratelprof_status.h"
#include "ratelprof/ratelprof_time.h"
#include "ratelprof/ratelprof_lifecycle.h"

#include "utils/logger.h"
#include "utils/utils.h"

ratelprof_lifecycle_t lifecycle;

void ratelprof_init_lifecycle() 
{
    lifecycle.current_phase = RATELPROF_IN_TOOL_INIT_PHASE;
    lifecycle.tool_init_start = ratelprof_get_curr_timespec();
}


void ratelprof_fini_lifecycle() 
{
    if (lifecycle.main_data.argv) free(lifecycle.main_data.argv);
    lifecycle.tool_fini_stop = ratelprof_get_curr_timespec();
}


ratelprof_phase_t ratelprof_get_current_phase() 
{
    return lifecycle.current_phase;
}


ratelprof_lifecycle_t* ratelprof_get_lifecycle() 
{
    return &lifecycle;
}


int i_main(int argc, char **argv, char **envp)
{
    lifecycle.current_phase = RATELPROF_IN_MAIN_PHASE;
    lifecycle.main_data.argc = argc;
    lifecycle.main_data.argv = (char**)malloc(argc * sizeof(char*));
    if (!lifecycle.main_data.argv) {
        LOG(LOG_LEVEL_FATAL, "Cannot allocate main data argument. Out of memory ?\n");
    }
    for (int i = 0; i < argc; ++i) {
        lifecycle.main_data.argv[i] = strdup(argv[i]);
    }
    lifecycle.main_start = ratelprof_get_curr_timespec();
    lifecycle.main_data.retval = lifecycle.main_data.main_fn(argc, argv, envp);
    lifecycle.main_stop = ratelprof_get_curr_timespec();
    lifecycle.main_data.pid = get_pid();
    lifecycle.main_data.tid = get_tid();
    lifecycle.current_phase = RATELPROF_IN_DESTRUCTOR_PHASE;
    return lifecycle.main_data.retval;
}