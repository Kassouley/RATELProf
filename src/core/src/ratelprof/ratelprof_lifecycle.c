/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
#include <time.h>
#include <unistd.h>

#include "ratelprof/ratelprof_status.h"
#include "ratelprof/ratelprof_time.h"
#include "ratelprof/ratelprof_lifecycle.h"

#include "utils/logger.h"
#include "utils/utils.h"


static ratelprof_lifecycle_t lifecycle = {.current_phase = RATELPROF_IN_UNKNOWN_PHASE};


const char* ratelprof_get_phase_name(ratelprof_phase_t phase)
{
    switch (phase)
    {
        case RATELPROF_IN_CONSTRUCTOR_PHASE:    return "CONSTRUCTOR_PHASE"; break;
        case RATELPROF_IN_MAIN_PHASE:           return "MAIN_PHASE"; break;
        case RATELPROF_IN_DESTRUCTOR_PHASE:     return "DESTRUCTOR_PHASE"; break;
        
        default: return "Unknown phase"; break;
    }
    return "Unknown phase";
}


ratelprof_time_t ratelprof_get_normalized_time(ratelprof_time_t time)
{
    return time - lifecycle.normalizer;
}


void ratelprof_next_phase(void)
{
    ratelprof_timespec_t ts = ratelprof_get_curr_timespec();

    if (lifecycle.current_phase != RATELPROF_IN_UNKNOWN_PHASE 
        && lifecycle.current_phase < RATELPROF_NB_PHASE)
    {
        lifecycle.phase_stop_ts[lifecycle.current_phase] = ts;
    }
    
    lifecycle.current_phase++;
}


void ratelprof_start_lifecycle(void) 
{
    ratelprof_timespec_t ts = ratelprof_get_curr_timespec();
    
    lifecycle.experiment_start_epoch = ratelprof_get_curr_epoch();
    lifecycle.current_phase          = RATELPROF_IN_CONSTRUCTOR_PHASE;
    lifecycle.normalizer             = ratelprof_get_timestamp_ns(ts);
}


void ratelprof_stop_lifecycle(void) 
{
    for (ratelprof_phase_t i = lifecycle.current_phase; i < RATELPROF_NB_PHASE; i++)
    {
        ratelprof_next_phase();
    }
    lifecycle.current_phase = RATELPROF_IN_UNKNOWN_PHASE;
}


ratelprof_phase_t ratelprof_get_current_phase(void) 
{
    return lifecycle.current_phase;
}


ratelprof_lifecycle_t* ratelprof_get_lifecycle(void) 
{
    return &lifecycle;
}


ratelprof_time_t ratelprof_get_constructor_time(void)
{
    ratelprof_time_t constructor_stop = ratelprof_get_timestamp_ns(lifecycle.phase_stop_ts[RATELPROF_IN_CONSTRUCTOR_PHASE]);
    return ratelprof_get_normalized_time(constructor_stop);
}


ratelprof_time_t ratelprof_get_main_time(void)
{
    ratelprof_time_t main_start = ratelprof_get_timestamp_ns(lifecycle.phase_stop_ts[RATELPROF_IN_CONSTRUCTOR_PHASE]);
    ratelprof_time_t main_stop  = ratelprof_get_timestamp_ns(lifecycle.phase_stop_ts[RATELPROF_IN_MAIN_PHASE]);
    return main_stop - main_start;
}


ratelprof_time_t ratelprof_get_destructor_time(void)
{
    ratelprof_time_t destructor_start = ratelprof_get_timestamp_ns(lifecycle.phase_stop_ts[RATELPROF_IN_MAIN_PHASE]);
    ratelprof_time_t destructor_stop  = ratelprof_get_timestamp_ns(lifecycle.phase_stop_ts[RATELPROF_IN_DESTRUCTOR_PHASE]);
    return destructor_stop - destructor_start;

}


int i_main(int argc, char **argv, char **envp)
{
    lifecycle.main_data.pid  = get_pid();
    lifecycle.main_data.tid  = get_tid();
    lifecycle.main_data.argc = argc;
    lifecycle.main_data.argv = (char**)malloc(argc * sizeof(char*) + 1);

    if (!lifecycle.main_data.argv) {
        LOG(LOG_LEVEL_FATAL, "Cannot allocate main data argument. Out of memory ?\n");
    }
    for (int i = 0; i < argc; ++i) {
        lifecycle.main_data.argv[i] = strdup(argv[i]);
    }

    ratelprof_next_phase();

    lifecycle.main_data.retval = lifecycle.main_data.main_fn(argc, argv, envp);

    ratelprof_next_phase();

    return lifecycle.main_data.retval;
}