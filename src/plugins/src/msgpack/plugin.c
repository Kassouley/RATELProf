/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */
 
#include <string.h>
#include <errno.h>
#include <sys/file.h>
#include <ratelprof.h>
#include <ratelprof_ext.h>
#include "version.h"
#include "msgpack.h"

#include "activity_plugin.h" 
#include "hsa_plugin.h"
#include "omp_tgt_rtl_plugin.h"
#include "omp_routine_plugin.h"
#include "hip_plugin.h"
#include "mpi_plugin.h"
#include "ompt_plugin.h"


typedef struct {
    msgpack_buffer_t buffer;
    size_t size;
} plugin_traces_t;


typedef struct ratelprof_plugin_s {
	api_callback_handler_t hsa_callback_handler;
	api_callback_handler_t omp_tgt_rtl_callback_handler;
	api_callback_handler_t omp_routine_callback_handler;
	api_callback_handler_t hip_callback_handler;
	api_callback_handler_t mpi_callback_handler;
    api_callback_handler_t ompt_callback_handler;

    activity_callback_t activity_callback;
    plugin_traces_t* traces;
} ratelprof_plugin_t;


static bool count_location(ratelprof_source_data_t *loc, void *user_data) {
    if (loc->addr) {
        (*(size_t *)user_data)++;
    }
    return false;
}

static bool encode_location(ratelprof_source_data_t *loc, void *user_data) {
    msgpack_buffer_t* buf = (msgpack_buffer_t*) user_data;
    if (loc->addr) {
        msgpack_encode_uint(buf, (uintptr_t)loc->addr);
        msgpack_encode_map(buf, 4);
        msgpack_encode_string_ext(buf, "ofile");
        msgpack_encode_string_ext(buf, loc->object_file ? loc->object_file : "<unknown>");
        msgpack_encode_string_ext(buf, "sfile");
        msgpack_encode_string_ext(buf, loc->filename ? loc->filename : "<unknown>");
        msgpack_encode_string_ext(buf, "sfun");
        msgpack_encode_string_ext(buf, loc->func ? demangle(loc->func, 1) : "<unknown>");
        msgpack_encode_string_ext(buf, "sline");
        msgpack_encode_uint(buf, loc->line);
    }
    return false;
}


static inline char* get_report_filename() {
    static char filename[512];
    int rank = get_mpi_rank_from_env();  // returns -1 if not in MPI

    const char* base_filename = get_output_file();
    if (rank >= 0) {
        snprintf(filename, sizeof(filename), "rank_%d_%s", rank, base_filename);
    } else {
        snprintf(filename, sizeof(filename), "%s", base_filename);
    }
    return filename;
}

static inline void memorize_filename(char filename[512])
{
    const char *filepath = "/tmp/rprof_output_filename.txt";

    // Open file for appending, create if not exists
    int fd = open(filepath, O_WRONLY | O_CREAT | O_APPEND, 0666);
    if (fd == -1) {
        LOG(LOG_LEVEL_ERROR, "Failed to open file %s for writing: %s\n", filepath, strerror(errno));
        return;
    }

    // Lock the file exclusively
    if (flock(fd, LOCK_EX) == -1) {
        LOG(LOG_LEVEL_ERROR, "Failed to lock file %s: %s\n", filepath, strerror(errno));
        close(fd);
        return;
    }

    // Write the data safely
    ssize_t written = write(fd, filename, strlen(filename));
    if (written == -1) {
        LOG(LOG_LEVEL_ERROR, "Failed to write to file %s: %s\n", filepath, strerror(errno));
        flock(fd, LOCK_UN); // unlock before returning
        close(fd);
        return;
    }

    written = write(fd, "\n", 1);
    if (written == -1) {
        LOG(LOG_LEVEL_ERROR, "Failed to write to file %s: %s\n", filepath, strerror(errno));
        flock(fd, LOCK_UN); // unlock before returning
        close(fd);
        return;
    }

    // Unlock and close
    flock(fd, LOCK_UN);
    close(fd);
}


/** RATELProf Ext encoding 
 *      Encoding as follow : 
 *          - extension bytes (magic bytes)
 *          - tool version as 3 uint
 *          - experiment start epoch time as uint
 *          - lifecycle stop time as array
 *          - main data
 *          - map node id to agent object
 *          - string extension mapping
 *          - location data
 *          - trace data
 */
static inline void encode_ratelprof_ext(ratelprof_plugin_t* p) {
    plugin_traces_t* traces = p->traces;
    
    ratelprof_lifecycle_t* lc = ratelprof_get_lifecycle();
    size_t i = 0;
    msgpack_buffer_t main_buffer;

    char* filename = get_report_filename();
    memorize_filename(filename);
    msgpack_init(&main_buffer, 0xff, MSGPACK_OVERFLOW_WRITE_TO_FILE, filename);

    msgpack_encode_ext(&main_buffer,  MSGPACK_EXT_RATELPROF, NULL, 0);

    // Encode tool version
    msgpack_encode_array(&main_buffer, 3);
    msgpack_encode_uint(&main_buffer, RATELPROF_MAJOR);
    msgpack_encode_uint(&main_buffer, RATELPROF_MINOR);
    msgpack_encode_uint(&main_buffer, RATELPROF_PATCH);


    // Encode experiment start
    msgpack_encode_uint(&main_buffer, ratelprof_get_timestamp_ns(lc->experiment_start_epoch));

    // Encode experiment rank
    msgpack_encode_uint(&main_buffer, get_mpi_rank_from_env());

    // Encode lifecycle stop time (first start is 0 and other start are prev stop)
    msgpack_encode_array(&main_buffer, RATELPROF_NB_PHASE);
    for (i = 0; i < RATELPROF_NB_PHASE; i++)
    {
        ratelprof_time_t t = ratelprof_get_timestamp_ns(lc->phase_stop_ts[i]);
        msgpack_encode_uint(&main_buffer, ratelprof_get_normalized_time(t));
    }

    // Encode main data
    msgpack_encode_array(&main_buffer, lc->main_data.argc + 1);
    msgpack_encode_int(&main_buffer, lc->main_data.retval);
    for (i = 0; i < lc->main_data.argc; i++)
    {
        msgpack_encode_string(&main_buffer, lc->main_data.argv[i]);
    }
    

    // Encode map Node ID to Agent Object
    ratelprof_object_tracking_pool_t* pool = ratelprof_object_tracking_pool_get_pool();
    ratelprof_agent_object_t*  agents_list = pool->agents_list;
    size_t                    agents_count = pool->agents_count;

    if (agents_list && agents_count > 0) {
        msgpack_encode_map(&main_buffer, agents_count);
        for (i = 0; i < agents_count; i++) {
            msgpack_encode_uint(&main_buffer, agents_list[i].handle);
            msgpack_encode_uint(&main_buffer, i);
        }
    } else {
        msgpack_encode_map(&main_buffer, 0);
    }

    // Preprocess location source data
    msgpack_buffer_t location_data;
    msgpack_init(&location_data, 0xfffff, MSGPACK_OVERFLOW_REALLOC, NULL);

    size_t location_counter = 0;
    ratelprof_iterate_location_cache(count_location, &location_counter);

    msgpack_encode_map(&location_data, location_counter);

    ratelprof_iterate_location_cache(encode_location, &location_data);

   
    // Preprocess trace event data
    msgpack_buffer_t trace_events;
    msgpack_init(&trace_events, 0xffffff, MSGPACK_OVERFLOW_REALLOC, NULL);

    size_t nb_domain_util = 0;
    for (i = 0; i < RATELPROF_NB_DOMAIN_EXT; i++) {
        if (traces[i].size != 0)
            nb_domain_util++;
    }
    
    msgpack_encode_map(&trace_events, nb_domain_util);
    for (i = 0; i < RATELPROF_NB_DOMAIN_EXT; i++) {
        if (traces[i].size != 0) {
            msgpack_encode_string_ext(&trace_events, ratelprof_get_domain_name(i));
            msgpack_encode_map(&trace_events, traces[i].size);
            msgpack_concat(&trace_events, &traces[i].buffer);
            msgpack_free(&traces[i].buffer);
        }
    }

    // Encode string extension mapping
    msgpack_encode_string_table_ext(&main_buffer);

    // Encode location data
    msgpack_concat(&main_buffer, &location_data);
    msgpack_free(&location_data);

    // Encode trace event data
    msgpack_concat(&main_buffer, &trace_events);
    msgpack_free(&trace_events);

    msgpack_free(&main_buffer); // Write data and free
}



ratelprof_status_t ratelprof_plugin_initialize(ratelprof_plugin_t** plugin) 
{
    ratelprof_plugin_t* p = NULL;
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    
    if (plugin == NULL) return RATELPROF_STATUS_INVALID_PTR;
    if (*plugin != NULL) return RATELPROF_STATUS_PLUGIN_ALREADY_INIT;
    
    p = (ratelprof_plugin_t*)malloc(sizeof(ratelprof_plugin_t));
    if (!p) return RATELPROF_STATUS_MALLOC_FAILED;
    
    p->hsa_callback_handler.on_enter = on_enter_hsa_callback;
    p->hsa_callback_handler.on_exit = on_exit_hsa_callback;
    p->omp_tgt_rtl_callback_handler.on_enter = on_enter_omp_tgt_rtl_callback;
    p->omp_tgt_rtl_callback_handler.on_exit = on_exit_omp_tgt_rtl_callback;
    p->omp_routine_callback_handler.on_enter = on_enter_omp_routine_callback;
    p->omp_routine_callback_handler.on_exit = on_exit_omp_routine_callback;
    p->hip_callback_handler.on_enter = on_enter_hip_callback;
    p->hip_callback_handler.on_exit = on_exit_hip_callback;
    p->mpi_callback_handler.on_enter = on_enter_mpi_callback;
    p->mpi_callback_handler.on_exit = on_exit_mpi_callback;
    p->ompt_callback_handler.on_enter = on_enter_ompt_callback;
    p->ompt_callback_handler.on_exit = on_exit_ompt_callback; 

    p->activity_callback = activity_callback; 
    
    p->traces = (plugin_traces_t*)malloc(RATELPROF_NB_DOMAIN_EXT * sizeof(plugin_traces_t));
    for (int i = 0; i < RATELPROF_NB_DOMAIN_EXT; i++) {
        p->traces[i].size = 0;
        const char* domain_name = ratelprof_get_domain_name(i);
        if (is_set_domain(domain_name)) {
            msgpack_init(&p->traces[i].buffer, 0xffffff, MSGPACK_OVERFLOW_REALLOC, NULL);
        }
    }

    msgpack_ext_string_init();

    *plugin = p;
    return status;
}

ratelprof_status_t ratelprof_plugin_finalize(ratelprof_plugin_t** plugin) 
{
    ratelprof_plugin_t* p = NULL;
    ratelprof_status_t status = RATELPROF_STATUS_SUCCESS;
    if (plugin == NULL) return RATELPROF_STATUS_INVALID_PTR;
    if (*plugin == NULL) return RATELPROF_STATUS_PLUGIN_IS_NULL;
    
    p = *plugin;
    encode_ratelprof_ext(p);

    free(p->traces);
    msgpack_ext_string_free();

    free(*plugin);
    *plugin = NULL;
    return status;
}

ratelprof_status_t ratelprof_get_api_callback(const ratelprof_plugin_t* plugin, ratelprof_domain_t domain, api_callback_handler_t* callback_handler) 
{
    if (plugin == NULL) return RATELPROF_STATUS_INVALID_PTR;
    switch(domain)
    {
        case RATELPROF_DOMAIN_HSA: *callback_handler = plugin->hsa_callback_handler; break;
        case RATELPROF_DOMAIN_OMP_TGT_RTL: *callback_handler = plugin->omp_tgt_rtl_callback_handler; break;
        case RATELPROF_DOMAIN_OMP_ROUTINE: *callback_handler = plugin->omp_routine_callback_handler; break;
        case RATELPROF_DOMAIN_HIP: *callback_handler = plugin->hip_callback_handler; break;
        case RATELPROF_DOMAIN_MPI: *callback_handler = plugin->mpi_callback_handler; break;
        case RATELPROF_DOMAIN_OMP_REGION: *callback_handler = plugin->ompt_callback_handler; break; 
        default: return RATELPROF_STATUS_UNKNOWN_DOMAIN;
    }
    return RATELPROF_STATUS_SUCCESS;
}


ratelprof_status_t ratelprof_get_activity_callback(const ratelprof_plugin_t* plugin, activity_callback_t* activity_callback, void** activity_callback_user_args) 
{
    if (plugin == NULL) return RATELPROF_STATUS_INVALID_PTR;
    if (activity_callback == NULL) return RATELPROF_STATUS_INVALID_PTR;
    if (activity_callback_user_args == NULL) return RATELPROF_STATUS_INVALID_PTR;
    *activity_callback = plugin->activity_callback;
    *activity_callback_user_args = plugin->traces;
    return RATELPROF_STATUS_SUCCESS;
}