/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */
 
#include <stdio.h>
#include <ratelprof.h>
#include "hip_plugin.h"

void on_enter_hip_callback(ratelprof_domain_t domain, ratelprof_api_id_t id, void* user_activity)
{
    ratelprof_api_activity_t* activity = (ratelprof_api_activity_t*)user_activity;
    get_hip_pointed_args_for(id, activity->args, 1);
    activity->phase = ratelprof_get_current_phase();
    activity->domain = domain;
    get_correlation_id(&activity->corr_id);
    get_id(&activity->id);
    activity->funid = id;
}

void on_exit_hip_callback(ratelprof_domain_t domain, ratelprof_api_id_t id, void* user_activity)
{
    ratelprof_api_activity_t* activity = (ratelprof_api_activity_t*)user_activity;
    get_hip_pointed_args_for(id, activity->args, 0);
    activity->pid = get_pid();
    activity->tid = get_tid();
    printf("-----------\n");
    printf("PHASE:%d : %s | ID: %lu | CID: %lu\n", activity->phase, get_hip_funame_by_id(activity->funid), activity->id, activity->corr_id);
    ratelprof_get_and_print_location(activity->return_address);
    process_hip_args_for(activity->funid, activity->args, NULL);
    pop_id();
}

void process_hip_args_for(hip_api_id_t funid, const void* func_args, void* user_args)
{
    switch(funid) {
		#if HAVE_hipMemPtrGetInfo
		case HIP_API_ID_hipMemPtrGetInfo : {
			//	void * ptr (void *);
			//	size_t * size (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPtrGetInfo_t* args = (args_hipMemPtrGetInfo_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tsize_t * size = %p", args->size);
			if (args->size != NULL) {
				printf(" -> %lu\n", args->size__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParams1D
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParams1D : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecMemcpyNodeSetParams1D_t* args = (args_hipGraphExecMemcpyNodeSetParams1D_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxEnablePeerAccess
		case HIP_API_ID_hipCtxEnablePeerAccess : {
			//	hipCtx_t peerCtx (struct ihipCtx_t *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxEnablePeerAccess_t* args = (args_hipCtxEnablePeerAccess_t*) func_args;
			printf("\thipCtx_t peerCtx = %p", args->peerCtx);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostUnregister
		case HIP_API_ID_hipHostUnregister : {
			//	void * hostPtr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipHostUnregister_t* args = (args_hipHostUnregister_t*) func_args;
			printf("\tvoid * hostPtr = %p", args->hostPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDevicePrimaryCtxGetState
		case HIP_API_ID_hipDevicePrimaryCtxGetState : {
			//	hipDevice_t dev (int);
			//	unsigned int * flags (unsigned int *);
			//	int * active (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipDevicePrimaryCtxGetState_t* args = (args_hipDevicePrimaryCtxGetState_t*) func_args;
			printf("\thipDevice_t dev = %d\n", args->dev);
			printf("\tunsigned int * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %u\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\tint * active = %p", args->active);
			if (args->active != NULL) {
				printf(" -> %d\n", args->active__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipPointerGetAttribute
		case HIP_API_ID_hipPointerGetAttribute : {
			//	void * data (void *);
			//	hipPointer_attribute attribute (enum hipPointer_attribute);
			//	hipDeviceptr_t ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipPointerGetAttribute_t* args = (args_hipPointerGetAttribute_t*) func_args;
			printf("\tvoid * data = %p", args->data);
			printf("\n");
			printf("\thipPointer_attribute attribute = %d\n", args->attribute);
			printf("\thipDeviceptr_t ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolGetAccess
		case HIP_API_ID_hipMemPoolGetAccess : {
			//	hipMemAccessFlags * flags (enum hipMemAccessFlags*);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemLocation * location ({
			//		hipMemLocationType type (enum hipMemLocationType);
			//		int id (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolGetAccess_t* args = (args_hipMemPoolGetAccess_t*) func_args;
			printf("\thipMemAccessFlags * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %d\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipMemLocation * location = %p", args->location);
			if (args->location != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocationType type = %d\n", args->location__ref.val.type);
				printf("\t\tint id = %d\n", args->location__ref.val.id);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetD32
		case HIP_API_ID_hipMemsetD32 : {
			//	hipDeviceptr_t dest (void *);
			//	int value (int);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetD32_t* args = (args_hipMemsetD32_t*) func_args;
			printf("\thipDeviceptr_t dest = %p", args->dest);
			printf("\n");
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetMipMappedArray
		case HIP_API_ID_hipTexRefGetMipMappedArray : {
			//	hipMipmappedArray_t * pArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetMipMappedArray_t* args = (args_hipTexRefGetMipMappedArray_t*) func_args;
			printf("\thipMipmappedArray_t * pArray = %p", args->pArray);
			if (args->pArray != NULL) {
				printf("-> %p", args->pArray__ref.ptr1);
				if (args->pArray__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->pArray__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->pArray__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->pArray__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->pArray__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->pArray__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->pArray__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->pArray__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->pArray__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->pArray__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->pArray__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->pArray__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->pArray__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->pArray__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->pArray__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMalloc3D
		case HIP_API_ID_hipMalloc3D : {
			//	hipPitchedPtr * pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMalloc3D_t* args = (args_hipMalloc3D_t*) func_args;
			printf("\thipPitchedPtr * pitchedDevPtr = %p", args->pitchedDevPtr);
			if (args->pitchedDevPtr != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t pitch = %lu\n", args->pitchedDevPtr__ref.val.pitch);
				printf("\t\tsize_t xsize = %lu\n", args->pitchedDevPtr__ref.val.xsize);
				printf("\t\tsize_t ysize = %lu\n", args->pitchedDevPtr__ref.val.ysize);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetD8
		case HIP_API_ID_hipMemsetD8 : {
			//	hipDeviceptr_t dest (void *);
			//	unsigned char value (unsigned char);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetD8_t* args = (args_hipMemsetD8_t*) func_args;
			printf("\thipDeviceptr_t dest = %p", args->dest);
			printf("\n");
			printf("\tunsigned char value = %hhu\n", args->value);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocArray
		case HIP_API_ID_hipMallocArray : {
			//	hipArray_t * array (struct hipArray **);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocArray_t* args = (args_hipMallocArray_t*) func_args;
			printf("\thipArray_t * array = %p", args->array);
			if (args->array != NULL) {
				printf(" -> %p\n", args->array__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphEventWaitNodeGetEvent
		case HIP_API_ID_hipGraphEventWaitNodeGetEvent : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t * event_out (struct ihipEvent_t **);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphEventWaitNodeGetEvent_t* args = (args_hipGraphEventWaitNodeGetEvent_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipEvent_t * event_out = %p", args->event_out);
			if (args->event_out != NULL) {
				printf(" -> %p\n", args->event_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvMemcpy3D
		case HIP_API_ID_hipDrvMemcpy3D : {
			//	const HIP_MEMCPY3D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		size_t srcZ (unsigned long);
			//		size_t srcLOD (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t srcHeight (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		size_t dstZ (unsigned long);
			//		size_t dstLOD (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t dstHeight (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipDrvMemcpy3D_t* args = (args_hipDrvMemcpy3D_t*) func_args;
			printf("\tconst HIP_MEMCPY3D * pCopy = %p", args->pCopy);
			if (args->pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->pCopy__ref.val.srcY);
				printf("\t\tsize_t srcZ = %lu\n", args->pCopy__ref.val.srcZ);
				printf("\t\tsize_t srcLOD = %lu\n", args->pCopy__ref.val.srcLOD);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->pCopy__ref.val.srcPitch);
				printf("\t\tsize_t srcHeight = %lu\n", args->pCopy__ref.val.srcHeight);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->pCopy__ref.val.dstY);
				printf("\t\tsize_t dstZ = %lu\n", args->pCopy__ref.val.dstZ);
				printf("\t\tsize_t dstLOD = %lu\n", args->pCopy__ref.val.dstLOD);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->pCopy__ref.val.dstPitch);
				printf("\t\tsize_t dstHeight = %lu\n", args->pCopy__ref.val.dstHeight);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->pCopy__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->pCopy__ref.val.Depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
		case HIP_API_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags : {
			//	int * numBlocks (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_t* args = (args_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_t*) func_args;
			printf("\tint * numBlocks = %p", args->numBlocks);
			if (args->numBlocks != NULL) {
				printf(" -> %d\n", args->numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostMalloc
		case HIP_API_ID_hipHostMalloc : {
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipHostMalloc_t* args = (args_hipHostMalloc_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleGetTexRef
		case HIP_API_ID_hipModuleGetTexRef : {
			//	textureReference ** texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipModule_t hmod (struct ihipModule_t *);
			//	const char * name (const char *);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleGetTexRef_t* args = (args_hipModuleGetTexRef_t*) func_args;
			printf("\ttextureReference ** texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf("-> %p", args->texRef__ref.ptr1);
				if (args->texRef__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
					printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
					printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
					printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
					printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
					printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
					printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
					printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
					printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
					printf("\t\t}\n");
					printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
					printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
					printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
					printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
					printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
					printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
					printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
					printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipModule_t hmod = %p", args->hmod);
			printf("\n");
			printf("\tconst char * name = %p", args->name);
			if (args->name != NULL) {
				printf(" -> %s\n", args->name__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipIpcGetMemHandle
		case HIP_API_ID_hipIpcGetMemHandle : {
			//	hipIpcMemHandle_t * handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	void * devPtr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipIpcGetMemHandle_t* args = (args_hipIpcGetMemHandle_t*) func_args;
			printf("\thipIpcMemHandle_t * handle = %p", args->handle);
			if (args->handle != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[64] reserved = %c\n", args->handle__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tvoid * devPtr = %p", args->devPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyDtoHAsync
		case HIP_API_ID_hipMemcpyDtoHAsync : {
			//	void * dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyDtoHAsync_t* args = (args_hipMemcpyDtoHAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleLoad
		case HIP_API_ID_hipModuleLoad : {
			//	hipModule_t * module (struct ihipModule_t **);
			//	const char * fname (const char *);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleLoad_t* args = (args_hipModuleLoad_t*) func_args;
			printf("\thipModule_t * module = %p", args->module);
			if (args->module != NULL) {
				printf(" -> %p\n", args->module__ref.val);
			} else { printf("\n"); };
			printf("\tconst char * fname = %p", args->fname);
			if (args->fname != NULL) {
				printf(" -> %s\n", args->fname__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipWaitExternalSemaphoresAsync
		case HIP_API_ID_hipWaitExternalSemaphoresAsync : {
			//	const hipExternalSemaphore_t * extSemArray (const void * *);
			//	const hipExternalSemaphoreWaitParams * paramsArray ({
			//		struct (unnamed struct at header/hip/hip.h:1505:2) params ({
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	unsigned int numExtSems (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipWaitExternalSemaphoresAsync_t* args = (args_hipWaitExternalSemaphoresAsync_t*) func_args;
			printf("\tconst hipExternalSemaphore_t * extSemArray = %p", args->extSemArray);
			if (args->extSemArray != NULL) {
				printf("-> %p", args->extSemArray__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalSemaphoreWaitParams * paramsArray = %p", args->paramsArray);
			if (args->paramsArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1505:2) params = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->paramsArray__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->paramsArray__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numExtSems = %u\n", args->numExtSems);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphKernelNodeGetParams
		case HIP_API_ID_hipGraphKernelNodeGetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphKernelNodeGetParams_t* args = (args_hipGraphKernelNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipKernelNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphLaunch
		case HIP_API_ID_hipGraphLaunch : {
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphLaunch_t* args = (args_hipGraphLaunch_t*) func_args;
			printf("\thipGraphExec_t graphExec = %p", args->graphExec);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostAlloc
		case HIP_API_ID_hipHostAlloc : {
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipHostAlloc_t* args = (args_hipHostAlloc_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipSetDevice
		case HIP_API_ID_hipSetDevice : {
			//	int deviceId (int);
			//	hipError_t retval (enum hipError_t);
			args_hipSetDevice_t* args = (args_hipSetDevice_t*) func_args;
			printf("\tint deviceId = %d\n", args->deviceId);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleOccupancyMaxPotentialBlockSizeWithFlags
		case HIP_API_ID_hipModuleOccupancyMaxPotentialBlockSizeWithFlags : {
			//	int * gridSize (int *);
			//	int * blockSize (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	int blockSizeLimit (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleOccupancyMaxPotentialBlockSizeWithFlags_t* args = (args_hipModuleOccupancyMaxPotentialBlockSizeWithFlags_t*) func_args;
			printf("\tint * gridSize = %p", args->gridSize);
			if (args->gridSize != NULL) {
				printf(" -> %d\n", args->gridSize__ref.val);
			} else { printf("\n"); };
			printf("\tint * blockSize = %p", args->blockSize);
			if (args->blockSize != NULL) {
				printf(" -> %d\n", args->blockSize__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\tint blockSizeLimit = %d\n", args->blockSizeLimit);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphNodeGetDependentNodes
		case HIP_API_ID_hipGraphNodeGetDependentNodes : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraphNode_t * pDependentNodes (struct hipGraphNode **);
			//	size_t * pNumDependentNodes (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphNodeGetDependentNodes_t* args = (args_hipGraphNodeGetDependentNodes_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipGraphNode_t * pDependentNodes = %p", args->pDependentNodes);
			if (args->pDependentNodes != NULL) {
				printf(" -> %p\n", args->pDependentNodes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * pNumDependentNodes = %p", args->pNumDependentNodes);
			if (args->pNumDependentNodes != NULL) {
				printf(" -> %lu\n", args->pNumDependentNodes__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtStreamGetCUMask
		case HIP_API_ID_hipExtStreamGetCUMask : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	uint32_t cuMaskSize (unsigned int);
			//	uint32_t * cuMask (unsigned int*);
			//	hipError_t retval (enum hipError_t);
			args_hipExtStreamGetCUMask_t* args = (args_hipExtStreamGetCUMask_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tuint32_t cuMaskSize = %u\n", args->cuMaskSize);
			printf("\tuint32_t * cuMask = %p", args->cuMask);
			if (args->cuMask != NULL) {
				printf(" -> %u\n", args->cuMask__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetD16
		case HIP_API_ID_hipMemsetD16 : {
			//	hipDeviceptr_t dest (void *);
			//	unsigned short value (unsigned short);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetD16_t* args = (args_hipMemsetD16_t*) func_args;
			printf("\thipDeviceptr_t dest = %p", args->dest);
			printf("\n");
			printf("\tunsigned short value = %hu\n", args->value);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchKernel
		case HIP_API_ID_hipLaunchKernel : {
			//	const void * function_address (const void *);
			//	dim3 numBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 dimBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** args (void **);
			//	size_t sharedMemBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchKernel_t* args = (args_hipLaunchKernel_t*) func_args;
			printf("\tconst void * function_address = %p", args->function_address);
			printf("\n");
			printf("\tdim3 numBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->numBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->numBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->numBlocks.z);
			printf("\t}\n");
			printf("\tdim3 dimBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->dimBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->dimBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->dimBlocks.z);
			printf("\t}\n");
			printf("\tvoid ** args = %p", args->args);
			if (args->args != NULL) {
				printf("-> %p", args->args__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sharedMemBytes = %lu\n", args->sharedMemBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetErrorString
		case HIP_API_ID_hipGetErrorString : {
			//	hipError_t hipError (enum hipError_t);
			//	const char * retval (const char *);
			args_hipGetErrorString_t* args = (args_hipGetErrorString_t*) func_args;
			printf("\thipError_t hipError = %d\n", args->hipError);
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipModuleLoadDataEx
		case HIP_API_ID_hipModuleLoadDataEx : {
			//	hipModule_t * module (struct ihipModule_t **);
			//	const void * image (const void *);
			//	unsigned int numOptions (unsigned int);
			//	hipJitOption * options (enum hipJitOption*);
			//	void ** optionValues (void **);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleLoadDataEx_t* args = (args_hipModuleLoadDataEx_t*) func_args;
			printf("\thipModule_t * module = %p", args->module);
			if (args->module != NULL) {
				printf(" -> %p\n", args->module__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * image = %p", args->image);
			printf("\n");
			printf("\tunsigned int numOptions = %u\n", args->numOptions);
			printf("\thipJitOption * options = %p", args->options);
			if (args->options != NULL) {
				printf(" -> %d\n", args->options__ref.val);
			} else { printf("\n"); };
			printf("\tvoid ** optionValues = %p", args->optionValues);
			if (args->optionValues != NULL) {
				printf("-> %p", args->optionValues__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetFilterMode
		case HIP_API_ID_hipTexRefGetFilterMode : {
			//	enum hipTextureFilterMode * pfm (enum hipTextureFilterMode *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetFilterMode_t* args = (args_hipTexRefGetFilterMode_t*) func_args;
			printf("\tenum hipTextureFilterMode * pfm = %p", args->pfm);
			if (args->pfm != NULL) {
				printf(" -> %d\n", args->pfm__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphInstantiateWithParams
		case HIP_API_ID_hipGraphInstantiateWithParams : {
			//	hipGraphExec_t * pGraphExec (struct hipGraphExec **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphInstantiateParams * instantiateParams ({
			//		hipGraphNode_t errNode_out (struct hipGraphNode *);
			//		unsigned long long flags (unsigned long long);
			//		hipGraphInstantiateResult result_out (enum hipGraphInstantiateResult);
			//		hipStream_t uploadStream (struct ihipStream_t *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphInstantiateWithParams_t* args = (args_hipGraphInstantiateWithParams_t*) func_args;
			printf("\thipGraphExec_t * pGraphExec = %p", args->pGraphExec);
			if (args->pGraphExec != NULL) {
				printf(" -> %p\n", args->pGraphExec__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipGraphInstantiateParams * instantiateParams = %p", args->instantiateParams);
			if (args->instantiateParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned long long flags = %llu\n", args->instantiateParams__ref.val.flags);
				printf("\t\thipGraphInstantiateResult result_out = %d\n", args->instantiateParams__ref.val.result_out);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemcpyNodeSetParams1D
		case HIP_API_ID_hipGraphMemcpyNodeSetParams1D : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemcpyNodeSetParams1D_t* args = (args_hipGraphMemcpyNodeSetParams1D_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamSynchronize
		case HIP_API_ID_hipStreamSynchronize : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamSynchronize_t* args = (args_hipStreamSynchronize_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphicsUnmapResources
		case HIP_API_ID_hipGraphicsUnmapResources : {
			//	int count (int);
			//	hipGraphicsResource_t * resources (struct _hipGraphicsResource**);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphicsUnmapResources_t* args = (args_hipGraphicsUnmapResources_t*) func_args;
			printf("\tint count = %d\n", args->count);
			printf("\thipGraphicsResource_t * resources = %p", args->resources);
			if (args->resources != NULL) {
				printf(" -> %p\n", args->resources__ref.val);
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DFromArray_spt
		case HIP_API_ID_hipMemcpy2DFromArray_spt : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DFromArray_spt_t* args = (args_hipMemcpy2DFromArray_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\thipArray_const_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParamsFromSymbol
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParamsFromSymbol : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecMemcpyNodeSetParamsFromSymbol_t* args = (args_hipGraphExecMemcpyNodeSetParamsFromSymbol_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetMipmapLevelBias
		case HIP_API_ID_hipTexRefGetMipmapLevelBias : {
			//	float * pbias (float *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetMipmapLevelBias_t* args = (args_hipTexRefGetMipmapLevelBias_t*) func_args;
			printf("\tfloat * pbias = %p", args->pbias);
			if (args->pbias != NULL) {
				printf(" -> %f\n", args->pbias__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddExternalSemaphoresSignalNode
		case HIP_API_ID_hipGraphAddExternalSemaphoresSignalNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipExternalSemaphoreSignalNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddExternalSemaphoresSignalNode_t* args = (args_hipGraphAddExternalSemaphoresSignalNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst hipExternalSemaphoreSignalNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtGetLastError
		case HIP_API_ID_hipExtGetLastError : {
			//	hipError_t retval (enum hipError_t);
			args_hipExtGetLastError_t* args = (args_hipExtGetLastError_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemMapArrayAsync
		case HIP_API_ID_hipMemMapArrayAsync : {
			//	hipArrayMapInfo * mapInfoList ({
			//		hipResourceType resourceType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:1643:2) resource ({
			//		});
			//		hipArraySparseSubresourceType subresourceType (enum hipArraySparseSubresourceType);
			//		union (unnamed union at header/hip/hip.h:1648:2) subresource ({
			//		});
			//		hipMemOperationType memOperationType (enum hipMemOperationType);
			//		hipMemHandleType memHandleType (enum hipMemHandleType);
			//		union (unnamed union at header/hip/hip.h:1667:2) memHandle ({
			//		});
			//		unsigned long long offset (unsigned long long);
			//		unsigned int deviceBitMask (unsigned int);
			//		unsigned int flags (unsigned int);
			//		unsigned int[2] reserved (unsigned int[2]);
			//	});
			//	unsigned int count (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemMapArrayAsync_t* args = (args_hipMemMapArrayAsync_t*) func_args;
			printf("\thipArrayMapInfo * mapInfoList = %p", args->mapInfoList);
			if (args->mapInfoList != NULL) {
				printf(" -> {\n");
				printf("\t\thipResourceType resourceType = %d\n", args->mapInfoList__ref.val.resourceType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1643:2) resource = {\n");
				printf("\t\t}\n");
				printf("\t\thipArraySparseSubresourceType subresourceType = %d\n", args->mapInfoList__ref.val.subresourceType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1648:2) subresource = {\n");
				printf("\t\t}\n");
				printf("\t\thipMemOperationType memOperationType = %d\n", args->mapInfoList__ref.val.memOperationType);
				printf("\t\thipMemHandleType memHandleType = %d\n", args->mapInfoList__ref.val.memHandleType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1667:2) memHandle = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned long long offset = %llu\n", args->mapInfoList__ref.val.offset);
				printf("\t\tunsigned int deviceBitMask = %u\n", args->mapInfoList__ref.val.deviceBitMask);
				printf("\t\tunsigned int flags = %u\n", args->mapInfoList__ref.val.flags);
				printf("\t\tunsigned int[2] reserved = %u\n", args->mapInfoList__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int count = %u\n", args->count);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyAsync
		case HIP_API_ID_hipMemcpyAsync : {
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyAsync_t* args = (args_hipMemcpyAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphKernelNodeSetAttribute
		case HIP_API_ID_hipGraphKernelNodeSetAttribute : {
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipLaunchAttributeID attr (enum hipLaunchAttributeID);
			//	const hipLaunchAttributeValue * value ({
			//		hipAccessPolicyWindow accessPolicyWindow ({
			//			void * base_ptr (void *);
			//			hipAccessProperty hitProp (enum hipAccessProperty);
			//			float hitRatio (float);
			//			hipAccessProperty missProp (enum hipAccessProperty);
			//			size_t num_bytes (unsigned long);
			//		});
			//		int cooperative (int);
			//		int priority (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphKernelNodeSetAttribute_t* args = (args_hipGraphKernelNodeSetAttribute_t*) func_args;
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\thipLaunchAttributeID attr = %d\n", args->attr);
			printf("\tconst hipLaunchAttributeValue * value = %p", args->value);
			if (args->value != NULL) {
				printf(" -> {\n");
				printf("\t\thipAccessPolicyWindow accessPolicyWindow = {\n");
				printf("\t\t\thipAccessProperty hitProp = %d\n", args->value__ref.val.accessPolicyWindow.hitProp);
				printf("\t\t\tfloat hitRatio = %f\n", args->value__ref.val.accessPolicyWindow.hitRatio);
				printf("\t\t\thipAccessProperty missProp = %d\n", args->value__ref.val.accessPolicyWindow.missProp);
				printf("\t\t\tsize_t num_bytes = %lu\n", args->value__ref.val.accessPolicyWindow.num_bytes);
				printf("\t\t}\n");
				printf("\t\tint cooperative = %d\n", args->value__ref.val.cooperative);
				printf("\t\tint priority = %d\n", args->value__ref.val.priority);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvMemcpy2DUnaligned
		case HIP_API_ID_hipDrvMemcpy2DUnaligned : {
			//	const hip_Memcpy2D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipDrvMemcpy2DUnaligned_t* args = (args_hipDrvMemcpy2DUnaligned_t*) func_args;
			printf("\tconst hip_Memcpy2D * pCopy = %p", args->pCopy);
			if (args->pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->pCopy__ref.val.srcY);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->pCopy__ref.val.srcPitch);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->pCopy__ref.val.dstY);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->pCopy__ref.val.dstPitch);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->pCopy__ref.val.Height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolDestroy
		case HIP_API_ID_hipMemPoolDestroy : {
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolDestroy_t* args = (args_hipMemPoolDestroy_t*) func_args;
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphRemoveDependencies
		case HIP_API_ID_hipGraphRemoveDependencies : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * from (const struct hipGraphNode * *);
			//	const hipGraphNode_t * to (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphRemoveDependencies_t* args = (args_hipGraphRemoveDependencies_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * from = %p", args->from);
			if (args->from != NULL) {
				printf(" -> %p\n", args->from__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t * to = %p", args->to);
			if (args->to != NULL) {
				printf(" -> %p\n", args->to__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphCreate
		case HIP_API_ID_hipGraphCreate : {
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphCreate_t* args = (args_hipGraphCreate_t*) func_args;
			printf("\thipGraph_t * pGraph = %p", args->pGraph);
			if (args->pGraph != NULL) {
				printf(" -> %p\n", args->pGraph__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtLaunchMultiKernelMultiDevice
		case HIP_API_ID_hipExtLaunchMultiKernelMultiDevice : {
			//	hipLaunchParams * launchParamsList ({
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** args (void **);
			//		size_t sharedMem (unsigned long);
			//		hipStream_t stream (struct ihipStream_t *);
			//	});
			//	int numDevices (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipExtLaunchMultiKernelMultiDevice_t* args = (args_hipExtLaunchMultiKernelMultiDevice_t*) func_args;
			printf("\thipLaunchParams * launchParamsList = %p", args->launchParamsList);
			if (args->launchParamsList != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->launchParamsList__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->launchParamsList__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->launchParamsList__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->launchParamsList__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->launchParamsList__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->launchParamsList__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tsize_t sharedMem = %lu\n", args->launchParamsList__ref.val.sharedMem);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint numDevices = %d\n", args->numDevices);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetDeviceCount
		case HIP_API_ID_hipGetDeviceCount : {
			//	int * count (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetDeviceCount_t* args = (args_hipGetDeviceCount_t*) func_args;
			printf("\tint * count = %p", args->count);
			if (args->count != NULL) {
				printf(" -> %d\n", args->count__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemUnmap
		case HIP_API_ID_hipMemUnmap : {
			//	void * ptr (void *);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemUnmap_t* args = (args_hipMemUnmap_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexObjectGetResourceDesc
		case HIP_API_ID_hipTexObjectGetResourceDesc : {
			//	HIP_RESOURCE_DESC * pResDesc ({
			//		HIPresourcetype resType (enum HIPresourcetype_enum);
			//		union (unnamed union at header/hip/hip.h:635:2) res ({
			//		});
			//		unsigned int flags (unsigned int);
			//	});
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipTexObjectGetResourceDesc_t* args = (args_hipTexObjectGetResourceDesc_t*) func_args;
			printf("\tHIP_RESOURCE_DESC * pResDesc = %p", args->pResDesc);
			if (args->pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourcetype resType = %d\n", args->pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:635:2) res = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->pResDesc__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t texObject = %p", args->texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecEventRecordNodeSetEvent
		case HIP_API_ID_hipGraphExecEventRecordNodeSetEvent : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecEventRecordNodeSetEvent_t* args = (args_hipGraphExecEventRecordNodeSetEvent_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipInit
		case HIP_API_ID_hipInit : {
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipInit_t* args = (args_hipInit_t*) func_args;
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipThreadExchangeStreamCaptureMode
		case HIP_API_ID_hipThreadExchangeStreamCaptureMode : {
			//	hipStreamCaptureMode * mode (enum hipStreamCaptureMode*);
			//	hipError_t retval (enum hipError_t);
			args_hipThreadExchangeStreamCaptureMode_t* args = (args_hipThreadExchangeStreamCaptureMode_t*) func_args;
			printf("\thipStreamCaptureMode * mode = %p", args->mode);
			if (args->mode != NULL) {
				printf(" -> %d\n", args->mode__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetP2PAttribute
		case HIP_API_ID_hipDeviceGetP2PAttribute : {
			//	int * value (int *);
			//	hipDeviceP2PAttr attr (enum hipDeviceP2PAttr);
			//	int srcDevice (int);
			//	int dstDevice (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetP2PAttribute_t* args = (args_hipDeviceGetP2PAttribute_t*) func_args;
			printf("\tint * value = %p", args->value);
			if (args->value != NULL) {
				printf(" -> %d\n", args->value__ref.val);
			} else { printf("\n"); };
			printf("\thipDeviceP2PAttr attr = %d\n", args->attr);
			printf("\tint srcDevice = %d\n", args->srcDevice);
			printf("\tint dstDevice = %d\n", args->dstDevice);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetByPCIBusId
		case HIP_API_ID_hipDeviceGetByPCIBusId : {
			//	int * device (int *);
			//	const char * pciBusId (const char *);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetByPCIBusId_t* args = (args_hipDeviceGetByPCIBusId_t*) func_args;
			printf("\tint * device = %p", args->device);
			if (args->device != NULL) {
				printf(" -> %d\n", args->device__ref.val);
			} else { printf("\n"); };
			printf("\tconst char * pciBusId = %p", args->pciBusId);
			if (args->pciBusId != NULL) {
				printf(" -> %s\n", args->pciBusId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostFree
		case HIP_API_ID_hipHostFree : {
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipHostFree_t* args = (args_hipHostFree_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtGetLinkTypeAndHopCount
		case HIP_API_ID_hipExtGetLinkTypeAndHopCount : {
			//	int device1 (int);
			//	int device2 (int);
			//	uint32_t * linktype (unsigned int*);
			//	uint32_t * hopcount (unsigned int*);
			//	hipError_t retval (enum hipError_t);
			args_hipExtGetLinkTypeAndHopCount_t* args = (args_hipExtGetLinkTypeAndHopCount_t*) func_args;
			printf("\tint device1 = %d\n", args->device1);
			printf("\tint device2 = %d\n", args->device2);
			printf("\tuint32_t * linktype = %p", args->linktype);
			if (args->linktype != NULL) {
				printf(" -> %u\n", args->linktype__ref.val);
			} else { printf("\n"); };
			printf("\tuint32_t * hopcount = %p", args->hopcount);
			if (args->hopcount != NULL) {
				printf(" -> %u\n", args->hopcount__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyToSymbolAsync_spt
		case HIP_API_ID_hipMemcpyToSymbolAsync_spt : {
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyToSymbolAsync_spt_t* args = (args_hipMemcpyToSymbolAsync_spt_t*) func_args;
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxDisablePeerAccess
		case HIP_API_ID_hipCtxDisablePeerAccess : {
			//	hipCtx_t peerCtx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxDisablePeerAccess_t* args = (args_hipCtxDisablePeerAccess_t*) func_args;
			printf("\thipCtx_t peerCtx = %p", args->peerCtx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipSetupArgument
		case HIP_API_ID_hipSetupArgument : {
			//	const void * arg (const void *);
			//	size_t size (unsigned long);
			//	size_t offset (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipSetupArgument_t* args = (args_hipSetupArgument_t*) func_args;
			printf("\tconst void * arg = %p", args->arg);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyAtoHAsync
		case HIP_API_ID_hipMemcpyAtoHAsync : {
			//	void * dstHost (void *);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t ByteCount (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyAtoHAsync_t* args = (args_hipMemcpyAtoHAsync_t*) func_args;
			printf("\tvoid * dstHost = %p", args->dstHost);
			printf("\n");
			printf("\thipArray_t srcArray = %p", args->srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->srcOffset);
			printf("\tsize_t ByteCount = %lu\n", args->ByteCount);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxSetCacheConfig
		case HIP_API_ID_hipCtxSetCacheConfig : {
			//	hipFuncCache_t cacheConfig (enum hipFuncCache_t);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxSetCacheConfig_t* args = (args_hipCtxSetCacheConfig_t*) func_args;
			printf("\thipFuncCache_t cacheConfig = %d\n", args->cacheConfig);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemRelease
		case HIP_API_ID_hipMemRelease : {
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemRelease_t* args = (args_hipMemRelease_t*) func_args;
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->handle);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipUnbindTexture
		case HIP_API_ID_hipUnbindTexture : {
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipUnbindTexture_t* args = (args_hipUnbindTexture_t*) func_args;
			printf("\tconst textureReference * tex = %p", args->tex);
			if (args->tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvMemcpy3DAsync
		case HIP_API_ID_hipDrvMemcpy3DAsync : {
			//	const HIP_MEMCPY3D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		size_t srcZ (unsigned long);
			//		size_t srcLOD (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t srcHeight (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		size_t dstZ (unsigned long);
			//		size_t dstLOD (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t dstHeight (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipDrvMemcpy3DAsync_t* args = (args_hipDrvMemcpy3DAsync_t*) func_args;
			printf("\tconst HIP_MEMCPY3D * pCopy = %p", args->pCopy);
			if (args->pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->pCopy__ref.val.srcY);
				printf("\t\tsize_t srcZ = %lu\n", args->pCopy__ref.val.srcZ);
				printf("\t\tsize_t srcLOD = %lu\n", args->pCopy__ref.val.srcLOD);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->pCopy__ref.val.srcPitch);
				printf("\t\tsize_t srcHeight = %lu\n", args->pCopy__ref.val.srcHeight);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->pCopy__ref.val.dstY);
				printf("\t\tsize_t dstZ = %lu\n", args->pCopy__ref.val.dstZ);
				printf("\t\tsize_t dstLOD = %lu\n", args->pCopy__ref.val.dstLOD);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->pCopy__ref.val.dstPitch);
				printf("\t\tsize_t dstHeight = %lu\n", args->pCopy__ref.val.dstHeight);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->pCopy__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->pCopy__ref.val.Depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipIpcGetEventHandle
		case HIP_API_ID_hipIpcGetEventHandle : {
			//	hipIpcEventHandle_t * handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipIpcGetEventHandle_t* args = (args_hipIpcGetEventHandle_t*) func_args;
			printf("\thipIpcEventHandle_t * handle = %p", args->handle);
			if (args->handle != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[64] reserved = %c\n", args->handle__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphReleaseUserObject
		case HIP_API_ID_hipGraphReleaseUserObject : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphReleaseUserObject_t* args = (args_hipGraphReleaseUserObject_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipUserObject_t object = %p", args->object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetMemPool
		case HIP_API_ID_hipDeviceGetMemPool : {
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetMemPool_t* args = (args_hipDeviceGetMemPool_t*) func_args;
			printf("\thipMemPool_t * mem_pool = %p", args->mem_pool);
			if (args->mem_pool != NULL) {
				printf(" -> %p\n", args->mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tint device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphHostNodeSetParams
		case HIP_API_ID_hipGraphHostNodeSetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphHostNodeSetParams_t* args = (args_hipGraphHostNodeSetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipHostNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddEventWaitNode
		case HIP_API_ID_hipGraphAddEventWaitNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddEventWaitNode_t* args = (args_hipGraphAddEventWaitNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DFromArrayAsync_spt
		case HIP_API_ID_hipMemcpy2DFromArrayAsync_spt : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffsetSrc (unsigned long);
			//	size_t hOffsetSrc (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DFromArrayAsync_spt_t* args = (args_hipMemcpy2DFromArrayAsync_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\thipArray_const_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t wOffsetSrc = %lu\n", args->wOffsetSrc);
			printf("\tsize_t hOffsetSrc = %lu\n", args->hOffsetSrc);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchHostFunc_spt
		case HIP_API_ID_hipLaunchHostFunc_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipHostFn_t fn (void (*)(void *));
			//	void * userData (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchHostFunc_spt_t* args = (args_hipLaunchHostFunc_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipHostFn_t fn = %p\n", args->fn);
			printf("\tvoid * userData = %p", args->userData);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamWaitEvent_spt
		case HIP_API_ID_hipStreamWaitEvent_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamWaitEvent_spt_t* args = (args_hipStreamWaitEvent_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipArrayGetDescriptor
		case HIP_API_ID_hipArrayGetDescriptor : {
			//	HIP_ARRAY_DESCRIPTOR * pArrayDescriptor ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//	});
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			args_hipArrayGetDescriptor_t* args = (args_hipArrayGetDescriptor_t*) func_args;
			printf("\tHIP_ARRAY_DESCRIPTOR * pArrayDescriptor = %p", args->pArrayDescriptor);
			if (args->pArrayDescriptor != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->pArrayDescriptor__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->pArrayDescriptor__ref.val.Height);
				printf("\t\tenum hipArray_Format Format = %d\n", args->pArrayDescriptor__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->pArrayDescriptor__ref.val.NumChannels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_t array = %p", args->array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecUpdate
		case HIP_API_ID_hipGraphExecUpdate : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraph_t hGraph (struct ihipGraph *);
			//	hipGraphNode_t * hErrorNode_out (struct hipGraphNode **);
			//	hipGraphExecUpdateResult * updateResult_out (enum hipGraphExecUpdateResult*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecUpdate_t* args = (args_hipGraphExecUpdate_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraph_t hGraph = %p", args->hGraph);
			printf("\n");
			printf("\thipGraphNode_t * hErrorNode_out = %p", args->hErrorNode_out);
			if (args->hErrorNode_out != NULL) {
				printf(" -> %p\n", args->hErrorNode_out__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphExecUpdateResult * updateResult_out = %p", args->updateResult_out);
			if (args->updateResult_out != NULL) {
				printf(" -> %d\n", args->updateResult_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemGetAllocationPropertiesFromHandle
		case HIP_API_ID_hipMemGetAllocationPropertiesFromHandle : {
			//	hipMemAllocationProp * prop ({
			//		hipMemAllocationType type (enum hipMemAllocationType);
			//		hipMemAllocationHandleType requestedHandleType (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32HandleMetaData (void *);
			//		struct (unnamed struct at header/hip/hip.h:1616:2) allocFlags ({
			//		});
			//	});
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemGetAllocationPropertiesFromHandle_t* args = (args_hipMemGetAllocationPropertiesFromHandle_t*) func_args;
			printf("\thipMemAllocationProp * prop = %p", args->prop);
			if (args->prop != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType type = %d\n", args->prop__ref.val.type);
				printf("\t\thipMemAllocationHandleType requestedHandleType = %d\n", args->prop__ref.val.requestedHandleType);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->prop__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->prop__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1616:2) allocFlags = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->handle);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyWithStream
		case HIP_API_ID_hipMemcpyWithStream : {
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyWithStream_t* args = (args_hipMemcpyWithStream_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddExternalSemaphoresWaitNode
		case HIP_API_ID_hipGraphAddExternalSemaphoresWaitNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipExternalSemaphoreWaitNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddExternalSemaphoresWaitNode_t* args = (args_hipGraphAddExternalSemaphoresWaitNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst hipExternalSemaphoreWaitNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyAtoH
		case HIP_API_ID_hipMemcpyAtoH : {
			//	void * dst (void *);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyAtoH_t* args = (args_hipMemcpyAtoH_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\thipArray_t srcArray = %p", args->srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->srcOffset);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamQuery
		case HIP_API_ID_hipStreamQuery : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamQuery_t* args = (args_hipStreamQuery_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipIpcCloseMemHandle
		case HIP_API_ID_hipIpcCloseMemHandle : {
			//	void * devPtr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipIpcCloseMemHandle_t* args = (args_hipIpcCloseMemHandle_t*) func_args;
			printf("\tvoid * devPtr = %p", args->devPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetAsync
		case HIP_API_ID_hipMemsetAsync : {
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetAsync_t* args = (args_hipMemsetAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyDtoD
		case HIP_API_ID_hipMemcpyDtoD : {
			//	hipDeviceptr_t dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyDtoD_t* args = (args_hipMemcpyDtoD_t*) func_args;
			printf("\thipDeviceptr_t dst = %p", args->dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleUnload
		case HIP_API_ID_hipModuleUnload : {
			//	hipModule_t module (struct ihipModule_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleUnload_t* args = (args_hipModuleUnload_t*) func_args;
			printf("\thipModule_t module = %p", args->module);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetDevicePropertiesR0600
		case HIP_API_ID_hipGetDevicePropertiesR0600 : {
			//	hipDeviceProp_tR0600 * prop ({
			//		char[256] name (char[256]);
			//		hipUUID uuid ({
			//			char[16] bytes (char[16]);
			//		});
			//		char[8] luid (char[8]);
			//		unsigned int luidDeviceNodeMask (unsigned int);
			//		size_t totalGlobalMem (unsigned long);
			//		size_t sharedMemPerBlock (unsigned long);
			//		int regsPerBlock (int);
			//		int warpSize (int);
			//		size_t memPitch (unsigned long);
			//		int maxThreadsPerBlock (int);
			//		int[3] maxThreadsDim (int[3]);
			//		int[3] maxGridSize (int[3]);
			//		int clockRate (int);
			//		size_t totalConstMem (unsigned long);
			//		int major (int);
			//		int minor (int);
			//		size_t textureAlignment (unsigned long);
			//		size_t texturePitchAlignment (unsigned long);
			//		int deviceOverlap (int);
			//		int multiProcessorCount (int);
			//		int kernelExecTimeoutEnabled (int);
			//		int integrated (int);
			//		int canMapHostMemory (int);
			//		int computeMode (int);
			//		int maxTexture1D (int);
			//		int maxTexture1DMipmap (int);
			//		int maxTexture1DLinear (int);
			//		int[2] maxTexture2D (int[2]);
			//		int[2] maxTexture2DMipmap (int[2]);
			//		int[3] maxTexture2DLinear (int[3]);
			//		int[2] maxTexture2DGather (int[2]);
			//		int[3] maxTexture3D (int[3]);
			//		int[3] maxTexture3DAlt (int[3]);
			//		int maxTextureCubemap (int);
			//		int[2] maxTexture1DLayered (int[2]);
			//		int[3] maxTexture2DLayered (int[3]);
			//		int[2] maxTextureCubemapLayered (int[2]);
			//		int maxSurface1D (int);
			//		int[2] maxSurface2D (int[2]);
			//		int[3] maxSurface3D (int[3]);
			//		int[2] maxSurface1DLayered (int[2]);
			//		int[3] maxSurface2DLayered (int[3]);
			//		int maxSurfaceCubemap (int);
			//		int[2] maxSurfaceCubemapLayered (int[2]);
			//		size_t surfaceAlignment (unsigned long);
			//		int concurrentKernels (int);
			//		int ECCEnabled (int);
			//		int pciBusID (int);
			//		int pciDeviceID (int);
			//		int pciDomainID (int);
			//		int tccDriver (int);
			//		int asyncEngineCount (int);
			//		int unifiedAddressing (int);
			//		int memoryClockRate (int);
			//		int memoryBusWidth (int);
			//		int l2CacheSize (int);
			//		int persistingL2CacheMaxSize (int);
			//		int maxThreadsPerMultiProcessor (int);
			//		int streamPrioritiesSupported (int);
			//		int globalL1CacheSupported (int);
			//		int localL1CacheSupported (int);
			//		size_t sharedMemPerMultiprocessor (unsigned long);
			//		int regsPerMultiprocessor (int);
			//		int managedMemory (int);
			//		int isMultiGpuBoard (int);
			//		int multiGpuBoardGroupID (int);
			//		int hostNativeAtomicSupported (int);
			//		int singleToDoublePrecisionPerfRatio (int);
			//		int pageableMemoryAccess (int);
			//		int concurrentManagedAccess (int);
			//		int computePreemptionSupported (int);
			//		int canUseHostPointerForRegisteredMem (int);
			//		int cooperativeLaunch (int);
			//		int cooperativeMultiDeviceLaunch (int);
			//		size_t sharedMemPerBlockOptin (unsigned long);
			//		int pageableMemoryAccessUsesHostPageTables (int);
			//		int directManagedMemAccessFromHost (int);
			//		int maxBlocksPerMultiProcessor (int);
			//		int accessPolicyMaxWindowSize (int);
			//		size_t reservedSharedMemPerBlock (unsigned long);
			//		int hostRegisterSupported (int);
			//		int sparseHipArraySupported (int);
			//		int hostRegisterReadOnlySupported (int);
			//		int timelineSemaphoreInteropSupported (int);
			//		int memoryPoolsSupported (int);
			//		int gpuDirectRDMASupported (int);
			//		unsigned int gpuDirectRDMAFlushWritesOptions (unsigned int);
			//		int gpuDirectRDMAWritesOrdering (int);
			//		unsigned int memoryPoolSupportedHandleTypes (unsigned int);
			//		int deferredMappingHipArraySupported (int);
			//		int ipcEventSupported (int);
			//		int clusterLaunch (int);
			//		int unifiedFunctionPointers (int);
			//		int[63] reserved (int[63]);
			//		int[32] hipReserved (int[32]);
			//		char[256] gcnArchName (char[256]);
			//		size_t maxSharedMemoryPerMultiProcessor (unsigned long);
			//		int clockInstructionRate (int);
			//		hipDeviceArch_t arch ({
			//			unsigned int hasGlobalInt32Atomics (unsigned int);
			//			unsigned int hasGlobalFloatAtomicExch (unsigned int);
			//			unsigned int hasSharedInt32Atomics (unsigned int);
			//			unsigned int hasSharedFloatAtomicExch (unsigned int);
			//			unsigned int hasFloatAtomicAdd (unsigned int);
			//			unsigned int hasGlobalInt64Atomics (unsigned int);
			//			unsigned int hasSharedInt64Atomics (unsigned int);
			//			unsigned int hasDoubles (unsigned int);
			//			unsigned int hasWarpVote (unsigned int);
			//			unsigned int hasWarpBallot (unsigned int);
			//			unsigned int hasWarpShuffle (unsigned int);
			//			unsigned int hasFunnelShift (unsigned int);
			//			unsigned int hasThreadFenceSystem (unsigned int);
			//			unsigned int hasSyncThreadsExt (unsigned int);
			//			unsigned int hasSurfaceFuncs (unsigned int);
			//			unsigned int has3dGrid (unsigned int);
			//			unsigned int hasDynamicParallelism (unsigned int);
			//		});
			//		int cooperativeMultiDeviceUnmatchedFunc (int);
			//		int cooperativeMultiDeviceUnmatchedGridDim (int);
			//		int cooperativeMultiDeviceUnmatchedBlockDim (int);
			//		int cooperativeMultiDeviceUnmatchedSharedMem (int);
			//		int isLargeBar (int);
			//		int asicRevision (int);
			//	});
			//	int deviceId (int);
			//	hipError_t retval (enum hipError_t);
			args_hipGetDevicePropertiesR0600_t* args = (args_hipGetDevicePropertiesR0600_t*) func_args;
			printf("\thipDeviceProp_tR0600 * prop = %p", args->prop);
			if (args->prop != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[256] name = %c\n", args->prop__ref.val.name[0]);
				printf("\t\thipUUID uuid = {\n");
				printf("\t\t\tchar[16] bytes = %c\n", args->prop__ref.val.uuid.bytes[0]);
				printf("\t\t}\n");
				printf("\t\tchar[8] luid = %c\n", args->prop__ref.val.luid[0]);
				printf("\t\tunsigned int luidDeviceNodeMask = %u\n", args->prop__ref.val.luidDeviceNodeMask);
				printf("\t\tsize_t totalGlobalMem = %lu\n", args->prop__ref.val.totalGlobalMem);
				printf("\t\tsize_t sharedMemPerBlock = %lu\n", args->prop__ref.val.sharedMemPerBlock);
				printf("\t\tint regsPerBlock = %d\n", args->prop__ref.val.regsPerBlock);
				printf("\t\tint warpSize = %d\n", args->prop__ref.val.warpSize);
				printf("\t\tsize_t memPitch = %lu\n", args->prop__ref.val.memPitch);
				printf("\t\tint maxThreadsPerBlock = %d\n", args->prop__ref.val.maxThreadsPerBlock);
				printf("\t\tint[3] maxThreadsDim = %d\n", args->prop__ref.val.maxThreadsDim[0]);
				printf("\t\tint[3] maxGridSize = %d\n", args->prop__ref.val.maxGridSize[0]);
				printf("\t\tint clockRate = %d\n", args->prop__ref.val.clockRate);
				printf("\t\tsize_t totalConstMem = %lu\n", args->prop__ref.val.totalConstMem);
				printf("\t\tint major = %d\n", args->prop__ref.val.major);
				printf("\t\tint minor = %d\n", args->prop__ref.val.minor);
				printf("\t\tsize_t textureAlignment = %lu\n", args->prop__ref.val.textureAlignment);
				printf("\t\tsize_t texturePitchAlignment = %lu\n", args->prop__ref.val.texturePitchAlignment);
				printf("\t\tint deviceOverlap = %d\n", args->prop__ref.val.deviceOverlap);
				printf("\t\tint multiProcessorCount = %d\n", args->prop__ref.val.multiProcessorCount);
				printf("\t\tint kernelExecTimeoutEnabled = %d\n", args->prop__ref.val.kernelExecTimeoutEnabled);
				printf("\t\tint integrated = %d\n", args->prop__ref.val.integrated);
				printf("\t\tint canMapHostMemory = %d\n", args->prop__ref.val.canMapHostMemory);
				printf("\t\tint computeMode = %d\n", args->prop__ref.val.computeMode);
				printf("\t\tint maxTexture1D = %d\n", args->prop__ref.val.maxTexture1D);
				printf("\t\tint maxTexture1DMipmap = %d\n", args->prop__ref.val.maxTexture1DMipmap);
				printf("\t\tint maxTexture1DLinear = %d\n", args->prop__ref.val.maxTexture1DLinear);
				printf("\t\tint[2] maxTexture2D = %d\n", args->prop__ref.val.maxTexture2D[0]);
				printf("\t\tint[2] maxTexture2DMipmap = %d\n", args->prop__ref.val.maxTexture2DMipmap[0]);
				printf("\t\tint[3] maxTexture2DLinear = %d\n", args->prop__ref.val.maxTexture2DLinear[0]);
				printf("\t\tint[2] maxTexture2DGather = %d\n", args->prop__ref.val.maxTexture2DGather[0]);
				printf("\t\tint[3] maxTexture3D = %d\n", args->prop__ref.val.maxTexture3D[0]);
				printf("\t\tint[3] maxTexture3DAlt = %d\n", args->prop__ref.val.maxTexture3DAlt[0]);
				printf("\t\tint maxTextureCubemap = %d\n", args->prop__ref.val.maxTextureCubemap);
				printf("\t\tint[2] maxTexture1DLayered = %d\n", args->prop__ref.val.maxTexture1DLayered[0]);
				printf("\t\tint[3] maxTexture2DLayered = %d\n", args->prop__ref.val.maxTexture2DLayered[0]);
				printf("\t\tint[2] maxTextureCubemapLayered = %d\n", args->prop__ref.val.maxTextureCubemapLayered[0]);
				printf("\t\tint maxSurface1D = %d\n", args->prop__ref.val.maxSurface1D);
				printf("\t\tint[2] maxSurface2D = %d\n", args->prop__ref.val.maxSurface2D[0]);
				printf("\t\tint[3] maxSurface3D = %d\n", args->prop__ref.val.maxSurface3D[0]);
				printf("\t\tint[2] maxSurface1DLayered = %d\n", args->prop__ref.val.maxSurface1DLayered[0]);
				printf("\t\tint[3] maxSurface2DLayered = %d\n", args->prop__ref.val.maxSurface2DLayered[0]);
				printf("\t\tint maxSurfaceCubemap = %d\n", args->prop__ref.val.maxSurfaceCubemap);
				printf("\t\tint[2] maxSurfaceCubemapLayered = %d\n", args->prop__ref.val.maxSurfaceCubemapLayered[0]);
				printf("\t\tsize_t surfaceAlignment = %lu\n", args->prop__ref.val.surfaceAlignment);
				printf("\t\tint concurrentKernels = %d\n", args->prop__ref.val.concurrentKernels);
				printf("\t\tint ECCEnabled = %d\n", args->prop__ref.val.ECCEnabled);
				printf("\t\tint pciBusID = %d\n", args->prop__ref.val.pciBusID);
				printf("\t\tint pciDeviceID = %d\n", args->prop__ref.val.pciDeviceID);
				printf("\t\tint pciDomainID = %d\n", args->prop__ref.val.pciDomainID);
				printf("\t\tint tccDriver = %d\n", args->prop__ref.val.tccDriver);
				printf("\t\tint asyncEngineCount = %d\n", args->prop__ref.val.asyncEngineCount);
				printf("\t\tint unifiedAddressing = %d\n", args->prop__ref.val.unifiedAddressing);
				printf("\t\tint memoryClockRate = %d\n", args->prop__ref.val.memoryClockRate);
				printf("\t\tint memoryBusWidth = %d\n", args->prop__ref.val.memoryBusWidth);
				printf("\t\tint l2CacheSize = %d\n", args->prop__ref.val.l2CacheSize);
				printf("\t\tint persistingL2CacheMaxSize = %d\n", args->prop__ref.val.persistingL2CacheMaxSize);
				printf("\t\tint maxThreadsPerMultiProcessor = %d\n", args->prop__ref.val.maxThreadsPerMultiProcessor);
				printf("\t\tint streamPrioritiesSupported = %d\n", args->prop__ref.val.streamPrioritiesSupported);
				printf("\t\tint globalL1CacheSupported = %d\n", args->prop__ref.val.globalL1CacheSupported);
				printf("\t\tint localL1CacheSupported = %d\n", args->prop__ref.val.localL1CacheSupported);
				printf("\t\tsize_t sharedMemPerMultiprocessor = %lu\n", args->prop__ref.val.sharedMemPerMultiprocessor);
				printf("\t\tint regsPerMultiprocessor = %d\n", args->prop__ref.val.regsPerMultiprocessor);
				printf("\t\tint managedMemory = %d\n", args->prop__ref.val.managedMemory);
				printf("\t\tint isMultiGpuBoard = %d\n", args->prop__ref.val.isMultiGpuBoard);
				printf("\t\tint multiGpuBoardGroupID = %d\n", args->prop__ref.val.multiGpuBoardGroupID);
				printf("\t\tint hostNativeAtomicSupported = %d\n", args->prop__ref.val.hostNativeAtomicSupported);
				printf("\t\tint singleToDoublePrecisionPerfRatio = %d\n", args->prop__ref.val.singleToDoublePrecisionPerfRatio);
				printf("\t\tint pageableMemoryAccess = %d\n", args->prop__ref.val.pageableMemoryAccess);
				printf("\t\tint concurrentManagedAccess = %d\n", args->prop__ref.val.concurrentManagedAccess);
				printf("\t\tint computePreemptionSupported = %d\n", args->prop__ref.val.computePreemptionSupported);
				printf("\t\tint canUseHostPointerForRegisteredMem = %d\n", args->prop__ref.val.canUseHostPointerForRegisteredMem);
				printf("\t\tint cooperativeLaunch = %d\n", args->prop__ref.val.cooperativeLaunch);
				printf("\t\tint cooperativeMultiDeviceLaunch = %d\n", args->prop__ref.val.cooperativeMultiDeviceLaunch);
				printf("\t\tsize_t sharedMemPerBlockOptin = %lu\n", args->prop__ref.val.sharedMemPerBlockOptin);
				printf("\t\tint pageableMemoryAccessUsesHostPageTables = %d\n", args->prop__ref.val.pageableMemoryAccessUsesHostPageTables);
				printf("\t\tint directManagedMemAccessFromHost = %d\n", args->prop__ref.val.directManagedMemAccessFromHost);
				printf("\t\tint maxBlocksPerMultiProcessor = %d\n", args->prop__ref.val.maxBlocksPerMultiProcessor);
				printf("\t\tint accessPolicyMaxWindowSize = %d\n", args->prop__ref.val.accessPolicyMaxWindowSize);
				printf("\t\tsize_t reservedSharedMemPerBlock = %lu\n", args->prop__ref.val.reservedSharedMemPerBlock);
				printf("\t\tint hostRegisterSupported = %d\n", args->prop__ref.val.hostRegisterSupported);
				printf("\t\tint sparseHipArraySupported = %d\n", args->prop__ref.val.sparseHipArraySupported);
				printf("\t\tint hostRegisterReadOnlySupported = %d\n", args->prop__ref.val.hostRegisterReadOnlySupported);
				printf("\t\tint timelineSemaphoreInteropSupported = %d\n", args->prop__ref.val.timelineSemaphoreInteropSupported);
				printf("\t\tint memoryPoolsSupported = %d\n", args->prop__ref.val.memoryPoolsSupported);
				printf("\t\tint gpuDirectRDMASupported = %d\n", args->prop__ref.val.gpuDirectRDMASupported);
				printf("\t\tunsigned int gpuDirectRDMAFlushWritesOptions = %u\n", args->prop__ref.val.gpuDirectRDMAFlushWritesOptions);
				printf("\t\tint gpuDirectRDMAWritesOrdering = %d\n", args->prop__ref.val.gpuDirectRDMAWritesOrdering);
				printf("\t\tunsigned int memoryPoolSupportedHandleTypes = %u\n", args->prop__ref.val.memoryPoolSupportedHandleTypes);
				printf("\t\tint deferredMappingHipArraySupported = %d\n", args->prop__ref.val.deferredMappingHipArraySupported);
				printf("\t\tint ipcEventSupported = %d\n", args->prop__ref.val.ipcEventSupported);
				printf("\t\tint clusterLaunch = %d\n", args->prop__ref.val.clusterLaunch);
				printf("\t\tint unifiedFunctionPointers = %d\n", args->prop__ref.val.unifiedFunctionPointers);
				printf("\t\tint[63] reserved = %d\n", args->prop__ref.val.reserved[0]);
				printf("\t\tint[32] hipReserved = %d\n", args->prop__ref.val.hipReserved[0]);
				printf("\t\tchar[256] gcnArchName = %c\n", args->prop__ref.val.gcnArchName[0]);
				printf("\t\tsize_t maxSharedMemoryPerMultiProcessor = %lu\n", args->prop__ref.val.maxSharedMemoryPerMultiProcessor);
				printf("\t\tint clockInstructionRate = %d\n", args->prop__ref.val.clockInstructionRate);
				printf("\t\thipDeviceArch_t arch = {\n");
				printf("\t\t\tunsigned int hasGlobalInt32Atomics = %u\n", args->prop__ref.val.arch.hasGlobalInt32Atomics);
				printf("\t\t\tunsigned int hasGlobalFloatAtomicExch = %u\n", args->prop__ref.val.arch.hasGlobalFloatAtomicExch);
				printf("\t\t\tunsigned int hasSharedInt32Atomics = %u\n", args->prop__ref.val.arch.hasSharedInt32Atomics);
				printf("\t\t\tunsigned int hasSharedFloatAtomicExch = %u\n", args->prop__ref.val.arch.hasSharedFloatAtomicExch);
				printf("\t\t\tunsigned int hasFloatAtomicAdd = %u\n", args->prop__ref.val.arch.hasFloatAtomicAdd);
				printf("\t\t\tunsigned int hasGlobalInt64Atomics = %u\n", args->prop__ref.val.arch.hasGlobalInt64Atomics);
				printf("\t\t\tunsigned int hasSharedInt64Atomics = %u\n", args->prop__ref.val.arch.hasSharedInt64Atomics);
				printf("\t\t\tunsigned int hasDoubles = %u\n", args->prop__ref.val.arch.hasDoubles);
				printf("\t\t\tunsigned int hasWarpVote = %u\n", args->prop__ref.val.arch.hasWarpVote);
				printf("\t\t\tunsigned int hasWarpBallot = %u\n", args->prop__ref.val.arch.hasWarpBallot);
				printf("\t\t\tunsigned int hasWarpShuffle = %u\n", args->prop__ref.val.arch.hasWarpShuffle);
				printf("\t\t\tunsigned int hasFunnelShift = %u\n", args->prop__ref.val.arch.hasFunnelShift);
				printf("\t\t\tunsigned int hasThreadFenceSystem = %u\n", args->prop__ref.val.arch.hasThreadFenceSystem);
				printf("\t\t\tunsigned int hasSyncThreadsExt = %u\n", args->prop__ref.val.arch.hasSyncThreadsExt);
				printf("\t\t\tunsigned int hasSurfaceFuncs = %u\n", args->prop__ref.val.arch.hasSurfaceFuncs);
				printf("\t\t\tunsigned int has3dGrid = %u\n", args->prop__ref.val.arch.has3dGrid);
				printf("\t\t\tunsigned int hasDynamicParallelism = %u\n", args->prop__ref.val.arch.hasDynamicParallelism);
				printf("\t\t}\n");
				printf("\t\tint cooperativeMultiDeviceUnmatchedFunc = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedFunc);
				printf("\t\tint cooperativeMultiDeviceUnmatchedGridDim = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedGridDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedBlockDim = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedBlockDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedSharedMem = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedSharedMem);
				printf("\t\tint isLargeBar = %d\n", args->prop__ref.val.isLargeBar);
				printf("\t\tint asicRevision = %d\n", args->prop__ref.val.asicRevision);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint deviceId = %d\n", args->deviceId);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyFromArray
		case HIP_API_ID_hipMemcpyFromArray : {
			//	void * dst (void *);
			//	hipArray_const_t srcArray (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyFromArray_t* args = (args_hipMemcpyFromArray_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\thipArray_const_t srcArray = %p", args->srcArray);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceCanAccessPeer
		case HIP_API_ID_hipDeviceCanAccessPeer : {
			//	int * canAccessPeer (int *);
			//	int deviceId (int);
			//	int peerDeviceId (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceCanAccessPeer_t* args = (args_hipDeviceCanAccessPeer_t*) func_args;
			printf("\tint * canAccessPeer = %p", args->canAccessPeer);
			if (args->canAccessPeer != NULL) {
				printf(" -> %d\n", args->canAccessPeer__ref.val);
			} else { printf("\n"); };
			printf("\tint deviceId = %d\n", args->deviceId);
			printf("\tint peerDeviceId = %d\n", args->peerDeviceId);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemSetAccess
		case HIP_API_ID_hipMemSetAccess : {
			//	void * ptr (void *);
			//	size_t size (unsigned long);
			//	const hipMemAccessDesc * desc ({
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		hipMemAccessFlags flags (enum hipMemAccessFlags);
			//	});
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemSetAccess_t* args = (args_hipMemSetAccess_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tconst hipMemAccessDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->desc__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->desc__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\thipMemAccessFlags flags = %d\n", args->desc__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamWaitValue32
		case HIP_API_ID_hipStreamWaitValue32 : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint32_t value (unsigned int);
			//	unsigned int flags (unsigned int);
			//	uint32_t mask (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamWaitValue32_t* args = (args_hipStreamWaitValue32_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tuint32_t value = %u\n", args->value);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\tuint32_t mask = %u\n", args->mask);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipApiName
		case HIP_API_ID_hipApiName : {
			//	uint32_t id (unsigned int);
			//	const char * retval (const char *);
			args_hipApiName_t* args = (args_hipApiName_t*) func_args;
			printf("\tuint32_t id = %u\n", args->id);
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipGraphicsSubResourceGetMappedArray
		case HIP_API_ID_hipGraphicsSubResourceGetMappedArray : {
			//	hipArray_t * array (struct hipArray **);
			//	hipGraphicsResource_t resource (struct _hipGraphicsResource*);
			//	unsigned int arrayIndex (unsigned int);
			//	unsigned int mipLevel (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphicsSubResourceGetMappedArray_t* args = (args_hipGraphicsSubResourceGetMappedArray_t*) func_args;
			printf("\thipArray_t * array = %p", args->array);
			if (args->array != NULL) {
				printf(" -> %p\n", args->array__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphicsResource_t resource = %p", args->resource);
			printf("\n");
			printf("\tunsigned int arrayIndex = %u\n", args->arrayIndex);
			printf("\tunsigned int mipLevel = %u\n", args->mipLevel);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DToArrayAsync
		case HIP_API_ID_hipMemcpy2DToArrayAsync : {
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DToArrayAsync_t* args = (args_hipMemcpy2DToArrayAsync_t*) func_args;
			printf("\thipArray_t dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphDestroy
		case HIP_API_ID_hipGraphDestroy : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphDestroy_t* args = (args_hipGraphDestroy_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetBorderColor
		case HIP_API_ID_hipTexRefGetBorderColor : {
			//	float * pBorderColor (float *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetBorderColor_t* args = (args_hipTexRefGetBorderColor_t*) func_args;
			printf("\tfloat * pBorderColor = %p", args->pBorderColor);
			if (args->pBorderColor != NULL) {
				printf(" -> %f\n", args->pBorderColor__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemcpyNode1D
		case HIP_API_ID_hipGraphAddMemcpyNode1D : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemcpyNode1D_t* args = (args_hipGraphAddMemcpyNode1D_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphGetNodes
		case HIP_API_ID_hipGraphGetNodes : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * nodes (struct hipGraphNode **);
			//	size_t * numNodes (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphGetNodes_t* args = (args_hipGraphGetNodes_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipGraphNode_t * nodes = %p", args->nodes);
			if (args->nodes != NULL) {
				printf(" -> %p\n", args->nodes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * numNodes = %p", args->numNodes);
			if (args->numNodes != NULL) {
				printf(" -> %lu\n", args->numNodes__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetFlags_spt
		case HIP_API_ID_hipStreamGetFlags_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetFlags_spt_t* args = (args_hipStreamGetFlags_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tunsigned int * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %u\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetAddress2D
		case HIP_API_ID_hipTexRefSetAddress2D : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const HIP_ARRAY_DESCRIPTOR * desc ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//	});
			//	hipDeviceptr_t dptr (void *);
			//	size_t Pitch (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetAddress2D_t* args = (args_hipTexRefSetAddress2D_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst HIP_ARRAY_DESCRIPTOR * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->desc__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->desc__ref.val.Height);
				printf("\t\tenum hipArray_Format Format = %d\n", args->desc__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->desc__ref.val.NumChannels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipDeviceptr_t dptr = %p", args->dptr);
			printf("\n");
			printf("\tsize_t Pitch = %lu\n", args->Pitch);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetPriority
		case HIP_API_ID_hipStreamGetPriority : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	int * priority (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetPriority_t* args = (args_hipStreamGetPriority_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tint * priority = %p", args->priority);
			if (args->priority != NULL) {
				printf(" -> %d\n", args->priority__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamCreate
		case HIP_API_ID_hipStreamCreate : {
			//	hipStream_t * stream (struct ihipStream_t **);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamCreate_t* args = (args_hipStreamCreate_t*) func_args;
			printf("\thipStream_t * stream = %p", args->stream);
			if (args->stream != NULL) {
				printf(" -> %p\n", args->stream__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyFromSymbol
		case HIP_API_ID_hipMemcpyFromSymbol : {
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyFromSymbol_t* args = (args_hipMemcpyFromSymbol_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphNodeGetEnabled
		case HIP_API_ID_hipGraphNodeGetEnabled : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	unsigned int * isEnabled (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphNodeGetEnabled_t* args = (args_hipGraphNodeGetEnabled_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\tunsigned int * isEnabled = %p", args->isEnabled);
			if (args->isEnabled != NULL) {
				printf(" -> %u\n", args->isEnabled__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCreateChannelDesc
		case HIP_API_ID_hipCreateChannelDesc : {
			//	int x (int);
			//	int y (int);
			//	int z (int);
			//	int w (int);
			//	enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	struct hipChannelFormatDesc retval ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			args_hipCreateChannelDesc_t* args = (args_hipCreateChannelDesc_t*) func_args;
			printf("\tint x = %d\n", args->x);
			printf("\tint y = %d\n", args->y);
			printf("\tint z = %d\n", args->z);
			printf("\tint w = %d\n", args->w);
			printf("\tenum hipChannelFormatKind f = %d\n", args->f);
			printf("\tstruct hipChannelFormatDesc retval = {\n");
			printf("\t\tint x = %d\n", args->retval.x);
			printf("\t\tint y = %d\n", args->retval.y);
			printf("\t\tint z = %d\n", args->retval.z);
			printf("\t\tint w = %d\n", args->retval.w);
			printf("\t\tenum hipChannelFormatKind f = %d\n", args->retval.f);
			printf("\t}\n");
			break;

		}
		#endif
		#if HAVE_hipFreeMipmappedArray
		case HIP_API_ID_hipFreeMipmappedArray : {
			//	hipMipmappedArray_t mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipFreeMipmappedArray_t* args = (args_hipFreeMipmappedArray_t*) func_args;
			printf("\thipMipmappedArray_t mipmappedArray = %p", args->mipmappedArray);
			if (args->mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetTextureAlignmentOffset
		case HIP_API_ID_hipGetTextureAlignmentOffset : {
			//	size_t * offset (unsigned long*);
			//	const textureReference * texref ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGetTextureAlignmentOffset_t* args = (args_hipGetTextureAlignmentOffset_t*) func_args;
			printf("\tsize_t * offset = %p", args->offset);
			if (args->offset != NULL) {
				printf(" -> %lu\n", args->offset__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texref = %p", args->texref);
			if (args->texref != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texref__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texref__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texref__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texref__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texref__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texref__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texref__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texref__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texref__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texref__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texref__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texref__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texref__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texref__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texref__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texref__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texref__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddEventRecordNode
		case HIP_API_ID_hipGraphAddEventRecordNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddEventRecordNode_t* args = (args_hipGraphAddEventRecordNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphNodeFindInClone
		case HIP_API_ID_hipGraphNodeFindInClone : {
			//	hipGraphNode_t * pNode (struct hipGraphNode **);
			//	hipGraphNode_t originalNode (struct hipGraphNode *);
			//	hipGraph_t clonedGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphNodeFindInClone_t* args = (args_hipGraphNodeFindInClone_t*) func_args;
			printf("\thipGraphNode_t * pNode = %p", args->pNode);
			if (args->pNode != NULL) {
				printf(" -> %p\n", args->pNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphNode_t originalNode = %p", args->originalNode);
			printf("\n");
			printf("\thipGraph_t clonedGraph = %p", args->clonedGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyFromSymbol_spt
		case HIP_API_ID_hipMemcpyFromSymbol_spt : {
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyFromSymbol_spt_t* args = (args_hipMemcpyFromSymbol_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset3DAsync_spt
		case HIP_API_ID_hipMemset3DAsync_spt : {
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset3DAsync_spt_t* args = (args_hipMemset3DAsync_spt_t*) func_args;
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetD16Async
		case HIP_API_ID_hipMemsetD16Async : {
			//	hipDeviceptr_t dest (void *);
			//	unsigned short value (unsigned short);
			//	size_t count (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetD16Async_t* args = (args_hipMemsetD16Async_t*) func_args;
			printf("\thipDeviceptr_t dest = %p", args->dest);
			printf("\n");
			printf("\tunsigned short value = %hu\n", args->value);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetCacheConfig
		case HIP_API_ID_hipDeviceGetCacheConfig : {
			//	hipFuncCache_t * cacheConfig (enum hipFuncCache_t*);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetCacheConfig_t* args = (args_hipDeviceGetCacheConfig_t*) func_args;
			printf("\thipFuncCache_t * cacheConfig = %p", args->cacheConfig);
			if (args->cacheConfig != NULL) {
				printf(" -> %d\n", args->cacheConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemCreate
		case HIP_API_ID_hipMemCreate : {
			//	hipMemGenericAllocationHandle_t * handle (struct ihipMemGenericAllocationHandle **);
			//	size_t size (unsigned long);
			//	const hipMemAllocationProp * prop ({
			//		hipMemAllocationType type (enum hipMemAllocationType);
			//		hipMemAllocationHandleType requestedHandleType (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32HandleMetaData (void *);
			//		struct (unnamed struct at header/hip/hip.h:1616:2) allocFlags ({
			//		});
			//	});
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemCreate_t* args = (args_hipMemCreate_t*) func_args;
			printf("\thipMemGenericAllocationHandle_t * handle = %p", args->handle);
			if (args->handle != NULL) {
				printf(" -> %p\n", args->handle__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tconst hipMemAllocationProp * prop = %p", args->prop);
			if (args->prop != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType type = %d\n", args->prop__ref.val.type);
				printf("\t\thipMemAllocationHandleType requestedHandleType = %d\n", args->prop__ref.val.requestedHandleType);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->prop__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->prop__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1616:2) allocFlags = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned long long flags = %llu\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExternalSemaphoresWaitNodeGetParams
		case HIP_API_ID_hipGraphExternalSemaphoresWaitNodeGetParams : {
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipExternalSemaphoreWaitNodeParams * params_out ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExternalSemaphoresWaitNodeGetParams_t* args = (args_hipGraphExternalSemaphoresWaitNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\thipExternalSemaphoreWaitNodeParams * params_out = %p", args->params_out);
			if (args->params_out != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->params_out__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamEndCapture
		case HIP_API_ID_hipStreamEndCapture : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamEndCapture_t* args = (args_hipStreamEndCapture_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipGraph_t * pGraph = %p", args->pGraph);
			if (args->pGraph != NULL) {
				printf(" -> %p\n", args->pGraph__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyFromSymbolAsync_spt
		case HIP_API_ID_hipMemcpyFromSymbolAsync_spt : {
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyFromSymbolAsync_spt_t* args = (args_hipMemcpyFromSymbolAsync_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyHtoA
		case HIP_API_ID_hipMemcpyHtoA : {
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	const void * srcHost (const void *);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyHtoA_t* args = (args_hipMemcpyHtoA_t*) func_args;
			printf("\thipArray_t dstArray = %p", args->dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->dstOffset);
			printf("\tconst void * srcHost = %p", args->srcHost);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecHostNodeSetParams
		case HIP_API_ID_hipGraphExecHostNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecHostNodeSetParams_t* args = (args_hipGraphExecHostNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipHostNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMalloc
		case HIP_API_ID_hipMalloc : {
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMalloc_t* args = (args_hipMalloc_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMalloc3DArray
		case HIP_API_ID_hipMalloc3DArray : {
			//	hipArray_t * array (struct hipArray **);
			//	const struct hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	struct hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMalloc3DArray_t* args = (args_hipMalloc3DArray_t*) func_args;
			printf("\thipArray_t * array = %p", args->array);
			if (args->array != NULL) {
				printf(" -> %p\n", args->array__ref.val);
			} else { printf("\n"); };
			printf("\tconst struct hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tstruct hipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecKernelNodeSetParams
		case HIP_API_ID_hipGraphExecKernelNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecKernelNodeSetParams_t* args = (args_hipGraphExecKernelNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipKernelNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetTextureObjectResourceDesc
		case HIP_API_ID_hipGetTextureObjectResourceDesc : {
			//	hipResourceDesc * pResDesc ({
			//		enum hipResourceType resType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:612:2) res ({
			//		});
			//	});
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetTextureObjectResourceDesc_t* args = (args_hipGetTextureObjectResourceDesc_t*) func_args;
			printf("\thipResourceDesc * pResDesc = %p", args->pResDesc);
			if (args->pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceType resType = %d\n", args->pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:612:2) res = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t textureObject = %p", args->textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE___hipPushCallConfiguration
		case HIP_API_ID___hipPushCallConfiguration : {
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	size_t sharedMem (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args___hipPushCallConfiguration_t* args = (args___hipPushCallConfiguration_t*) func_args;
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->blockDim.x);
			printf("\t\tuint32_t y = %u\n", args->blockDim.y);
			printf("\t\tuint32_t z = %u\n", args->blockDim.z);
			printf("\t}\n");
			printf("\tsize_t sharedMem = %lu\n", args->sharedMem);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy3DAsync_spt
		case HIP_API_ID_hipMemcpy3DAsync_spt : {
			//	const hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy3DAsync_spt_t* args = (args_hipMemcpy3DAsync_spt_t*) func_args;
			printf("\tconst hipMemcpy3DParms * p = %p", args->p);
			if (args->p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetD8Async
		case HIP_API_ID_hipMemsetD8Async : {
			//	hipDeviceptr_t dest (void *);
			//	unsigned char value (unsigned char);
			//	size_t count (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetD8Async_t* args = (args_hipMemsetD8Async_t*) func_args;
			printf("\thipDeviceptr_t dest = %p", args->dest);
			printf("\n");
			printf("\tunsigned char value = %hhu\n", args->value);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamAddCallback
		case HIP_API_ID_hipStreamAddCallback : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCallback_t callback (void (*)(struct ihipStream_t *, enum hipError_t, void *));
			//	void * userData (void *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamAddCallback_t* args = (args_hipStreamAddCallback_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCallback_t callback = %p\n", args->callback);
			printf("\tvoid * userData = %p", args->userData);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolImportPointer
		case HIP_API_ID_hipMemPoolImportPointer : {
			//	void ** dev_ptr (void **);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemPoolPtrExportData * export_data ({
			//		unsigned char[64] reserved (unsigned char[64]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolImportPointer_t* args = (args_hipMemPoolImportPointer_t*) func_args;
			printf("\tvoid ** dev_ptr = %p", args->dev_ptr);
			if (args->dev_ptr != NULL) {
				printf("-> %p", args->dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipMemPoolPtrExportData * export_data = %p", args->export_data);
			if (args->export_data != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned char[64] reserved = %hhu\n", args->export_data__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFuncGetAttributes
		case HIP_API_ID_hipFuncGetAttributes : {
			//	struct hipFuncAttributes * attr ({
			//		int binaryVersion (int);
			//		int cacheModeCA (int);
			//		size_t constSizeBytes (unsigned long);
			//		size_t localSizeBytes (unsigned long);
			//		int maxDynamicSharedSizeBytes (int);
			//		int maxThreadsPerBlock (int);
			//		int numRegs (int);
			//		int preferredShmemCarveout (int);
			//		int ptxVersion (int);
			//		size_t sharedSizeBytes (unsigned long);
			//	});
			//	const void * func (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipFuncGetAttributes_t* args = (args_hipFuncGetAttributes_t*) func_args;
			printf("\tstruct hipFuncAttributes * attr = %p", args->attr);
			if (args->attr != NULL) {
				printf(" -> {\n");
				printf("\t\tint binaryVersion = %d\n", args->attr__ref.val.binaryVersion);
				printf("\t\tint cacheModeCA = %d\n", args->attr__ref.val.cacheModeCA);
				printf("\t\tsize_t constSizeBytes = %lu\n", args->attr__ref.val.constSizeBytes);
				printf("\t\tsize_t localSizeBytes = %lu\n", args->attr__ref.val.localSizeBytes);
				printf("\t\tint maxDynamicSharedSizeBytes = %d\n", args->attr__ref.val.maxDynamicSharedSizeBytes);
				printf("\t\tint maxThreadsPerBlock = %d\n", args->attr__ref.val.maxThreadsPerBlock);
				printf("\t\tint numRegs = %d\n", args->attr__ref.val.numRegs);
				printf("\t\tint preferredShmemCarveout = %d\n", args->attr__ref.val.preferredShmemCarveout);
				printf("\t\tint ptxVersion = %d\n", args->attr__ref.val.ptxVersion);
				printf("\t\tsize_t sharedSizeBytes = %lu\n", args->attr__ref.val.sharedSizeBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * func = %p", args->func);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxGetCurrent
		case HIP_API_ID_hipCtxGetCurrent : {
			//	hipCtx_t * ctx (struct ihipCtx_t **);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxGetCurrent_t* args = (args_hipCtxGetCurrent_t*) func_args;
			printf("\thipCtx_t * ctx = %p", args->ctx);
			if (args->ctx != NULL) {
				printf(" -> %p\n", args->ctx__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddChildGraphNode
		case HIP_API_ID_hipGraphAddChildGraphNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipGraph_t childGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddChildGraphNode_t* args = (args_hipGraphAddChildGraphNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipGraph_t childGraph = %p", args->childGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventCreate
		case HIP_API_ID_hipEventCreate : {
			//	hipEvent_t * event (struct ihipEvent_t **);
			//	hipError_t retval (enum hipError_t);
			args_hipEventCreate_t* args = (args_hipEventCreate_t*) func_args;
			printf("\thipEvent_t * event = %p", args->event);
			if (args->event != NULL) {
				printf(" -> %p\n", args->event__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostGetDevicePointer
		case HIP_API_ID_hipHostGetDevicePointer : {
			//	void ** devPtr (void **);
			//	void * hstPtr (void *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipHostGetDevicePointer_t* args = (args_hipHostGetDevicePointer_t*) func_args;
			printf("\tvoid ** devPtr = %p", args->devPtr);
			if (args->devPtr != NULL) {
				printf("-> %p", args->devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tvoid * hstPtr = %p", args->hstPtr);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventQuery
		case HIP_API_ID_hipEventQuery : {
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipEventQuery_t* args = (args_hipEventQuery_t*) func_args;
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyPeerAsync
		case HIP_API_ID_hipMemcpyPeerAsync : {
			//	void * dst (void *);
			//	int dstDeviceId (int);
			//	const void * src (const void *);
			//	int srcDevice (int);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyPeerAsync_t* args = (args_hipMemcpyPeerAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tint dstDeviceId = %d\n", args->dstDeviceId);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tint srcDevice = %d\n", args->srcDevice);
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemMap
		case HIP_API_ID_hipMemMap : {
			//	void * ptr (void *);
			//	size_t size (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemMap_t* args = (args_hipMemMap_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->handle);
			printf("\n");
			printf("\tunsigned long long flags = %llu\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipBindTextureToArray
		case HIP_API_ID_hipBindTextureToArray : {
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipArray_const_t array (const struct hipArray *);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipBindTextureToArray_t* args = (args_hipBindTextureToArray_t*) func_args;
			printf("\tconst textureReference * tex = %p", args->tex);
			if (args->tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_const_t array = %p", args->array);
			printf("\n");
			printf("\tconst hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DAsync_spt
		case HIP_API_ID_hipMemcpy2DAsync_spt : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DAsync_spt_t* args = (args_hipMemcpy2DAsync_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolSetAttribute
		case HIP_API_ID_hipMemPoolSetAttribute : {
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemPoolAttr attr (enum hipMemPoolAttr);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolSetAttribute_t* args = (args_hipMemPoolSetAttribute_t*) func_args;
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipMemPoolAttr attr = %d\n", args->attr);
			printf("\tvoid * value = %p", args->value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetLastError
		case HIP_API_ID_hipGetLastError : {
			//	hipError_t retval (enum hipError_t);
			args_hipGetLastError_t* args = (args_hipGetLastError_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamEndCapture_spt
		case HIP_API_ID_hipStreamEndCapture_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamEndCapture_spt_t* args = (args_hipStreamEndCapture_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipGraph_t * pGraph = %p", args->pGraph);
			if (args->pGraph != NULL) {
				printf(" -> %p\n", args->pGraph__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleOccupancyMaxPotentialBlockSize
		case HIP_API_ID_hipModuleOccupancyMaxPotentialBlockSize : {
			//	int * gridSize (int *);
			//	int * blockSize (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	int blockSizeLimit (int);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleOccupancyMaxPotentialBlockSize_t* args = (args_hipModuleOccupancyMaxPotentialBlockSize_t*) func_args;
			printf("\tint * gridSize = %p", args->gridSize);
			if (args->gridSize != NULL) {
				printf(" -> %d\n", args->gridSize__ref.val);
			} else { printf("\n"); };
			printf("\tint * blockSize = %p", args->blockSize);
			if (args->blockSize != NULL) {
				printf(" -> %d\n", args->blockSize__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\tint blockSizeLimit = %d\n", args->blockSizeLimit);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipKernelNameRefByPtr
		case HIP_API_ID_hipKernelNameRefByPtr : {
			//	const void * hostFunction (const void *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	const char * retval (const char *);
			args_hipKernelNameRefByPtr_t* args = (args_hipKernelNameRefByPtr_t*) func_args;
			printf("\tconst void * hostFunction = %p", args->hostFunction);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipGetDevice
		case HIP_API_ID_hipGetDevice : {
			//	int * deviceId (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetDevice_t* args = (args_hipGetDevice_t*) func_args;
			printf("\tint * deviceId = %p", args->deviceId);
			if (args->deviceId != NULL) {
				printf(" -> %d\n", args->deviceId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy3D_spt
		case HIP_API_ID_hipMemcpy3D_spt : {
			//	const struct hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy3D_spt_t* args = (args_hipMemcpy3D_spt_t*) func_args;
			printf("\tconst struct hipMemcpy3DParms * p = %p", args->p);
			if (args->p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexObjectGetTextureDesc
		case HIP_API_ID_hipTexObjectGetTextureDesc : {
			//	HIP_TEXTURE_DESC * pTexDesc ({
			//		HIPaddress_mode[3] addressMode (enum HIPaddress_mode_enum[3]);
			//		HIPfilter_mode filterMode (enum HIPfilter_mode_enum);
			//		unsigned int flags (unsigned int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		HIPfilter_mode mipmapFilterMode (enum HIPfilter_mode_enum);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		float[4] borderColor (float[4]);
			//		int[12] reserved (int[12]);
			//	});
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipTexObjectGetTextureDesc_t* args = (args_hipTexObjectGetTextureDesc_t*) func_args;
			printf("\tHIP_TEXTURE_DESC * pTexDesc = %p", args->pTexDesc);
			if (args->pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPaddress_mode[3] addressMode = %d\n", args->pTexDesc__ref.val.addressMode[0]);
				printf("\t\tHIPfilter_mode filterMode = %d\n", args->pTexDesc__ref.val.filterMode);
				printf("\t\tunsigned int flags = %u\n", args->pTexDesc__ref.val.flags);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tHIPfilter_mode mipmapFilterMode = %d\n", args->pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t\tfloat[4] borderColor = %f\n", args->pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint[12] reserved = %d\n", args->pTexDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t texObject = %p", args->texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGet
		case HIP_API_ID_hipDeviceGet : {
			//	hipDevice_t * device (int*);
			//	int ordinal (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGet_t* args = (args_hipDeviceGet_t*) func_args;
			printf("\thipDevice_t * device = %p", args->device);
			if (args->device != NULL) {
				printf(" -> %d\n", args->device__ref.val);
			} else { printf("\n"); };
			printf("\tint ordinal = %d\n", args->ordinal);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExternalSemaphoresSignalNodeSetParams
		case HIP_API_ID_hipGraphExternalSemaphoresSignalNodeSetParams : {
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreSignalNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExternalSemaphoresSignalNodeSetParams_t* args = (args_hipGraphExternalSemaphoresSignalNodeSetParams_t*) func_args;
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreSignalNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDestroySurfaceObject
		case HIP_API_ID_hipDestroySurfaceObject : {
			//	hipSurfaceObject_t surfaceObject (struct __hip_surface *);
			//	hipError_t retval (enum hipError_t);
			args_hipDestroySurfaceObject_t* args = (args_hipDestroySurfaceObject_t*) func_args;
			printf("\thipSurfaceObject_t surfaceObject = %p", args->surfaceObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetDevice
		case HIP_API_ID_hipStreamGetDevice : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipDevice_t * device (int*);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetDevice_t* args = (args_hipStreamGetDevice_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipDevice_t * device = %p", args->device);
			if (args->device != NULL) {
				printf(" -> %d\n", args->device__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemAllocPitch
		case HIP_API_ID_hipMemAllocPitch : {
			//	hipDeviceptr_t * dptr (void **);
			//	size_t * pitch (unsigned long*);
			//	size_t widthInBytes (unsigned long);
			//	size_t height (unsigned long);
			//	unsigned int elementSizeBytes (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMemAllocPitch_t* args = (args_hipMemAllocPitch_t*) func_args;
			printf("\thipDeviceptr_t * dptr = %p", args->dptr);
			if (args->dptr != NULL) {
				printf("-> %p", args->dptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * pitch = %p", args->pitch);
			if (args->pitch != NULL) {
				printf(" -> %lu\n", args->pitch__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t widthInBytes = %lu\n", args->widthInBytes);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\tunsigned int elementSizeBytes = %u\n", args->elementSizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddNode
		case HIP_API_ID_hipGraphAddNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipGraphNodeParams * nodeParams ({
			//		hipGraphNodeType type (enum hipGraphNodeType);
			//		int[3] reserved0 (int[3]);
			//		long long reserved2 (long long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddNode_t* args = (args_hipGraphAddNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipGraphNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipGraphNodeType type = %d\n", args->nodeParams__ref.val.type);
				printf("\t\tint[3] reserved0 = %d\n", args->nodeParams__ref.val.reserved0[0]);
				printf("\t\tlong long reserved2 = %lld\n", args->nodeParams__ref.val.reserved2);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceSetSharedMemConfig
		case HIP_API_ID_hipDeviceSetSharedMemConfig : {
			//	hipSharedMemConfig config (enum hipSharedMemConfig);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceSetSharedMemConfig_t* args = (args_hipDeviceSetSharedMemConfig_t*) func_args;
			printf("\thipSharedMemConfig config = %d\n", args->config);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipRuntimeGetVersion
		case HIP_API_ID_hipRuntimeGetVersion : {
			//	int * runtimeVersion (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipRuntimeGetVersion_t* args = (args_hipRuntimeGetVersion_t*) func_args;
			printf("\tint * runtimeVersion = %p", args->runtimeVersion);
			if (args->runtimeVersion != NULL) {
				printf(" -> %d\n", args->runtimeVersion__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphChildGraphNodeGetGraph
		case HIP_API_ID_hipGraphChildGraphNodeGetGraph : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphChildGraphNodeGetGraph_t* args = (args_hipGraphChildGraphNodeGetGraph_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipGraph_t * pGraph = %p", args->pGraph);
			if (args->pGraph != NULL) {
				printf(" -> %p\n", args->pGraph__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecMemsetNodeSetParams
		case HIP_API_ID_hipGraphExecMemsetNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipMemsetParams * pNodeParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecMemsetNodeSetParams_t* args = (args_hipGraphExecMemsetNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipMemsetParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->pNodeParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->pNodeParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->pNodeParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->pNodeParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphicsUnregisterResource
		case HIP_API_ID_hipGraphicsUnregisterResource : {
			//	hipGraphicsResource_t resource (struct _hipGraphicsResource*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphicsUnregisterResource_t* args = (args_hipGraphicsUnregisterResource_t*) func_args;
			printf("\thipGraphicsResource_t resource = %p", args->resource);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventElapsedTime
		case HIP_API_ID_hipEventElapsedTime : {
			//	float * ms (float *);
			//	hipEvent_t start (struct ihipEvent_t *);
			//	hipEvent_t stop (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipEventElapsedTime_t* args = (args_hipEventElapsedTime_t*) func_args;
			printf("\tfloat * ms = %p", args->ms);
			if (args->ms != NULL) {
				printf(" -> %f\n", args->ms__ref.val);
			} else { printf("\n"); };
			printf("\thipEvent_t start = %p", args->start);
			printf("\n");
			printf("\thipEvent_t stop = %p", args->stop);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFreeAsync
		case HIP_API_ID_hipFreeAsync : {
			//	void * dev_ptr (void *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipFreeAsync_t* args = (args_hipFreeAsync_t*) func_args;
			printf("\tvoid * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamCreateWithFlags
		case HIP_API_ID_hipStreamCreateWithFlags : {
			//	hipStream_t * stream (struct ihipStream_t **);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamCreateWithFlags_t* args = (args_hipStreamCreateWithFlags_t*) func_args;
			printf("\thipStream_t * stream = %p", args->stream);
			if (args->stream != NULL) {
				printf(" -> %p\n", args->stream__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetAddress
		case HIP_API_ID_hipTexRefSetAddress : {
			//	size_t * ByteOffset (unsigned long*);
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipDeviceptr_t dptr (void *);
			//	size_t bytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetAddress_t* args = (args_hipTexRefSetAddress_t*) func_args;
			printf("\tsize_t * ByteOffset = %p", args->ByteOffset);
			if (args->ByteOffset != NULL) {
				printf(" -> %lu\n", args->ByteOffset__ref.val);
			} else { printf("\n"); };
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipDeviceptr_t dptr = %p", args->dptr);
			printf("\n");
			printf("\tsize_t bytes = %lu\n", args->bytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamAddCallback_spt
		case HIP_API_ID_hipStreamAddCallback_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCallback_t callback (void (*)(struct ihipStream_t *, enum hipError_t, void *));
			//	void * userData (void *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamAddCallback_spt_t* args = (args_hipStreamAddCallback_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCallback_t callback = %p\n", args->callback);
			printf("\tvoid * userData = %p", args->userData);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddKernelNode
		case HIP_API_ID_hipGraphAddKernelNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddKernelNode_t* args = (args_hipGraphAddKernelNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst hipKernelNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyDtoH
		case HIP_API_ID_hipMemcpyDtoH : {
			//	void * dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyDtoH_t* args = (args_hipMemcpyDtoH_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceTotalMem
		case HIP_API_ID_hipDeviceTotalMem : {
			//	size_t * bytes (unsigned long*);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceTotalMem_t* args = (args_hipDeviceTotalMem_t*) func_args;
			printf("\tsize_t * bytes = %p", args->bytes);
			if (args->bytes != NULL) {
				printf(" -> %lu\n", args->bytes__ref.val);
			} else { printf("\n"); };
			printf("\thipDevice_t device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset2D
		case HIP_API_ID_hipMemset2D : {
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset2D_t* args = (args_hipMemset2D_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->pitch);
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DToArray_spt
		case HIP_API_ID_hipMemcpy2DToArray_spt : {
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DToArray_spt_t* args = (args_hipMemcpy2DToArray_spt_t*) func_args;
			printf("\thipArray_t dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemAllocHost
		case HIP_API_ID_hipMemAllocHost : {
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemAllocHost_t* args = (args_hipMemAllocHost_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipPointerSetAttribute
		case HIP_API_ID_hipPointerSetAttribute : {
			//	const void * value (const void *);
			//	hipPointer_attribute attribute (enum hipPointer_attribute);
			//	hipDeviceptr_t ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipPointerSetAttribute_t* args = (args_hipPointerSetAttribute_t*) func_args;
			printf("\tconst void * value = %p", args->value);
			printf("\n");
			printf("\thipPointer_attribute attribute = %d\n", args->attribute);
			printf("\thipDeviceptr_t ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphHostNodeGetParams
		case HIP_API_ID_hipGraphHostNodeGetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphHostNodeGetParams_t* args = (args_hipGraphHostNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipHostNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset3D
		case HIP_API_ID_hipMemset3D : {
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemset3D_t* args = (args_hipMemset3D_t*) func_args;
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDestroyTextureObject
		case HIP_API_ID_hipDestroyTextureObject : {
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipDestroyTextureObject_t* args = (args_hipDestroyTextureObject_t*) func_args;
			printf("\thipTextureObject_t textureObject = %p", args->textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemAdvise
		case HIP_API_ID_hipMemAdvise : {
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	hipMemoryAdvise advice (enum hipMemoryAdvise);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipMemAdvise_t* args = (args_hipMemAdvise_t*) func_args;
			printf("\tconst void * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemoryAdvise advice = %d\n", args->advice);
			printf("\tint device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxGetCacheConfig
		case HIP_API_ID_hipCtxGetCacheConfig : {
			//	hipFuncCache_t * cacheConfig (enum hipFuncCache_t*);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxGetCacheConfig_t* args = (args_hipCtxGetCacheConfig_t*) func_args;
			printf("\thipFuncCache_t * cacheConfig = %p", args->cacheConfig);
			if (args->cacheConfig != NULL) {
				printf(" -> %d\n", args->cacheConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvPointerGetAttributes
		case HIP_API_ID_hipDrvPointerGetAttributes : {
			//	unsigned int numAttributes (unsigned int);
			//	hipPointer_attribute * attributes (enum hipPointer_attribute*);
			//	void ** data (void **);
			//	hipDeviceptr_t ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipDrvPointerGetAttributes_t* args = (args_hipDrvPointerGetAttributes_t*) func_args;
			printf("\tunsigned int numAttributes = %u\n", args->numAttributes);
			printf("\thipPointer_attribute * attributes = %p", args->attributes);
			if (args->attributes != NULL) {
				printf(" -> %d\n", args->attributes__ref.val);
			} else { printf("\n"); };
			printf("\tvoid ** data = %p", args->data);
			if (args->data != NULL) {
				printf("-> %p", args->data__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipDeviceptr_t ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleLaunchCooperativeKernelMultiDevice
		case HIP_API_ID_hipModuleLaunchCooperativeKernelMultiDevice : {
			//	hipFunctionLaunchParams * launchParamsList ({
			//		hipFunction_t function (struct ihipModuleSymbol_t *);
			//		unsigned int gridDimX (unsigned int);
			//		unsigned int gridDimY (unsigned int);
			//		unsigned int gridDimZ (unsigned int);
			//		unsigned int blockDimX (unsigned int);
			//		unsigned int blockDimY (unsigned int);
			//		unsigned int blockDimZ (unsigned int);
			//		unsigned int sharedMemBytes (unsigned int);
			//		hipStream_t hStream (struct ihipStream_t *);
			//		void ** kernelParams (void **);
			//	});
			//	unsigned int numDevices (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleLaunchCooperativeKernelMultiDevice_t* args = (args_hipModuleLaunchCooperativeKernelMultiDevice_t*) func_args;
			printf("\thipFunctionLaunchParams * launchParamsList = %p", args->launchParamsList);
			if (args->launchParamsList != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int gridDimX = %u\n", args->launchParamsList__ref.val.gridDimX);
				printf("\t\tunsigned int gridDimY = %u\n", args->launchParamsList__ref.val.gridDimY);
				printf("\t\tunsigned int gridDimZ = %u\n", args->launchParamsList__ref.val.gridDimZ);
				printf("\t\tunsigned int blockDimX = %u\n", args->launchParamsList__ref.val.blockDimX);
				printf("\t\tunsigned int blockDimY = %u\n", args->launchParamsList__ref.val.blockDimY);
				printf("\t\tunsigned int blockDimZ = %u\n", args->launchParamsList__ref.val.blockDimZ);
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->launchParamsList__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numDevices = %u\n", args->numDevices);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleGetGlobal
		case HIP_API_ID_hipModuleGetGlobal : {
			//	hipDeviceptr_t * dptr (void **);
			//	size_t * bytes (unsigned long*);
			//	hipModule_t hmod (struct ihipModule_t *);
			//	const char * name (const char *);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleGetGlobal_t* args = (args_hipModuleGetGlobal_t*) func_args;
			printf("\thipDeviceptr_t * dptr = %p", args->dptr);
			if (args->dptr != NULL) {
				printf("-> %p", args->dptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * bytes = %p", args->bytes);
			if (args->bytes != NULL) {
				printf(" -> %lu\n", args->bytes__ref.val);
			} else { printf("\n"); };
			printf("\thipModule_t hmod = %p", args->hmod);
			printf("\n");
			printf("\tconst char * name = %p", args->name);
			if (args->name != NULL) {
				printf(" -> %s\n", args->name__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphEventRecordNodeGetEvent
		case HIP_API_ID_hipGraphEventRecordNodeGetEvent : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t * event_out (struct ihipEvent_t **);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphEventRecordNodeGetEvent_t* args = (args_hipGraphEventRecordNodeGetEvent_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipEvent_t * event_out = %p", args->event_out);
			if (args->event_out != NULL) {
				printf(" -> %p\n", args->event_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphInstantiate
		case HIP_API_ID_hipGraphInstantiate : {
			//	hipGraphExec_t * pGraphExec (struct hipGraphExec **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * pErrorNode (struct hipGraphNode **);
			//	char * pLogBuffer (char *);
			//	size_t bufferSize (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphInstantiate_t* args = (args_hipGraphInstantiate_t*) func_args;
			printf("\thipGraphExec_t * pGraphExec = %p", args->pGraphExec);
			if (args->pGraphExec != NULL) {
				printf(" -> %p\n", args->pGraphExec__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipGraphNode_t * pErrorNode = %p", args->pErrorNode);
			if (args->pErrorNode != NULL) {
				printf(" -> %p\n", args->pErrorNode__ref.val);
			} else { printf("\n"); };
			printf("\tchar * pLogBuffer = %p", args->pLogBuffer);
			if (args->pLogBuffer != NULL) {
				printf(" -> %s\n", args->pLogBuffer__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t bufferSize = %lu\n", args->bufferSize);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphRetainUserObject
		case HIP_API_ID_hipGraphRetainUserObject : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphRetainUserObject_t* args = (args_hipGraphRetainUserObject_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipUserObject_t object = %p", args->object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->count);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemAllocNodeGetParams
		case HIP_API_ID_hipGraphMemAllocNodeGetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemAllocNodeParams * pNodeParams ({
			//		hipMemPoolProps poolProps ({
			//			hipMemAllocationType allocType (enum hipMemAllocationType);
			//			hipMemAllocationHandleType handleTypes (enum hipMemAllocationHandleType);
			//			hipMemLocation location ({
			//				hipMemLocationType type (enum hipMemLocationType);
			//				int id (int);
			//			});
			//			void * win32SecurityAttributes (void *);
			//			size_t maxSize (unsigned long);
			//			unsigned char[56] reserved (unsigned char[56]);
			//		});
			//		size_t accessDescCount (unsigned long);
			//		size_t bytesize (unsigned long);
			//		void * dptr (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemAllocNodeGetParams_t* args = (args_hipGraphMemAllocNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipMemAllocNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemPoolProps poolProps = {\n");
				printf("\t\t\thipMemAllocationType allocType = %d\n", args->pNodeParams__ref.val.poolProps.allocType);
				printf("\t\t\thipMemAllocationHandleType handleTypes = %d\n", args->pNodeParams__ref.val.poolProps.handleTypes);
				printf("\t\t\thipMemLocation location = {\n");
				printf("\t\t\t\thipMemLocationType type = %d\n", args->pNodeParams__ref.val.poolProps.location.type);
				printf("\t\t\t\tint id = %d\n", args->pNodeParams__ref.val.poolProps.location.id);
				printf("\t\t\t}\n");
				printf("\t\t\tsize_t maxSize = %lu\n", args->pNodeParams__ref.val.poolProps.maxSize);
				printf("\t\t\tunsigned char[56] reserved = %hhu\n", args->pNodeParams__ref.val.poolProps.reserved[0]);
				printf("\t\t}\n");
				printf("\t\tsize_t accessDescCount = %lu\n", args->pNodeParams__ref.val.accessDescCount);
				printf("\t\tsize_t bytesize = %lu\n", args->pNodeParams__ref.val.bytesize);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetCaptureInfo
		case HIP_API_ID_hipStreamGetCaptureInfo : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	unsigned long long * pId (unsigned long long *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetCaptureInfo_t* args = (args_hipStreamGetCaptureInfo_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->pCaptureStatus);
			if (args->pCaptureStatus != NULL) {
				printf(" -> %d\n", args->pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * pId = %p", args->pId);
			if (args->pId != NULL) {
				printf(" -> %llu\n", args->pId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxPopCurrent
		case HIP_API_ID_hipCtxPopCurrent : {
			//	hipCtx_t * ctx (struct ihipCtx_t **);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxPopCurrent_t* args = (args_hipCtxPopCurrent_t*) func_args;
			printf("\thipCtx_t * ctx = %p", args->ctx);
			if (args->ctx != NULL) {
				printf(" -> %p\n", args->ctx__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipPointerGetAttributes
		case HIP_API_ID_hipPointerGetAttributes : {
			//	hipPointerAttribute_t * attributes ({
			//		enum hipMemoryType type (enum hipMemoryType);
			//		int device (int);
			//		void * devicePointer (void *);
			//		void * hostPointer (void *);
			//		int isManaged (int);
			//		unsigned int allocationFlags (unsigned int);
			//	});
			//	const void * ptr (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipPointerGetAttributes_t* args = (args_hipPointerGetAttributes_t*) func_args;
			printf("\thipPointerAttribute_t * attributes = %p", args->attributes);
			if (args->attributes != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipMemoryType type = %d\n", args->attributes__ref.val.type);
				printf("\t\tint device = %d\n", args->attributes__ref.val.device);
				printf("\t\tint isManaged = %d\n", args->attributes__ref.val.isManaged);
				printf("\t\tunsigned int allocationFlags = %u\n", args->attributes__ref.val.allocationFlags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceDisablePeerAccess
		case HIP_API_ID_hipDeviceDisablePeerAccess : {
			//	int peerDeviceId (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceDisablePeerAccess_t* args = (args_hipDeviceDisablePeerAccess_t*) func_args;
			printf("\tint peerDeviceId = %d\n", args->peerDeviceId);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocPitch
		case HIP_API_ID_hipMallocPitch : {
			//	void ** ptr (void **);
			//	size_t * pitch (unsigned long*);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocPitch_t* args = (args_hipMallocPitch_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * pitch = %p", args->pitch);
			if (args->pitch != NULL) {
				printf(" -> %lu\n", args->pitch__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DFromArrayAsync
		case HIP_API_ID_hipMemcpy2DFromArrayAsync : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DFromArrayAsync_t* args = (args_hipMemcpy2DFromArrayAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\thipArray_const_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceComputeCapability
		case HIP_API_ID_hipDeviceComputeCapability : {
			//	int * major (int *);
			//	int * minor (int *);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceComputeCapability_t* args = (args_hipDeviceComputeCapability_t*) func_args;
			printf("\tint * major = %p", args->major);
			if (args->major != NULL) {
				printf(" -> %d\n", args->major__ref.val);
			} else { printf("\n"); };
			printf("\tint * minor = %p", args->minor);
			if (args->minor != NULL) {
				printf(" -> %d\n", args->minor__ref.val);
			} else { printf("\n"); };
			printf("\thipDevice_t device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyHtoD
		case HIP_API_ID_hipMemcpyHtoD : {
			//	hipDeviceptr_t dst (void *);
			//	void * src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyHtoD_t* args = (args_hipMemcpyHtoD_t*) func_args;
			printf("\thipDeviceptr_t dst = %p", args->dst);
			printf("\n");
			printf("\tvoid * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipOccupancyMaxActiveBlocksPerMultiprocessor
		case HIP_API_ID_hipOccupancyMaxActiveBlocksPerMultiprocessor : {
			//	int * numBlocks (int *);
			//	const void * f (const void *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipOccupancyMaxActiveBlocksPerMultiprocessor_t* args = (args_hipOccupancyMaxActiveBlocksPerMultiprocessor_t*) func_args;
			printf("\tint * numBlocks = %p", args->numBlocks);
			if (args->numBlocks != NULL) {
				printf(" -> %d\n", args->numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * f = %p", args->f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipSignalExternalSemaphoresAsync
		case HIP_API_ID_hipSignalExternalSemaphoresAsync : {
			//	const hipExternalSemaphore_t * extSemArray (const void * *);
			//	const hipExternalSemaphoreSignalParams * paramsArray ({
			//		struct (unnamed struct at header/hip/hip.h:1488:2) params ({
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	unsigned int numExtSems (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipSignalExternalSemaphoresAsync_t* args = (args_hipSignalExternalSemaphoresAsync_t*) func_args;
			printf("\tconst hipExternalSemaphore_t * extSemArray = %p", args->extSemArray);
			if (args->extSemArray != NULL) {
				printf("-> %p", args->extSemArray__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalSemaphoreSignalParams * paramsArray = %p", args->paramsArray);
			if (args->paramsArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1488:2) params = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->paramsArray__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->paramsArray__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numExtSems = %u\n", args->numExtSems);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipArray3DGetDescriptor
		case HIP_API_ID_hipArray3DGetDescriptor : {
			//	HIP_ARRAY3D_DESCRIPTOR * pArrayDescriptor ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//		unsigned int Flags (unsigned int);
			//	});
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			args_hipArray3DGetDescriptor_t* args = (args_hipArray3DGetDescriptor_t*) func_args;
			printf("\tHIP_ARRAY3D_DESCRIPTOR * pArrayDescriptor = %p", args->pArrayDescriptor);
			if (args->pArrayDescriptor != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->pArrayDescriptor__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->pArrayDescriptor__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->pArrayDescriptor__ref.val.Depth);
				printf("\t\tenum hipArray_Format Format = %d\n", args->pArrayDescriptor__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->pArrayDescriptor__ref.val.NumChannels);
				printf("\t\tunsigned int Flags = %u\n", args->pArrayDescriptor__ref.val.Flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_t array = %p", args->array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE___hipPopCallConfiguration
		case HIP_API_ID___hipPopCallConfiguration : {
			//	dim3 * gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 * blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	size_t * sharedMem (unsigned long*);
			//	hipStream_t * stream (struct ihipStream_t **);
			//	hipError_t retval (enum hipError_t);
			args___hipPopCallConfiguration_t* args = (args___hipPopCallConfiguration_t*) func_args;
			printf("\tdim3 * gridDim = %p", args->gridDim);
			if (args->gridDim != NULL) {
				printf(" -> {\n");
				printf("\t\tuint32_t x = %u\n", args->gridDim__ref.val.x);
				printf("\t\tuint32_t y = %u\n", args->gridDim__ref.val.y);
				printf("\t\tuint32_t z = %u\n", args->gridDim__ref.val.z);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tdim3 * blockDim = %p", args->blockDim);
			if (args->blockDim != NULL) {
				printf(" -> {\n");
				printf("\t\tuint32_t x = %u\n", args->blockDim__ref.val.x);
				printf("\t\tuint32_t y = %u\n", args->blockDim__ref.val.y);
				printf("\t\tuint32_t z = %u\n", args->blockDim__ref.val.z);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t * sharedMem = %p", args->sharedMem);
			if (args->sharedMem != NULL) {
				printf(" -> %lu\n", args->sharedMem__ref.val);
			} else { printf("\n"); };
			printf("\thipStream_t * stream = %p", args->stream);
			if (args->stream != NULL) {
				printf(" -> %p\n", args->stream__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDevicePrimaryCtxRelease
		case HIP_API_ID_hipDevicePrimaryCtxRelease : {
			//	hipDevice_t dev (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDevicePrimaryCtxRelease_t* args = (args_hipDevicePrimaryCtxRelease_t*) func_args;
			printf("\thipDevice_t dev = %d\n", args->dev);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchCooperativeKernelMultiDevice
		case HIP_API_ID_hipLaunchCooperativeKernelMultiDevice : {
			//	hipLaunchParams * launchParamsList ({
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** args (void **);
			//		size_t sharedMem (unsigned long);
			//		hipStream_t stream (struct ihipStream_t *);
			//	});
			//	int numDevices (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchCooperativeKernelMultiDevice_t* args = (args_hipLaunchCooperativeKernelMultiDevice_t*) func_args;
			printf("\thipLaunchParams * launchParamsList = %p", args->launchParamsList);
			if (args->launchParamsList != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->launchParamsList__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->launchParamsList__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->launchParamsList__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->launchParamsList__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->launchParamsList__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->launchParamsList__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tsize_t sharedMem = %lu\n", args->launchParamsList__ref.val.sharedMem);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint numDevices = %d\n", args->numDevices);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFreeArray
		case HIP_API_ID_hipFreeArray : {
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			args_hipFreeArray_t* args = (args_hipFreeArray_t*) func_args;
			printf("\thipArray_t array = %p", args->array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemsetNodeSetParams
		case HIP_API_ID_hipGraphMemsetNodeSetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipMemsetParams * pNodeParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemsetNodeSetParams_t* args = (args_hipGraphMemsetNodeSetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipMemsetParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->pNodeParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->pNodeParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->pNodeParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->pNodeParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolSetAccess
		case HIP_API_ID_hipMemPoolSetAccess : {
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	const hipMemAccessDesc * desc_list ({
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		hipMemAccessFlags flags (enum hipMemAccessFlags);
			//	});
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolSetAccess_t* args = (args_hipMemPoolSetAccess_t*) func_args;
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\tconst hipMemAccessDesc * desc_list = %p", args->desc_list);
			if (args->desc_list != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->desc_list__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->desc_list__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\thipMemAccessFlags flags = %d\n", args->desc_list__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetStreamDeviceId
		case HIP_API_ID_hipGetStreamDeviceId : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	int retval (int);
			args_hipGetStreamDeviceId_t* args = (args_hipGetStreamDeviceId_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tint retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtStreamCreateWithCUMask
		case HIP_API_ID_hipExtStreamCreateWithCUMask : {
			//	hipStream_t * stream (struct ihipStream_t **);
			//	uint32_t cuMaskSize (unsigned int);
			//	const uint32_t * cuMask (const unsigned int *);
			//	hipError_t retval (enum hipError_t);
			args_hipExtStreamCreateWithCUMask_t* args = (args_hipExtStreamCreateWithCUMask_t*) func_args;
			printf("\thipStream_t * stream = %p", args->stream);
			if (args->stream != NULL) {
				printf(" -> %p\n", args->stream__ref.val);
			} else { printf("\n"); };
			printf("\tuint32_t cuMaskSize = %u\n", args->cuMaskSize);
			printf("\tconst uint32_t * cuMask = %p", args->cuMask);
			if (args->cuMask != NULL) {
				printf(" -> %u\n", args->cuMask__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetTextureObjectTextureDesc
		case HIP_API_ID_hipGetTextureObjectTextureDesc : {
			//	hipTextureDesc * pTexDesc ({
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		int sRGB (int);
			//		float[4] borderColor (float[4]);
			//		int normalizedCoords (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//	});
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetTextureObjectTextureDesc_t* args = (args_hipGetTextureObjectTextureDesc_t*) func_args;
			printf("\thipTextureDesc * pTexDesc = %p", args->pTexDesc);
			if (args->pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->pTexDesc__ref.val.addressMode[0]);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->pTexDesc__ref.val.filterMode);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->pTexDesc__ref.val.readMode);
				printf("\t\tint sRGB = %d\n", args->pTexDesc__ref.val.sRGB);
				printf("\t\tfloat[4] borderColor = %f\n", args->pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint normalizedCoords = %d\n", args->pTexDesc__ref.val.normalizedCoords);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t textureObject = %p", args->textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventRecord_spt
		case HIP_API_ID_hipEventRecord_spt : {
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipEventRecord_spt_t* args = (args_hipEventRecord_spt_t*) func_args;
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipConfigureCall
		case HIP_API_ID_hipConfigureCall : {
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	size_t sharedMem (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipConfigureCall_t* args = (args_hipConfigureCall_t*) func_args;
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->blockDim.x);
			printf("\t\tuint32_t y = %u\n", args->blockDim.y);
			printf("\t\tuint32_t z = %u\n", args->blockDim.z);
			printf("\t}\n");
			printf("\tsize_t sharedMem = %lu\n", args->sharedMem);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyFromArray_spt
		case HIP_API_ID_hipMemcpyFromArray_spt : {
			//	void * dst (void *);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffsetSrc (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyFromArray_spt_t* args = (args_hipMemcpyFromArray_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\thipArray_const_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t wOffsetSrc = %lu\n", args->wOffsetSrc);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleGetFunction
		case HIP_API_ID_hipModuleGetFunction : {
			//	hipFunction_t * function (struct ihipModuleSymbol_t **);
			//	hipModule_t module (struct ihipModule_t *);
			//	const char * kname (const char *);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleGetFunction_t* args = (args_hipModuleGetFunction_t*) func_args;
			printf("\thipFunction_t * function = %p", args->function);
			if (args->function != NULL) {
				printf(" -> %p\n", args->function__ref.val);
			} else { printf("\n"); };
			printf("\thipModule_t module = %p", args->module);
			printf("\n");
			printf("\tconst char * kname = %p", args->kname);
			if (args->kname != NULL) {
				printf(" -> %s\n", args->kname__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFuncSetCacheConfig
		case HIP_API_ID_hipFuncSetCacheConfig : {
			//	const void * func (const void *);
			//	hipFuncCache_t config (enum hipFuncCache_t);
			//	hipError_t retval (enum hipError_t);
			args_hipFuncSetCacheConfig_t* args = (args_hipFuncSetCacheConfig_t*) func_args;
			printf("\tconst void * func = %p", args->func);
			printf("\n");
			printf("\thipFuncCache_t config = %d\n", args->config);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetLimit
		case HIP_API_ID_hipDeviceGetLimit : {
			//	size_t * pValue (unsigned long*);
			//	enum hipLimit_t limit (enum hipLimit_t);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetLimit_t* args = (args_hipDeviceGetLimit_t*) func_args;
			printf("\tsize_t * pValue = %p", args->pValue);
			if (args->pValue != NULL) {
				printf(" -> %lu\n", args->pValue__ref.val);
			} else { printf("\n"); };
			printf("\tenum hipLimit_t limit = %d\n", args->limit);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetMaxAnisotropy
		case HIP_API_ID_hipTexRefGetMaxAnisotropy : {
			//	int * pmaxAnsio (int *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetMaxAnisotropy_t* args = (args_hipTexRefGetMaxAnisotropy_t*) func_args;
			printf("\tint * pmaxAnsio = %p", args->pmaxAnsio);
			if (args->pmaxAnsio != NULL) {
				printf(" -> %d\n", args->pmaxAnsio__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchKernel_spt
		case HIP_API_ID_hipLaunchKernel_spt : {
			//	const void * function_address (const void *);
			//	dim3 numBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 dimBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** args (void **);
			//	size_t sharedMemBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchKernel_spt_t* args = (args_hipLaunchKernel_spt_t*) func_args;
			printf("\tconst void * function_address = %p", args->function_address);
			printf("\n");
			printf("\tdim3 numBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->numBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->numBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->numBlocks.z);
			printf("\t}\n");
			printf("\tdim3 dimBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->dimBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->dimBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->dimBlocks.z);
			printf("\t}\n");
			printf("\tvoid ** args = %p", args->args);
			if (args->args != NULL) {
				printf("-> %p", args->args__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sharedMemBytes = %lu\n", args->sharedMemBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamBeginCaptureToGraph
		case HIP_API_ID_hipStreamBeginCaptureToGraph : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * dependencies (const struct hipGraphNode * *);
			//	const hipGraphEdgeData * dependencyData ({
			//		unsigned char from_port (unsigned char);
			//		unsigned char[5] reserved (unsigned char[5]);
			//		unsigned char to_port (unsigned char);
			//		unsigned char type (unsigned char);
			//	});
			//	size_t numDependencies (unsigned long);
			//	hipStreamCaptureMode mode (enum hipStreamCaptureMode);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamBeginCaptureToGraph_t* args = (args_hipStreamBeginCaptureToGraph_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * dependencies = %p", args->dependencies);
			if (args->dependencies != NULL) {
				printf(" -> %p\n", args->dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphEdgeData * dependencyData = %p", args->dependencyData);
			if (args->dependencyData != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned char from_port = %hhu\n", args->dependencyData__ref.val.from_port);
				printf("\t\tunsigned char[5] reserved = %hhu\n", args->dependencyData__ref.val.reserved[0]);
				printf("\t\tunsigned char to_port = %hhu\n", args->dependencyData__ref.val.to_port);
				printf("\t\tunsigned char type = %hhu\n", args->dependencyData__ref.val.type);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipStreamCaptureMode mode = %d\n", args->mode);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetFormat
		case HIP_API_ID_hipTexRefGetFormat : {
			//	hipArray_Format * pFormat (enum hipArray_Format*);
			//	int * pNumChannels (int *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetFormat_t* args = (args_hipTexRefGetFormat_t*) func_args;
			printf("\thipArray_Format * pFormat = %p", args->pFormat);
			if (args->pFormat != NULL) {
				printf(" -> %d\n", args->pFormat__ref.val);
			} else { printf("\n"); };
			printf("\tint * pNumChannels = %p", args->pNumChannels);
			if (args->pNumChannels != NULL) {
				printf(" -> %d\n", args->pNumChannels__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamWaitValue64
		case HIP_API_ID_hipStreamWaitValue64 : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint64_t value (unsigned long);
			//	unsigned int flags (unsigned int);
			//	uint64_t mask (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamWaitValue64_t* args = (args_hipStreamWaitValue64_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tuint64_t value = %lu\n", args->value);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\tuint64_t mask = %lu\n", args->mask);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDevicePrimaryCtxRetain
		case HIP_API_ID_hipDevicePrimaryCtxRetain : {
			//	hipCtx_t * pctx (struct ihipCtx_t **);
			//	hipDevice_t dev (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDevicePrimaryCtxRetain_t* args = (args_hipDevicePrimaryCtxRetain_t*) func_args;
			printf("\thipCtx_t * pctx = %p", args->pctx);
			if (args->pctx != NULL) {
				printf(" -> %p\n", args->pctx__ref.val);
			} else { printf("\n"); };
			printf("\thipDevice_t dev = %d\n", args->dev);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocManaged
		case HIP_API_ID_hipMallocManaged : {
			//	void ** dev_ptr (void **);
			//	size_t size (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocManaged_t* args = (args_hipMallocManaged_t*) func_args;
			printf("\tvoid ** dev_ptr = %p", args->dev_ptr);
			if (args->dev_ptr != NULL) {
				printf("-> %p", args->dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamCreateWithPriority
		case HIP_API_ID_hipStreamCreateWithPriority : {
			//	hipStream_t * stream (struct ihipStream_t **);
			//	unsigned int flags (unsigned int);
			//	int priority (int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamCreateWithPriority_t* args = (args_hipStreamCreateWithPriority_t*) func_args;
			printf("\thipStream_t * stream = %p", args->stream);
			if (args->stream != NULL) {
				printf(" -> %p\n", args->stream__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\tint priority = %d\n", args->priority);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetCaptureInfo_spt
		case HIP_API_ID_hipStreamGetCaptureInfo_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	unsigned long long * pId (unsigned long long *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetCaptureInfo_spt_t* args = (args_hipStreamGetCaptureInfo_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->pCaptureStatus);
			if (args->pCaptureStatus != NULL) {
				printf(" -> %d\n", args->pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * pId = %p", args->pId);
			if (args->pId != NULL) {
				printf(" -> %llu\n", args->pId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddHostNode
		case HIP_API_ID_hipGraphAddHostNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddHostNode_t* args = (args_hipGraphAddHostNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst hipHostNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchCooperativeKernel
		case HIP_API_ID_hipLaunchCooperativeKernel : {
			//	const void * f (const void *);
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDimX ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** kernelParams (void **);
			//	unsigned int sharedMemBytes (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchCooperativeKernel_t* args = (args_hipLaunchCooperativeKernel_t*) func_args;
			printf("\tconst void * f = %p", args->f);
			printf("\n");
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDimX = {\n");
			printf("\t\tuint32_t x = %u\n", args->blockDimX.x);
			printf("\t\tuint32_t y = %u\n", args->blockDimX.y);
			printf("\t\tuint32_t z = %u\n", args->blockDimX.z);
			printf("\t}\n");
			printf("\tvoid ** kernelParams = %p", args->kernelParams);
			if (args->kernelParams != NULL) {
				printf("-> %p", args->kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tunsigned int sharedMemBytes = %u\n", args->sharedMemBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostRegister
		case HIP_API_ID_hipHostRegister : {
			//	void * hostPtr (void *);
			//	size_t sizeBytes (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipHostRegister_t* args = (args_hipHostRegister_t*) func_args;
			printf("\tvoid * hostPtr = %p", args->hostPtr);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetErrorName
		case HIP_API_ID_hipGetErrorName : {
			//	hipError_t hip_error (enum hipError_t);
			//	const char * retval (const char *);
			args_hipGetErrorName_t* args = (args_hipGetErrorName_t*) func_args;
			printf("\thipError_t hip_error = %d\n", args->hip_error);
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipMemcpyToSymbol_spt
		case HIP_API_ID_hipMemcpyToSymbol_spt : {
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyToSymbol_spt_t* args = (args_hipMemcpyToSymbol_spt_t*) func_args;
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemsetNodeGetParams
		case HIP_API_ID_hipGraphMemsetNodeGetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemsetParams * pNodeParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemsetNodeGetParams_t* args = (args_hipGraphMemsetNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipMemsetParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->pNodeParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->pNodeParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->pNodeParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->pNodeParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamWriteValue32
		case HIP_API_ID_hipStreamWriteValue32 : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint32_t value (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamWriteValue32_t* args = (args_hipStreamWriteValue32_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tuint32_t value = %u\n", args->value);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamSynchronize_spt
		case HIP_API_ID_hipStreamSynchronize_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamSynchronize_spt_t* args = (args_hipStreamSynchronize_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGraphMemTrim
		case HIP_API_ID_hipDeviceGraphMemTrim : {
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGraphMemTrim_t* args = (args_hipDeviceGraphMemTrim_t*) func_args;
			printf("\tint device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamDestroy
		case HIP_API_ID_hipStreamDestroy : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamDestroy_t* args = (args_hipStreamDestroy_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetArray
		case HIP_API_ID_hipTexRefSetArray : {
			//	textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipArray_const_t array (const struct hipArray *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetArray_t* args = (args_hipTexRefSetArray_t*) func_args;
			printf("\ttextureReference * tex = %p", args->tex);
			if (args->tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_const_t array = %p", args->array);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyParam2DAsync
		case HIP_API_ID_hipMemcpyParam2DAsync : {
			//	const hip_Memcpy2D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyParam2DAsync_t* args = (args_hipMemcpyParam2DAsync_t*) func_args;
			printf("\tconst hip_Memcpy2D * pCopy = %p", args->pCopy);
			if (args->pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->pCopy__ref.val.srcY);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->pCopy__ref.val.srcPitch);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->pCopy__ref.val.dstY);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->pCopy__ref.val.dstPitch);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->pCopy__ref.val.Height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolExportPointer
		case HIP_API_ID_hipMemPoolExportPointer : {
			//	hipMemPoolPtrExportData * export_data ({
			//		unsigned char[64] reserved (unsigned char[64]);
			//	});
			//	void * dev_ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolExportPointer_t* args = (args_hipMemPoolExportPointer_t*) func_args;
			printf("\thipMemPoolPtrExportData * export_data = %p", args->export_data);
			if (args->export_data != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned char[64] reserved = %hhu\n", args->export_data__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tvoid * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphEventRecordNodeSetEvent
		case HIP_API_ID_hipGraphEventRecordNodeSetEvent : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphEventRecordNodeSetEvent_t* args = (args_hipGraphEventRecordNodeSetEvent_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxDestroy
		case HIP_API_ID_hipCtxDestroy : {
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxDestroy_t* args = (args_hipCtxDestroy_t*) func_args;
			printf("\thipCtx_t ctx = %p", args->ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipArrayDestroy
		case HIP_API_ID_hipArrayDestroy : {
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			args_hipArrayDestroy_t* args = (args_hipArrayDestroy_t*) func_args;
			printf("\thipArray_t array = %p", args->array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemGetAllocationGranularity
		case HIP_API_ID_hipMemGetAllocationGranularity : {
			//	size_t * granularity (unsigned long*);
			//	const hipMemAllocationProp * prop ({
			//		hipMemAllocationType type (enum hipMemAllocationType);
			//		hipMemAllocationHandleType requestedHandleType (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32HandleMetaData (void *);
			//		struct (unnamed struct at header/hip/hip.h:1616:2) allocFlags ({
			//		});
			//	});
			//	hipMemAllocationGranularity_flags option (enum hipMemAllocationGranularity_flags);
			//	hipError_t retval (enum hipError_t);
			args_hipMemGetAllocationGranularity_t* args = (args_hipMemGetAllocationGranularity_t*) func_args;
			printf("\tsize_t * granularity = %p", args->granularity);
			if (args->granularity != NULL) {
				printf(" -> %lu\n", args->granularity__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipMemAllocationProp * prop = %p", args->prop);
			if (args->prop != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType type = %d\n", args->prop__ref.val.type);
				printf("\t\thipMemAllocationHandleType requestedHandleType = %d\n", args->prop__ref.val.requestedHandleType);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->prop__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->prop__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1616:2) allocFlags = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipMemAllocationGranularity_flags option = %d\n", args->option);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphClone
		case HIP_API_ID_hipGraphClone : {
			//	hipGraph_t * pGraphClone (struct ihipGraph **);
			//	hipGraph_t originalGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphClone_t* args = (args_hipGraphClone_t*) func_args;
			printf("\thipGraph_t * pGraphClone = %p", args->pGraphClone);
			if (args->pGraphClone != NULL) {
				printf(" -> %p\n", args->pGraphClone__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t originalGraph = %p", args->originalGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset2DAsync_spt
		case HIP_API_ID_hipMemset2DAsync_spt : {
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset2DAsync_spt_t* args = (args_hipMemset2DAsync_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->pitch);
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipBindTexture2D
		case HIP_API_ID_hipBindTexture2D : {
			//	size_t * offset (unsigned long*);
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const void * devPtr (const void *);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	size_t pitch (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipBindTexture2D_t* args = (args_hipBindTexture2D_t*) func_args;
			printf("\tsize_t * offset = %p", args->offset);
			if (args->offset != NULL) {
				printf(" -> %lu\n", args->offset__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * tex = %p", args->tex);
			if (args->tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * devPtr = %p", args->devPtr);
			printf("\n");
			printf("\tconst hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\tsize_t pitch = %lu\n", args->pitch);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipArrayGetInfo
		case HIP_API_ID_hipArrayGetInfo : {
			//	hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipExtent * extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	unsigned int * flags (unsigned int *);
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			args_hipArrayGetInfo_t* args = (args_hipArrayGetInfo_t*) func_args;
			printf("\thipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipExtent * extent = %p", args->extent);
			if (args->extent != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t width = %lu\n", args->extent__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->extent__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->extent__ref.val.depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %u\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\thipArray_t array = %p", args->array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExternalSemaphoresSignalNodeGetParams
		case HIP_API_ID_hipGraphExternalSemaphoresSignalNodeGetParams : {
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipExternalSemaphoreSignalNodeParams * params_out ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExternalSemaphoresSignalNodeGetParams_t* args = (args_hipGraphExternalSemaphoresSignalNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\thipExternalSemaphoreSignalNodeParams * params_out = %p", args->params_out);
			if (args->params_out != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->params_out__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetStreamPriorityRange
		case HIP_API_ID_hipDeviceGetStreamPriorityRange : {
			//	int * leastPriority (int *);
			//	int * greatestPriority (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetStreamPriorityRange_t* args = (args_hipDeviceGetStreamPriorityRange_t*) func_args;
			printf("\tint * leastPriority = %p", args->leastPriority);
			if (args->leastPriority != NULL) {
				printf(" -> %d\n", args->leastPriority__ref.val);
			} else { printf("\n"); };
			printf("\tint * greatestPriority = %p", args->greatestPriority);
			if (args->greatestPriority != NULL) {
				printf(" -> %d\n", args->greatestPriority__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecChildGraphNodeSetParams
		case HIP_API_ID_hipGraphExecChildGraphNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraph_t childGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecChildGraphNodeSetParams_t* args = (args_hipGraphExecChildGraphNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipGraph_t childGraph = %p", args->childGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset2D_spt
		case HIP_API_ID_hipMemset2D_spt : {
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset2D_spt_t* args = (args_hipMemset2D_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->pitch);
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetDefaultMemPool
		case HIP_API_ID_hipDeviceGetDefaultMemPool : {
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetDefaultMemPool_t* args = (args_hipDeviceGetDefaultMemPool_t*) func_args;
			printf("\thipMemPool_t * mem_pool = %p", args->mem_pool);
			if (args->mem_pool != NULL) {
				printf(" -> %p\n", args->mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tint device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxCreate
		case HIP_API_ID_hipCtxCreate : {
			//	hipCtx_t * ctx (struct ihipCtx_t **);
			//	unsigned int flags (unsigned int);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxCreate_t* args = (args_hipCtxCreate_t*) func_args;
			printf("\thipCtx_t * ctx = %p", args->ctx);
			if (args->ctx != NULL) {
				printf(" -> %p\n", args->ctx__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipDevice_t device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamIsCapturing
		case HIP_API_ID_hipStreamIsCapturing : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamIsCapturing_t* args = (args_hipStreamIsCapturing_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->pCaptureStatus);
			if (args->pCaptureStatus != NULL) {
				printf(" -> %d\n", args->pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamUpdateCaptureDependencies
		case HIP_API_ID_hipStreamUpdateCaptureDependencies : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraphNode_t * dependencies (struct hipGraphNode **);
			//	size_t numDependencies (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamUpdateCaptureDependencies_t* args = (args_hipStreamUpdateCaptureDependencies_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipGraphNode_t * dependencies = %p", args->dependencies);
			if (args->dependencies != NULL) {
				printf(" -> %p\n", args->dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceSynchronize
		case HIP_API_ID_hipDeviceSynchronize : {
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceSynchronize_t* args = (args_hipDeviceSynchronize_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyFromSymbolAsync
		case HIP_API_ID_hipMemcpyFromSymbolAsync : {
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyFromSymbolAsync_t* args = (args_hipMemcpyFromSymbolAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphDestroyNode
		case HIP_API_ID_hipGraphDestroyNode : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphDestroyNode_t* args = (args_hipGraphDestroyNode_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipUserObjectRetain
		case HIP_API_ID_hipUserObjectRetain : {
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipUserObjectRetain_t* args = (args_hipUserObjectRetain_t*) func_args;
			printf("\thipUserObject_t object = %p", args->object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecEventWaitNodeSetEvent
		case HIP_API_ID_hipGraphExecEventWaitNodeSetEvent : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecEventWaitNodeSetEvent_t* args = (args_hipGraphExecEventWaitNodeSetEvent_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemAddressReserve
		case HIP_API_ID_hipMemAddressReserve : {
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	size_t alignment (unsigned long);
			//	void * addr (void *);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemAddressReserve_t* args = (args_hipMemAddressReserve_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\tsize_t alignment = %lu\n", args->alignment);
			printf("\tvoid * addr = %p", args->addr);
			printf("\n");
			printf("\tunsigned long long flags = %llu\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemsetNode
		case HIP_API_ID_hipGraphAddMemsetNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipMemsetParams * pMemsetParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemsetNode_t* args = (args_hipGraphAddMemsetNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst hipMemsetParams * pMemsetParams = %p", args->pMemsetParams);
			if (args->pMemsetParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->pMemsetParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->pMemsetParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->pMemsetParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->pMemsetParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->pMemsetParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphicsResourceGetMappedPointer
		case HIP_API_ID_hipGraphicsResourceGetMappedPointer : {
			//	void ** devPtr (void **);
			//	size_t * size (unsigned long*);
			//	hipGraphicsResource_t resource (struct _hipGraphicsResource*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphicsResourceGetMappedPointer_t* args = (args_hipGraphicsResourceGetMappedPointer_t*) func_args;
			printf("\tvoid ** devPtr = %p", args->devPtr);
			if (args->devPtr != NULL) {
				printf("-> %p", args->devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * size = %p", args->size);
			if (args->size != NULL) {
				printf(" -> %lu\n", args->size__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphicsResource_t resource = %p", args->resource);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamBeginCapture_spt
		case HIP_API_ID_hipStreamBeginCapture_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureMode mode (enum hipStreamCaptureMode);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamBeginCapture_spt_t* args = (args_hipStreamBeginCapture_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureMode mode = %d\n", args->mode);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetUuid
		case HIP_API_ID_hipDeviceGetUuid : {
			//	hipUUID * uuid ({
			//		char[16] bytes (char[16]);
			//	});
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetUuid_t* args = (args_hipDeviceGetUuid_t*) func_args;
			printf("\thipUUID * uuid = %p", args->uuid);
			if (args->uuid != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[16] bytes = %c\n", args->uuid__ref.val.bytes[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipDevice_t device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleLaunchKernel
		case HIP_API_ID_hipModuleLaunchKernel : {
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	unsigned int gridDimX (unsigned int);
			//	unsigned int gridDimY (unsigned int);
			//	unsigned int gridDimZ (unsigned int);
			//	unsigned int blockDimX (unsigned int);
			//	unsigned int blockDimY (unsigned int);
			//	unsigned int blockDimZ (unsigned int);
			//	unsigned int sharedMemBytes (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	void ** kernelParams (void **);
			//	void ** extra (void **);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleLaunchKernel_t* args = (args_hipModuleLaunchKernel_t*) func_args;
			printf("\thipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tunsigned int gridDimX = %u\n", args->gridDimX);
			printf("\tunsigned int gridDimY = %u\n", args->gridDimY);
			printf("\tunsigned int gridDimZ = %u\n", args->gridDimZ);
			printf("\tunsigned int blockDimX = %u\n", args->blockDimX);
			printf("\tunsigned int blockDimY = %u\n", args->blockDimY);
			printf("\tunsigned int blockDimZ = %u\n", args->blockDimZ);
			printf("\tunsigned int sharedMemBytes = %u\n", args->sharedMemBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid ** kernelParams = %p", args->kernelParams);
			if (args->kernelParams != NULL) {
				printf("-> %p", args->kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tvoid ** extra = %p", args->extra);
			if (args->extra != NULL) {
				printf("-> %p", args->extra__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddEmptyNode
		case HIP_API_ID_hipGraphAddEmptyNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddEmptyNode_t* args = (args_hipGraphAddEmptyNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemRangeGetAttribute
		case HIP_API_ID_hipMemRangeGetAttribute : {
			//	void * data (void *);
			//	size_t data_size (unsigned long);
			//	hipMemRangeAttribute attribute (enum hipMemRangeAttribute);
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemRangeGetAttribute_t* args = (args_hipMemRangeGetAttribute_t*) func_args;
			printf("\tvoid * data = %p", args->data);
			printf("\n");
			printf("\tsize_t data_size = %lu\n", args->data_size);
			printf("\thipMemRangeAttribute attribute = %d\n", args->attribute);
			printf("\tconst void * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphInstantiateWithFlags
		case HIP_API_ID_hipGraphInstantiateWithFlags : {
			//	hipGraphExec_t * pGraphExec (struct hipGraphExec **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphInstantiateWithFlags_t* args = (args_hipGraphInstantiateWithFlags_t*) func_args;
			printf("\thipGraphExec_t * pGraphExec = %p", args->pGraphExec);
			if (args->pGraphExec != NULL) {
				printf(" -> %p\n", args->pGraphExec__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tunsigned long long flags = %llu\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxPushCurrent
		case HIP_API_ID_hipCtxPushCurrent : {
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxPushCurrent_t* args = (args_hipCtxPushCurrent_t*) func_args;
			printf("\thipCtx_t ctx = %p", args->ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxGetApiVersion
		case HIP_API_ID_hipCtxGetApiVersion : {
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	int * apiVersion (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxGetApiVersion_t* args = (args_hipCtxGetApiVersion_t*) func_args;
			printf("\thipCtx_t ctx = %p", args->ctx);
			printf("\n");
			printf("\tint * apiVersion = %p", args->apiVersion);
			if (args->apiVersion != NULL) {
				printf(" -> %d\n", args->apiVersion__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipBindTexture
		case HIP_API_ID_hipBindTexture : {
			//	size_t * offset (unsigned long*);
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const void * devPtr (const void *);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipBindTexture_t* args = (args_hipBindTexture_t*) func_args;
			printf("\tsize_t * offset = %p", args->offset);
			if (args->offset != NULL) {
				printf(" -> %lu\n", args->offset__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * tex = %p", args->tex);
			if (args->tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * devPtr = %p", args->devPtr);
			printf("\n");
			printf("\tconst hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamBeginCapture
		case HIP_API_ID_hipStreamBeginCapture : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureMode mode (enum hipStreamCaptureMode);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamBeginCapture_t* args = (args_hipStreamBeginCapture_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureMode mode = %d\n", args->mode);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipProfilerStart
		case HIP_API_ID_hipProfilerStart : {
			//	hipError_t retval (enum hipError_t);
			args_hipProfilerStart_t* args = (args_hipProfilerStart_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyHtoDAsync
		case HIP_API_ID_hipMemcpyHtoDAsync : {
			//	hipDeviceptr_t dst (void *);
			//	void * src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyHtoDAsync_t* args = (args_hipMemcpyHtoDAsync_t*) func_args;
			printf("\thipDeviceptr_t dst = %p", args->dst);
			printf("\n");
			printf("\tvoid * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetDeviceFlags
		case HIP_API_ID_hipGetDeviceFlags : {
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetDeviceFlags_t* args = (args_hipGetDeviceFlags_t*) func_args;
			printf("\tunsigned int * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %u\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemRangeGetAttributes
		case HIP_API_ID_hipMemRangeGetAttributes : {
			//	void ** data (void **);
			//	size_t * data_sizes (unsigned long*);
			//	hipMemRangeAttribute * attributes (enum hipMemRangeAttribute*);
			//	size_t num_attributes (unsigned long);
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemRangeGetAttributes_t* args = (args_hipMemRangeGetAttributes_t*) func_args;
			printf("\tvoid ** data = %p", args->data);
			if (args->data != NULL) {
				printf("-> %p", args->data__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * data_sizes = %p", args->data_sizes);
			if (args->data_sizes != NULL) {
				printf(" -> %lu\n", args->data_sizes__ref.val);
			} else { printf("\n"); };
			printf("\thipMemRangeAttribute * attributes = %p", args->attributes);
			if (args->attributes != NULL) {
				printf(" -> %d\n", args->attributes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t num_attributes = %lu\n", args->num_attributes);
			printf("\tconst void * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDestroyExternalSemaphore
		case HIP_API_ID_hipDestroyExternalSemaphore : {
			//	hipExternalSemaphore_t extSem (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipDestroyExternalSemaphore_t* args = (args_hipDestroyExternalSemaphore_t*) func_args;
			printf("\thipExternalSemaphore_t extSem = %p", args->extSem);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipIpcOpenEventHandle
		case HIP_API_ID_hipIpcOpenEventHandle : {
			//	hipEvent_t * event (struct ihipEvent_t **);
			//	hipIpcEventHandle_t handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipIpcOpenEventHandle_t* args = (args_hipIpcOpenEventHandle_t*) func_args;
			printf("\thipEvent_t * event = %p", args->event);
			if (args->event != NULL) {
				printf(" -> %p\n", args->event__ref.val);
			} else { printf("\n"); };
			printf("\thipIpcEventHandle_t handle = {\n");
			printf("\t\tchar[64] reserved = %c\n", args->handle.reserved[0]);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphUpload
		case HIP_API_ID_hipGraphUpload : {
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphUpload_t* args = (args_hipGraphUpload_t*) func_args;
			printf("\thipGraphExec_t graphExec = %p", args->graphExec);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocAsync
		case HIP_API_ID_hipMallocAsync : {
			//	void ** dev_ptr (void **);
			//	size_t size (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocAsync_t* args = (args_hipMallocAsync_t*) func_args;
			printf("\tvoid ** dev_ptr = %p", args->dev_ptr);
			if (args->dev_ptr != NULL) {
				printf("-> %p", args->dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipOccupancyMaxPotentialBlockSize
		case HIP_API_ID_hipOccupancyMaxPotentialBlockSize : {
			//	int * gridSize (int *);
			//	int * blockSize (int *);
			//	const void * f (const void *);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	int blockSizeLimit (int);
			//	hipError_t retval (enum hipError_t);
			args_hipOccupancyMaxPotentialBlockSize_t* args = (args_hipOccupancyMaxPotentialBlockSize_t*) func_args;
			printf("\tint * gridSize = %p", args->gridSize);
			if (args->gridSize != NULL) {
				printf(" -> %d\n", args->gridSize__ref.val);
			} else { printf("\n"); };
			printf("\tint * blockSize = %p", args->blockSize);
			if (args->blockSize != NULL) {
				printf(" -> %d\n", args->blockSize__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * f = %p", args->f);
			printf("\n");
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\tint blockSizeLimit = %d\n", args->blockSizeLimit);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDestroyExternalMemory
		case HIP_API_ID_hipDestroyExternalMemory : {
			//	hipExternalMemory_t extMem (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipDestroyExternalMemory_t* args = (args_hipDestroyExternalMemory_t*) func_args;
			printf("\thipExternalMemory_t extMem = %p", args->extMem);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_amd_dbgapi_get_build_name
		case HIP_API_ID_amd_dbgapi_get_build_name : {
			//	const char * retval (const char *);
			args_amd_dbgapi_get_build_name_t* args = (args_amd_dbgapi_get_build_name_t*) func_args;
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemcpyNodeToSymbol
		case HIP_API_ID_hipGraphAddMemcpyNodeToSymbol : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemcpyNodeToSymbol_t* args = (args_hipGraphAddMemcpyNodeToSymbol_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetPCIBusId
		case HIP_API_ID_hipDeviceGetPCIBusId : {
			//	char * pciBusId (char *);
			//	int len (int);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetPCIBusId_t* args = (args_hipDeviceGetPCIBusId_t*) func_args;
			printf("\tchar * pciBusId = %p", args->pciBusId);
			if (args->pciBusId != NULL) {
				printf(" -> %s\n", args->pciBusId__ref.val);
			} else { printf("\n"); };
			printf("\tint len = %d\n", args->len);
			printf("\tint device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetChannelDesc
		case HIP_API_ID_hipGetChannelDesc : {
			//	hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipArray_const_t array (const struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetChannelDesc_t* args = (args_hipGetChannelDesc_t*) func_args;
			printf("\thipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_const_t array = %p", args->array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDevicePrimaryCtxReset
		case HIP_API_ID_hipDevicePrimaryCtxReset : {
			//	hipDevice_t dev (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDevicePrimaryCtxReset_t* args = (args_hipDevicePrimaryCtxReset_t*) func_args;
			printf("\thipDevice_t dev = %d\n", args->dev);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipImportExternalMemory
		case HIP_API_ID_hipImportExternalMemory : {
			//	hipExternalMemory_t * extMem_out (void **);
			//	const hipExternalMemoryHandleDesc * memHandleDesc ({
			//		hipExternalMemoryHandleType type (enum hipExternalMemoryHandleType_enum);
			//		union (unnamed union at header/hip/hip.h:1445:2) handle ({
			//		});
			//		unsigned long long size (unsigned long long);
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipImportExternalMemory_t* args = (args_hipImportExternalMemory_t*) func_args;
			printf("\thipExternalMemory_t * extMem_out = %p", args->extMem_out);
			if (args->extMem_out != NULL) {
				printf("-> %p", args->extMem_out__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalMemoryHandleDesc * memHandleDesc = %p", args->memHandleDesc);
			if (args->memHandleDesc != NULL) {
				printf(" -> {\n");
				printf("\t\thipExternalMemoryHandleType type = %d\n", args->memHandleDesc__ref.val.type);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1445:2) handle = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned long long size = %llu\n", args->memHandleDesc__ref.val.size);
				printf("\t\tunsigned int flags = %u\n", args->memHandleDesc__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->memHandleDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFuncSetSharedMemConfig
		case HIP_API_ID_hipFuncSetSharedMemConfig : {
			//	const void * func (const void *);
			//	hipSharedMemConfig config (enum hipSharedMemConfig);
			//	hipError_t retval (enum hipError_t);
			args_hipFuncSetSharedMemConfig_t* args = (args_hipFuncSetSharedMemConfig_t*) func_args;
			printf("\tconst void * func = %p", args->func);
			printf("\n");
			printf("\thipSharedMemConfig config = %d\n", args->config);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamWaitEvent
		case HIP_API_ID_hipStreamWaitEvent : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamWaitEvent_t* args = (args_hipStreamWaitEvent_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetMipmapLevelBias
		case HIP_API_ID_hipTexRefSetMipmapLevelBias : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	float bias (float);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetMipmapLevelBias_t* args = (args_hipTexRefSetMipmapLevelBias_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tfloat bias = %f\n", args->bias);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolImportFromShareableHandle
		case HIP_API_ID_hipMemPoolImportFromShareableHandle : {
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	void * shared_handle (void *);
			//	hipMemAllocationHandleType handle_type (enum hipMemAllocationHandleType);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolImportFromShareableHandle_t* args = (args_hipMemPoolImportFromShareableHandle_t*) func_args;
			printf("\thipMemPool_t * mem_pool = %p", args->mem_pool);
			if (args->mem_pool != NULL) {
				printf(" -> %p\n", args->mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * shared_handle = %p", args->shared_handle);
			printf("\n");
			printf("\thipMemAllocationHandleType handle_type = %d\n", args->handle_type);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolExportToShareableHandle
		case HIP_API_ID_hipMemPoolExportToShareableHandle : {
			//	void * shared_handle (void *);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemAllocationHandleType handle_type (enum hipMemAllocationHandleType);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolExportToShareableHandle_t* args = (args_hipMemPoolExportToShareableHandle_t*) func_args;
			printf("\tvoid * shared_handle = %p", args->shared_handle);
			printf("\n");
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipMemAllocationHandleType handle_type = %d\n", args->handle_type);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParamsToSymbol
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParamsToSymbol : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecMemcpyNodeSetParamsToSymbol_t* args = (args_hipGraphExecMemcpyNodeSetParamsToSymbol_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetMipmapFilterMode
		case HIP_API_ID_hipTexRefGetMipmapFilterMode : {
			//	enum hipTextureFilterMode * pfm (enum hipTextureFilterMode *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetMipmapFilterMode_t* args = (args_hipTexRefGetMipmapFilterMode_t*) func_args;
			printf("\tenum hipTextureFilterMode * pfm = %p", args->pfm);
			if (args->pfm != NULL) {
				printf(" -> %d\n", args->pfm__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetProcAddress
		case HIP_API_ID_hipGetProcAddress : {
			//	const char * symbol (const char *);
			//	void ** pfn (void **);
			//	int hipVersion (int);
			//	uint64_t flags (unsigned long);
			//	hipDriverProcAddressQueryResult * symbolStatus (enum hipDriverProcAddressQueryResult*);
			//	hipError_t retval (enum hipError_t);
			args_hipGetProcAddress_t* args = (args_hipGetProcAddress_t*) func_args;
			printf("\tconst char * symbol = %p", args->symbol);
			if (args->symbol != NULL) {
				printf(" -> %s\n", args->symbol__ref.val);
			} else { printf("\n"); };
			printf("\tvoid ** pfn = %p", args->pfn);
			if (args->pfn != NULL) {
				printf("-> %p", args->pfn__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tint hipVersion = %d\n", args->hipVersion);
			printf("\tuint64_t flags = %lu\n", args->flags);
			printf("\thipDriverProcAddressQueryResult * symbolStatus = %p", args->symbolStatus);
			if (args->symbolStatus != NULL) {
				printf(" -> %d\n", args->symbolStatus__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCreateTextureObject
		case HIP_API_ID_hipCreateTextureObject : {
			//	hipTextureObject_t * pTexObject (struct __hip_texture **);
			//	const hipResourceDesc * pResDesc ({
			//		enum hipResourceType resType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:612:2) res ({
			//		});
			//	});
			//	const hipTextureDesc * pTexDesc ({
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		int sRGB (int);
			//		float[4] borderColor (float[4]);
			//		int normalizedCoords (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//	});
			//	const struct hipResourceViewDesc * pResViewDesc ({
			//		enum hipResourceViewFormat format (enum hipResourceViewFormat);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipCreateTextureObject_t* args = (args_hipCreateTextureObject_t*) func_args;
			printf("\thipTextureObject_t * pTexObject = %p", args->pTexObject);
			if (args->pTexObject != NULL) {
				printf(" -> %p\n", args->pTexObject__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipResourceDesc * pResDesc = %p", args->pResDesc);
			if (args->pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceType resType = %d\n", args->pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:612:2) res = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst hipTextureDesc * pTexDesc = %p", args->pTexDesc);
			if (args->pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->pTexDesc__ref.val.addressMode[0]);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->pTexDesc__ref.val.filterMode);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->pTexDesc__ref.val.readMode);
				printf("\t\tint sRGB = %d\n", args->pTexDesc__ref.val.sRGB);
				printf("\t\tfloat[4] borderColor = %f\n", args->pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint normalizedCoords = %d\n", args->pTexDesc__ref.val.normalizedCoords);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst struct hipResourceViewDesc * pResViewDesc = %p", args->pResViewDesc);
			if (args->pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceViewFormat format = %d\n", args->pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->pResViewDesc__ref.val.lastLayer);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphKernelNodeCopyAttributes
		case HIP_API_ID_hipGraphKernelNodeCopyAttributes : {
			//	hipGraphNode_t hSrc (struct hipGraphNode *);
			//	hipGraphNode_t hDst (struct hipGraphNode *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphKernelNodeCopyAttributes_t* args = (args_hipGraphKernelNodeCopyAttributes_t*) func_args;
			printf("\thipGraphNode_t hSrc = %p", args->hSrc);
			printf("\n");
			printf("\thipGraphNode_t hDst = %p", args->hDst);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetFlags
		case HIP_API_ID_hipTexRefGetFlags : {
			//	unsigned int * pFlags (unsigned int *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetFlags_t* args = (args_hipTexRefGetFlags_t*) func_args;
			printf("\tunsigned int * pFlags = %p", args->pFlags);
			if (args->pFlags != NULL) {
				printf(" -> %u\n", args->pFlags__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvGraphAddMemcpyNode
		case HIP_API_ID_hipDrvGraphAddMemcpyNode : {
			//	hipGraphNode_t * phGraphNode (struct hipGraphNode **);
			//	hipGraph_t hGraph (struct ihipGraph *);
			//	const hipGraphNode_t * dependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const HIP_MEMCPY3D * copyParams ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		size_t srcZ (unsigned long);
			//		size_t srcLOD (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t srcHeight (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		size_t dstZ (unsigned long);
			//		size_t dstLOD (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t dstHeight (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//	});
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipDrvGraphAddMemcpyNode_t* args = (args_hipDrvGraphAddMemcpyNode_t*) func_args;
			printf("\thipGraphNode_t * phGraphNode = %p", args->phGraphNode);
			if (args->phGraphNode != NULL) {
				printf(" -> %p\n", args->phGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t hGraph = %p", args->hGraph);
			printf("\n");
			printf("\tconst hipGraphNode_t * dependencies = %p", args->dependencies);
			if (args->dependencies != NULL) {
				printf(" -> %p\n", args->dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst HIP_MEMCPY3D * copyParams = %p", args->copyParams);
			if (args->copyParams != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->copyParams__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->copyParams__ref.val.srcY);
				printf("\t\tsize_t srcZ = %lu\n", args->copyParams__ref.val.srcZ);
				printf("\t\tsize_t srcLOD = %lu\n", args->copyParams__ref.val.srcLOD);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->copyParams__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->copyParams__ref.val.srcPitch);
				printf("\t\tsize_t srcHeight = %lu\n", args->copyParams__ref.val.srcHeight);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->copyParams__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->copyParams__ref.val.dstY);
				printf("\t\tsize_t dstZ = %lu\n", args->copyParams__ref.val.dstZ);
				printf("\t\tsize_t dstLOD = %lu\n", args->copyParams__ref.val.dstLOD);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->copyParams__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->copyParams__ref.val.dstPitch);
				printf("\t\tsize_t dstHeight = %lu\n", args->copyParams__ref.val.dstHeight);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->copyParams__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->copyParams__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->copyParams__ref.val.Depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipCtx_t ctx = %p", args->ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemExportToShareableHandle
		case HIP_API_ID_hipMemExportToShareableHandle : {
			//	void * shareableHandle (void *);
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	hipMemAllocationHandleType handleType (enum hipMemAllocationHandleType);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemExportToShareableHandle_t* args = (args_hipMemExportToShareableHandle_t*) func_args;
			printf("\tvoid * shareableHandle = %p", args->shareableHandle);
			printf("\n");
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->handle);
			printf("\n");
			printf("\thipMemAllocationHandleType handleType = %d\n", args->handleType);
			printf("\tunsigned long long flags = %llu\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphLaunch_spt
		case HIP_API_ID_hipGraphLaunch_spt : {
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphLaunch_spt_t* args = (args_hipGraphLaunch_spt_t*) func_args;
			printf("\thipGraphExec_t graphExec = %p", args->graphExec);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemcpyNodeSetParamsFromSymbol
		case HIP_API_ID_hipGraphMemcpyNodeSetParamsFromSymbol : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemcpyNodeSetParamsFromSymbol_t* args = (args_hipGraphMemcpyNodeSetParamsFromSymbol_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphNodeGetDependencies
		case HIP_API_ID_hipGraphNodeGetDependencies : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraphNode_t * pDependencies (struct hipGraphNode **);
			//	size_t * pNumDependencies (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphNodeGetDependencies_t* args = (args_hipGraphNodeGetDependencies_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * pNumDependencies = %p", args->pNumDependencies);
			if (args->pNumDependencies != NULL) {
				printf(" -> %lu\n", args->pNumDependencies__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy3D
		case HIP_API_ID_hipMemcpy3D : {
			//	const struct hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy3D_t* args = (args_hipMemcpy3D_t*) func_args;
			printf("\tconst struct hipMemcpy3DParms * p = %p", args->p);
			if (args->p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemcpyNodeFromSymbol
		case HIP_API_ID_hipGraphAddMemcpyNodeFromSymbol : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemcpyNodeFromSymbol_t* args = (args_hipGraphAddMemcpyNodeFromSymbol_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetPriority_spt
		case HIP_API_ID_hipStreamGetPriority_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	int * priority (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetPriority_spt_t* args = (args_hipStreamGetPriority_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tint * priority = %p", args->priority);
			if (args->priority != NULL) {
				printf(" -> %d\n", args->priority__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleLoadData
		case HIP_API_ID_hipModuleLoadData : {
			//	hipModule_t * module (struct ihipModule_t **);
			//	const void * image (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleLoadData_t* args = (args_hipModuleLoadData_t*) func_args;
			printf("\thipModule_t * module = %p", args->module);
			if (args->module != NULL) {
				printf(" -> %p\n", args->module__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * image = %p", args->image);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipSetDeviceFlags
		case HIP_API_ID_hipSetDeviceFlags : {
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipSetDeviceFlags_t* args = (args_hipSetDeviceFlags_t*) func_args;
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExternalMemoryGetMappedBuffer
		case HIP_API_ID_hipExternalMemoryGetMappedBuffer : {
			//	void ** devPtr (void **);
			//	hipExternalMemory_t extMem (void *);
			//	const hipExternalMemoryBufferDesc * bufferDesc ({
			//		unsigned long long offset (unsigned long long);
			//		unsigned long long size (unsigned long long);
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipExternalMemoryGetMappedBuffer_t* args = (args_hipExternalMemoryGetMappedBuffer_t*) func_args;
			printf("\tvoid ** devPtr = %p", args->devPtr);
			if (args->devPtr != NULL) {
				printf("-> %p", args->devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipExternalMemory_t extMem = %p", args->extMem);
			printf("\n");
			printf("\tconst hipExternalMemoryBufferDesc * bufferDesc = %p", args->bufferDesc);
			if (args->bufferDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned long long offset = %llu\n", args->bufferDesc__ref.val.offset);
				printf("\t\tunsigned long long size = %llu\n", args->bufferDesc__ref.val.size);
				printf("\t\tunsigned int flags = %u\n", args->bufferDesc__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->bufferDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchCooperativeKernel_spt
		case HIP_API_ID_hipLaunchCooperativeKernel_spt : {
			//	const void * f (const void *);
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** kernelParams (void **);
			//	uint32_t sharedMemBytes (unsigned int);
			//	hipStream_t hStream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchCooperativeKernel_spt_t* args = (args_hipLaunchCooperativeKernel_spt_t*) func_args;
			printf("\tconst void * f = %p", args->f);
			printf("\n");
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->blockDim.x);
			printf("\t\tuint32_t y = %u\n", args->blockDim.y);
			printf("\t\tuint32_t z = %u\n", args->blockDim.z);
			printf("\t}\n");
			printf("\tvoid ** kernelParams = %p", args->kernelParams);
			if (args->kernelParams != NULL) {
				printf("-> %p", args->kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tuint32_t sharedMemBytes = %u\n", args->sharedMemBytes);
			printf("\thipStream_t hStream = %p", args->hStream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipLaunchHostFunc
		case HIP_API_ID_hipLaunchHostFunc : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipHostFn_t fn (void (*)(void *));
			//	void * userData (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchHostFunc_t* args = (args_hipLaunchHostFunc_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipHostFn_t fn = %p\n", args->fn);
			printf("\tvoid * userData = %p", args->userData);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyAsync_spt
		case HIP_API_ID_hipMemcpyAsync_spt : {
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyAsync_spt_t* args = (args_hipMemcpyAsync_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyPeer
		case HIP_API_ID_hipMemcpyPeer : {
			//	void * dst (void *);
			//	int dstDeviceId (int);
			//	const void * src (const void *);
			//	int srcDeviceId (int);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyPeer_t* args = (args_hipMemcpyPeer_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tint dstDeviceId = %d\n", args->dstDeviceId);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tint srcDeviceId = %d\n", args->srcDeviceId);
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceReset
		case HIP_API_ID_hipDeviceReset : {
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceReset_t* args = (args_hipDeviceReset_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemAddressFree
		case HIP_API_ID_hipMemAddressFree : {
			//	void * devPtr (void *);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemAddressFree_t* args = (args_hipMemAddressFree_t*) func_args;
			printf("\tvoid * devPtr = %p", args->devPtr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipProfilerStop
		case HIP_API_ID_hipProfilerStop : {
			//	hipError_t retval (enum hipError_t);
			args_hipProfilerStop_t* args = (args_hipProfilerStop_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphEventWaitNodeSetEvent
		case HIP_API_ID_hipGraphEventWaitNodeSetEvent : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphEventWaitNodeSetEvent_t* args = (args_hipGraphEventWaitNodeSetEvent_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleLaunchCooperativeKernel
		case HIP_API_ID_hipModuleLaunchCooperativeKernel : {
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	unsigned int gridDimX (unsigned int);
			//	unsigned int gridDimY (unsigned int);
			//	unsigned int gridDimZ (unsigned int);
			//	unsigned int blockDimX (unsigned int);
			//	unsigned int blockDimY (unsigned int);
			//	unsigned int blockDimZ (unsigned int);
			//	unsigned int sharedMemBytes (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	void ** kernelParams (void **);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleLaunchCooperativeKernel_t* args = (args_hipModuleLaunchCooperativeKernel_t*) func_args;
			printf("\thipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tunsigned int gridDimX = %u\n", args->gridDimX);
			printf("\tunsigned int gridDimY = %u\n", args->gridDimY);
			printf("\tunsigned int gridDimZ = %u\n", args->gridDimZ);
			printf("\tunsigned int blockDimX = %u\n", args->blockDimX);
			printf("\tunsigned int blockDimY = %u\n", args->blockDimY);
			printf("\tunsigned int blockDimZ = %u\n", args->blockDimZ);
			printf("\tunsigned int sharedMemBytes = %u\n", args->sharedMemBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid ** kernelParams = %p", args->kernelParams);
			if (args->kernelParams != NULL) {
				printf("-> %p", args->kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetName
		case HIP_API_ID_hipDeviceGetName : {
			//	char * name (char *);
			//	int len (int);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetName_t* args = (args_hipDeviceGetName_t*) func_args;
			printf("\tchar * name = %p", args->name);
			if (args->name != NULL) {
				printf(" -> %s\n", args->name__ref.val);
			} else { printf("\n"); };
			printf("\tint len = %d\n", args->len);
			printf("\thipDevice_t device = %d\n", args->device);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphNodeSetEnabled
		case HIP_API_ID_hipGraphNodeSetEnabled : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	unsigned int isEnabled (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphNodeSetEnabled_t* args = (args_hipGraphNodeSetEnabled_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\tunsigned int isEnabled = %u\n", args->isEnabled);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetAddressMode
		case HIP_API_ID_hipTexRefSetAddressMode : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	int dim (int);
			//	enum hipTextureAddressMode am (enum hipTextureAddressMode);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetAddressMode_t* args = (args_hipTexRefSetAddressMode_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint dim = %d\n", args->dim);
			printf("\tenum hipTextureAddressMode am = %d\n", args->am);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventSynchronize
		case HIP_API_ID_hipEventSynchronize : {
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipEventSynchronize_t* args = (args_hipEventSynchronize_t*) func_args;
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphGetRootNodes
		case HIP_API_ID_hipGraphGetRootNodes : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * pRootNodes (struct hipGraphNode **);
			//	size_t * pNumRootNodes (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphGetRootNodes_t* args = (args_hipGraphGetRootNodes_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipGraphNode_t * pRootNodes = %p", args->pRootNodes);
			if (args->pRootNodes != NULL) {
				printf(" -> %p\n", args->pRootNodes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * pNumRootNodes = %p", args->pNumRootNodes);
			if (args->pNumRootNodes != NULL) {
				printf(" -> %lu\n", args->pNumRootNodes__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DFromArray
		case HIP_API_ID_hipMemcpy2DFromArray : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DFromArray_t* args = (args_hipMemcpy2DFromArray_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\thipArray_const_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExternalSemaphoresWaitNodeSetParams
		case HIP_API_ID_hipGraphExternalSemaphoresWaitNodeSetParams : {
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreWaitNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExternalSemaphoresWaitNodeSetParams_t* args = (args_hipGraphExternalSemaphoresWaitNodeSetParams_t*) func_args;
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreWaitNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyDtoA
		case HIP_API_ID_hipMemcpyDtoA : {
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	hipDeviceptr_t srcDevice (void *);
			//	size_t ByteCount (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyDtoA_t* args = (args_hipMemcpyDtoA_t*) func_args;
			printf("\thipArray_t dstArray = %p", args->dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->dstOffset);
			printf("\thipDeviceptr_t srcDevice = %p", args->srcDevice);
			printf("\n");
			printf("\tsize_t ByteCount = %lu\n", args->ByteCount);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemcpyNodeGetParams
		case HIP_API_ID_hipGraphMemcpyNodeGetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemcpy3DParms * pNodeParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemcpyNodeGetParams_t* args = (args_hipGraphMemcpyNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipMemcpy3DParms * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pNodeParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pNodeParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pNodeParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pNodeParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pNodeParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pNodeParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pNodeParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pNodeParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pNodeParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pNodeParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->pNodeParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->pNodeParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->pNodeParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->pNodeParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy
		case HIP_API_ID_hipMemcpy : {
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy_t* args = (args_hipMemcpy_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipSetValidDevices
		case HIP_API_ID_hipSetValidDevices : {
			//	int * device_arr (int *);
			//	int len (int);
			//	hipError_t retval (enum hipError_t);
			args_hipSetValidDevices_t* args = (args_hipSetValidDevices_t*) func_args;
			printf("\tint * device_arr = %p", args->device_arr);
			if (args->device_arr != NULL) {
				printf(" -> %d\n", args->device_arr__ref.val);
			} else { printf("\n"); };
			printf("\tint len = %d\n", args->len);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DAsync
		case HIP_API_ID_hipMemcpy2DAsync : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DAsync_t* args = (args_hipMemcpy2DAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecExternalSemaphoresWaitNodeSetParams
		case HIP_API_ID_hipGraphExecExternalSemaphoresWaitNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreWaitNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecExternalSemaphoresWaitNodeSetParams_t* args = (args_hipGraphExecExternalSemaphoresWaitNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreWaitNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamAttachMemAsync
		case HIP_API_ID_hipStreamAttachMemAsync : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * dev_ptr (void *);
			//	size_t length (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamAttachMemAsync_t* args = (args_hipStreamAttachMemAsync_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\tsize_t length = %lu\n", args->length);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset2DAsync
		case HIP_API_ID_hipMemset2DAsync : {
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset2DAsync_t* args = (args_hipMemset2DAsync_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->pitch);
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexObjectGetResourceViewDesc
		case HIP_API_ID_hipTexObjectGetResourceViewDesc : {
			//	HIP_RESOURCE_VIEW_DESC * pResViewDesc ({
			//		HIPresourceViewFormat format (enum HIPresourceViewFormat_enum);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipTexObjectGetResourceViewDesc_t* args = (args_hipTexObjectGetResourceViewDesc_t*) func_args;
			printf("\tHIP_RESOURCE_VIEW_DESC * pResViewDesc = %p", args->pResViewDesc);
			if (args->pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourceViewFormat format = %d\n", args->pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->pResViewDesc__ref.val.lastLayer);
				printf("\t\tunsigned int[16] reserved = %u\n", args->pResViewDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t texObject = %p", args->texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventCreateWithFlags
		case HIP_API_ID_hipEventCreateWithFlags : {
			//	hipEvent_t * event (struct ihipEvent_t **);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipEventCreateWithFlags_t* args = (args_hipEventCreateWithFlags_t*) func_args;
			printf("\thipEvent_t * event = %p", args->event);
			if (args->event != NULL) {
				printf(" -> %p\n", args->event__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMipmappedArrayCreate
		case HIP_API_ID_hipMipmappedArrayCreate : {
			//	hipMipmappedArray_t * pHandle ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	HIP_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//		unsigned int Flags (unsigned int);
			//	});
			//	unsigned int numMipmapLevels (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMipmappedArrayCreate_t* args = (args_hipMipmappedArrayCreate_t*) func_args;
			printf("\thipMipmappedArray_t * pHandle = %p", args->pHandle);
			if (args->pHandle != NULL) {
				printf("-> %p", args->pHandle__ref.ptr1);
				if (args->pHandle__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->pHandle__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->pHandle__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->pHandle__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->pHandle__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->pHandle__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->pHandle__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->pHandle__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->pHandle__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->pHandle__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->pHandle__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->pHandle__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->pHandle__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->pHandle__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->pHandle__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tHIP_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc = %p", args->pMipmappedArrayDesc);
			if (args->pMipmappedArrayDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->pMipmappedArrayDesc__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->pMipmappedArrayDesc__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->pMipmappedArrayDesc__ref.val.Depth);
				printf("\t\tenum hipArray_Format Format = %d\n", args->pMipmappedArrayDesc__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->pMipmappedArrayDesc__ref.val.NumChannels);
				printf("\t\tunsigned int Flags = %u\n", args->pMipmappedArrayDesc__ref.val.Flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numMipmapLevels = %u\n", args->numMipmapLevels);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2D_spt
		case HIP_API_ID_hipMemcpy2D_spt : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2D_spt_t* args = (args_hipMemcpy2D_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemcpyNode
		case HIP_API_ID_hipGraphAddMemcpyNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipMemcpy3DParms * pCopyParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemcpyNode_t* args = (args_hipGraphAddMemcpyNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst hipMemcpy3DParms * pCopyParams = %p", args->pCopyParams);
			if (args->pCopyParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pCopyParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pCopyParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pCopyParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pCopyParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pCopyParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pCopyParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pCopyParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pCopyParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pCopyParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pCopyParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pCopyParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pCopyParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->pCopyParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->pCopyParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->pCopyParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->pCopyParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyToSymbolAsync
		case HIP_API_ID_hipMemcpyToSymbolAsync : {
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyToSymbolAsync_t* args = (args_hipMemcpyToSymbolAsync_t*) func_args;
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocFromPoolAsync
		case HIP_API_ID_hipMallocFromPoolAsync : {
			//	void ** dev_ptr (void **);
			//	size_t size (unsigned long);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocFromPoolAsync_t* args = (args_hipMallocFromPoolAsync_t*) func_args;
			printf("\tvoid ** dev_ptr = %p", args->dev_ptr);
			if (args->dev_ptr != NULL) {
				printf("-> %p", args->dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
		case HIP_API_ID_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags : {
			//	int * numBlocks (int *);
			//	const void * f (const void *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_t* args = (args_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags_t*) func_args;
			printf("\tint * numBlocks = %p", args->numBlocks);
			if (args->numBlocks != NULL) {
				printf(" -> %d\n", args->numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * f = %p", args->f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemFreeNode
		case HIP_API_ID_hipGraphAddMemFreeNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	void * dev_ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemFreeNode_t* args = (args_hipGraphAddMemFreeNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tvoid * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor
		case HIP_API_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor : {
			//	int * numBlocks (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_t* args = (args_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor_t*) func_args;
			printf("\tint * numBlocks = %p", args->numBlocks);
			if (args->numBlocks != NULL) {
				printf(" -> %d\n", args->numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->dynSharedMemPerBlk);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventDestroy
		case HIP_API_ID_hipEventDestroy : {
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipEventDestroy_t* args = (args_hipEventDestroy_t*) func_args;
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceSetCacheConfig
		case HIP_API_ID_hipDeviceSetCacheConfig : {
			//	hipFuncCache_t cacheConfig (enum hipFuncCache_t);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceSetCacheConfig_t* args = (args_hipDeviceSetCacheConfig_t*) func_args;
			printf("\thipFuncCache_t cacheConfig = %d\n", args->cacheConfig);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFree
		case HIP_API_ID_hipFree : {
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipFree_t* args = (args_hipFree_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DToArrayAsync_spt
		case HIP_API_ID_hipMemcpy2DToArrayAsync_spt : {
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DToArrayAsync_spt_t* args = (args_hipMemcpy2DToArrayAsync_spt_t*) func_args;
			printf("\thipArray_t dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxGetFlags
		case HIP_API_ID_hipCtxGetFlags : {
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxGetFlags_t* args = (args_hipCtxGetFlags_t*) func_args;
			printf("\tunsigned int * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %u\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetSymbolAddress
		case HIP_API_ID_hipGetSymbolAddress : {
			//	void ** devPtr (void **);
			//	const void * symbol (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetSymbolAddress_t* args = (args_hipGetSymbolAddress_t*) func_args;
			printf("\tvoid ** devPtr = %p", args->devPtr);
			if (args->devPtr != NULL) {
				printf("-> %p", args->devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetAddress
		case HIP_API_ID_hipTexRefGetAddress : {
			//	hipDeviceptr_t * dev_ptr (void **);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetAddress_t* args = (args_hipTexRefGetAddress_t*) func_args;
			printf("\thipDeviceptr_t * dev_ptr = %p", args->dev_ptr);
			if (args->dev_ptr != NULL) {
				printf("-> %p", args->dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexObjectCreate
		case HIP_API_ID_hipTexObjectCreate : {
			//	hipTextureObject_t * pTexObject (struct __hip_texture **);
			//	const HIP_RESOURCE_DESC * pResDesc ({
			//		HIPresourcetype resType (enum HIPresourcetype_enum);
			//		union (unnamed union at header/hip/hip.h:635:2) res ({
			//		});
			//		unsigned int flags (unsigned int);
			//	});
			//	const HIP_TEXTURE_DESC * pTexDesc ({
			//		HIPaddress_mode[3] addressMode (enum HIPaddress_mode_enum[3]);
			//		HIPfilter_mode filterMode (enum HIPfilter_mode_enum);
			//		unsigned int flags (unsigned int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		HIPfilter_mode mipmapFilterMode (enum HIPfilter_mode_enum);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		float[4] borderColor (float[4]);
			//		int[12] reserved (int[12]);
			//	});
			//	const HIP_RESOURCE_VIEW_DESC * pResViewDesc ({
			//		HIPresourceViewFormat format (enum HIPresourceViewFormat_enum);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexObjectCreate_t* args = (args_hipTexObjectCreate_t*) func_args;
			printf("\thipTextureObject_t * pTexObject = %p", args->pTexObject);
			if (args->pTexObject != NULL) {
				printf(" -> %p\n", args->pTexObject__ref.val);
			} else { printf("\n"); };
			printf("\tconst HIP_RESOURCE_DESC * pResDesc = %p", args->pResDesc);
			if (args->pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourcetype resType = %d\n", args->pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:635:2) res = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->pResDesc__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst HIP_TEXTURE_DESC * pTexDesc = %p", args->pTexDesc);
			if (args->pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPaddress_mode[3] addressMode = %d\n", args->pTexDesc__ref.val.addressMode[0]);
				printf("\t\tHIPfilter_mode filterMode = %d\n", args->pTexDesc__ref.val.filterMode);
				printf("\t\tunsigned int flags = %u\n", args->pTexDesc__ref.val.flags);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tHIPfilter_mode mipmapFilterMode = %d\n", args->pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t\tfloat[4] borderColor = %f\n", args->pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint[12] reserved = %d\n", args->pTexDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst HIP_RESOURCE_VIEW_DESC * pResViewDesc = %p", args->pResViewDesc);
			if (args->pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourceViewFormat format = %d\n", args->pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->pResViewDesc__ref.val.lastLayer);
				printf("\t\tunsigned int[16] reserved = %u\n", args->pResViewDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetSharedMemConfig
		case HIP_API_ID_hipDeviceGetSharedMemConfig : {
			//	hipSharedMemConfig * pConfig (enum hipSharedMemConfig*);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetSharedMemConfig_t* args = (args_hipDeviceGetSharedMemConfig_t*) func_args;
			printf("\thipSharedMemConfig * pConfig = %p", args->pConfig);
			if (args->pConfig != NULL) {
				printf(" -> %d\n", args->pConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyHtoAAsync
		case HIP_API_ID_hipMemcpyHtoAAsync : {
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	const void * srcHost (const void *);
			//	size_t ByteCount (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyHtoAAsync_t* args = (args_hipMemcpyHtoAAsync_t*) func_args;
			printf("\thipArray_t dstArray = %p", args->dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->dstOffset);
			printf("\tconst void * srcHost = %p", args->srcHost);
			printf("\n");
			printf("\tsize_t ByteCount = %lu\n", args->ByteCount);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolGetAttribute
		case HIP_API_ID_hipMemPoolGetAttribute : {
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemPoolAttr attr (enum hipMemPoolAttr);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolGetAttribute_t* args = (args_hipMemPoolGetAttribute_t*) func_args;
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipMemPoolAttr attr = %d\n", args->attr);
			printf("\tvoid * value = %p", args->value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddMemAllocNode
		case HIP_API_ID_hipGraphAddMemAllocNode : {
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipMemAllocNodeParams * pNodeParams ({
			//		hipMemPoolProps poolProps ({
			//			hipMemAllocationType allocType (enum hipMemAllocationType);
			//			hipMemAllocationHandleType handleTypes (enum hipMemAllocationHandleType);
			//			hipMemLocation location ({
			//				hipMemLocationType type (enum hipMemLocationType);
			//				int id (int);
			//			});
			//			void * win32SecurityAttributes (void *);
			//			size_t maxSize (unsigned long);
			//			unsigned char[56] reserved (unsigned char[56]);
			//		});
			//		size_t accessDescCount (unsigned long);
			//		size_t bytesize (unsigned long);
			//		void * dptr (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddMemAllocNode_t* args = (args_hipGraphAddMemAllocNode_t*) func_args;
			printf("\thipGraphNode_t * pGraphNode = %p", args->pGraphNode);
			if (args->pGraphNode != NULL) {
				printf(" -> %p\n", args->pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->pDependencies);
			if (args->pDependencies != NULL) {
				printf(" -> %p\n", args->pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipMemAllocNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemPoolProps poolProps = {\n");
				printf("\t\t\thipMemAllocationType allocType = %d\n", args->pNodeParams__ref.val.poolProps.allocType);
				printf("\t\t\thipMemAllocationHandleType handleTypes = %d\n", args->pNodeParams__ref.val.poolProps.handleTypes);
				printf("\t\t\thipMemLocation location = {\n");
				printf("\t\t\t\thipMemLocationType type = %d\n", args->pNodeParams__ref.val.poolProps.location.type);
				printf("\t\t\t\tint id = %d\n", args->pNodeParams__ref.val.poolProps.location.id);
				printf("\t\t\t}\n");
				printf("\t\t\tsize_t maxSize = %lu\n", args->pNodeParams__ref.val.poolProps.maxSize);
				printf("\t\t\tunsigned char[56] reserved = %hhu\n", args->pNodeParams__ref.val.poolProps.reserved[0]);
				printf("\t\t}\n");
				printf("\t\tsize_t accessDescCount = %lu\n", args->pNodeParams__ref.val.accessDescCount);
				printf("\t\tsize_t bytesize = %lu\n", args->pNodeParams__ref.val.bytesize);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemRetainAllocationHandle
		case HIP_API_ID_hipMemRetainAllocationHandle : {
			//	hipMemGenericAllocationHandle_t * handle (struct ihipMemGenericAllocationHandle **);
			//	void * addr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemRetainAllocationHandle_t* args = (args_hipMemRetainAllocationHandle_t*) func_args;
			printf("\thipMemGenericAllocationHandle_t * handle = %p", args->handle);
			if (args->handle != NULL) {
				printf(" -> %p\n", args->handle__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * addr = %p", args->addr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetFuncBySymbol
		case HIP_API_ID_hipGetFuncBySymbol : {
			//	hipFunction_t * functionPtr (struct ihipModuleSymbol_t **);
			//	const void * symbolPtr (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetFuncBySymbol_t* args = (args_hipGetFuncBySymbol_t*) func_args;
			printf("\thipFunction_t * functionPtr = %p", args->functionPtr);
			if (args->functionPtr != NULL) {
				printf(" -> %p\n", args->functionPtr__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * symbolPtr = %p", args->symbolPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceSetMemPool
		case HIP_API_ID_hipDeviceSetMemPool : {
			//	int device (int);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceSetMemPool_t* args = (args_hipDeviceSetMemPool_t*) func_args;
			printf("\tint device = %d\n", args->device);
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceSetLimit
		case HIP_API_ID_hipDeviceSetLimit : {
			//	enum hipLimit_t limit (enum hipLimit_t);
			//	size_t value (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceSetLimit_t* args = (args_hipDeviceSetLimit_t*) func_args;
			printf("\tenum hipLimit_t limit = %d\n", args->limit);
			printf("\tsize_t value = %lu\n", args->value);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemGetInfo
		case HIP_API_ID_hipMemGetInfo : {
			//	size_t * free (unsigned long*);
			//	size_t * total (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipMemGetInfo_t* args = (args_hipMemGetInfo_t*) func_args;
			printf("\tsize_t * free = %p", args->free);
			if (args->free != NULL) {
				printf(" -> %lu\n", args->free__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * total = %p", args->total);
			if (args->total != NULL) {
				printf(" -> %lu\n", args->total__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyParam2D
		case HIP_API_ID_hipMemcpyParam2D : {
			//	const hip_Memcpy2D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyParam2D_t* args = (args_hipMemcpyParam2D_t*) func_args;
			printf("\tconst hip_Memcpy2D * pCopy = %p", args->pCopy);
			if (args->pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->pCopy__ref.val.srcY);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->pCopy__ref.val.srcPitch);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->pCopy__ref.val.dstY);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->pCopy__ref.val.dstPitch);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->pCopy__ref.val.Height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphDebugDotPrint
		case HIP_API_ID_hipGraphDebugDotPrint : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	const char * path (const char *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphDebugDotPrint_t* args = (args_hipGraphDebugDotPrint_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst char * path = %p", args->path);
			if (args->path != NULL) {
				printf(" -> %s\n", args->path__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceSetGraphMemAttribute
		case HIP_API_ID_hipDeviceSetGraphMemAttribute : {
			//	int device (int);
			//	hipGraphMemAttributeType attr (enum hipGraphMemAttributeType);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceSetGraphMemAttribute_t* args = (args_hipDeviceSetGraphMemAttribute_t*) func_args;
			printf("\tint device = %d\n", args->device);
			printf("\thipGraphMemAttributeType attr = %d\n", args->attr);
			printf("\tvoid * value = %p", args->value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvGetErrorString
		case HIP_API_ID_hipDrvGetErrorString : {
			//	hipError_t hipError (enum hipError_t);
			//	const char ** errorString (const char **);
			//	hipError_t retval (enum hipError_t);
			args_hipDrvGetErrorString_t* args = (args_hipDrvGetErrorString_t*) func_args;
			printf("\thipError_t hipError = %d\n", args->hipError);
			printf("\tconst char ** errorString = %p", args->errorString);
			if (args->errorString != NULL) {
				printf("-> %p", args->errorString__ref.ptr1);
				if (args->errorString__ref.ptr1 != NULL) {
					printf(" -> %s\n", args->errorString__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyDtoDAsync
		case HIP_API_ID_hipMemcpyDtoDAsync : {
			//	hipDeviceptr_t dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyDtoDAsync_t* args = (args_hipMemcpyDtoDAsync_t*) func_args;
			printf("\thipDeviceptr_t dst = %p", args->dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxSynchronize
		case HIP_API_ID_hipCtxSynchronize : {
			//	hipError_t retval (enum hipError_t);
			args_hipCtxSynchronize_t* args = (args_hipCtxSynchronize_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexObjectDestroy
		case HIP_API_ID_hipTexObjectDestroy : {
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipTexObjectDestroy_t* args = (args_hipTexObjectDestroy_t*) func_args;
			printf("\thipTextureObject_t texObject = %p", args->texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetAddressMode
		case HIP_API_ID_hipTexRefGetAddressMode : {
			//	enum hipTextureAddressMode * pam (enum hipTextureAddressMode *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	int dim (int);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetAddressMode_t* args = (args_hipTexRefGetAddressMode_t*) func_args;
			printf("\tenum hipTextureAddressMode * pam = %p", args->pam);
			if (args->pam != NULL) {
				printf(" -> %d\n", args->pam__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint dim = %d\n", args->dim);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE___hipGetPCH
		case HIP_API_ID___hipGetPCH : {
			//	const char ** pch (const char **);
			//	unsigned int * size (unsigned int *);
			args___hipGetPCH_t* args = (args___hipGetPCH_t*) func_args;
			printf("\tconst char ** pch = %p", args->pch);
			if (args->pch != NULL) {
				printf("-> %p", args->pch__ref.ptr1);
				if (args->pch__ref.ptr1 != NULL) {
					printf(" -> %s\n", args->pch__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tunsigned int * size = %p", args->size);
			if (args->size != NULL) {
				printf(" -> %u\n", args->size__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipStreamGetFlags
		case HIP_API_ID_hipStreamGetFlags : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetFlags_t* args = (args_hipStreamGetFlags_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tunsigned int * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %u\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemGetAccess
		case HIP_API_ID_hipMemGetAccess : {
			//	unsigned long long * flags (unsigned long long *);
			//	const hipMemLocation * location ({
			//		hipMemLocationType type (enum hipMemLocationType);
			//		int id (int);
			//	});
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemGetAccess_t* args = (args_hipMemGetAccess_t*) func_args;
			printf("\tunsigned long long * flags = %p", args->flags);
			if (args->flags != NULL) {
				printf(" -> %llu\n", args->flags__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipMemLocation * location = %p", args->location);
			if (args->location != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocationType type = %d\n", args->location__ref.val.type);
				printf("\t\tint id = %d\n", args->location__ref.val.id);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyAtoA
		case HIP_API_ID_hipMemcpyAtoA : {
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t ByteCount (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyAtoA_t* args = (args_hipMemcpyAtoA_t*) func_args;
			printf("\thipArray_t dstArray = %p", args->dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->dstOffset);
			printf("\thipArray_t srcArray = %p", args->srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->srcOffset);
			printf("\tsize_t ByteCount = %lu\n", args->ByteCount);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyToSymbol
		case HIP_API_ID_hipMemcpyToSymbol : {
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyToSymbol_t* args = (args_hipMemcpyToSymbol_t*) func_args;
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxSetCurrent
		case HIP_API_ID_hipCtxSetCurrent : {
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxSetCurrent_t* args = (args_hipCtxSetCurrent_t*) func_args;
			printf("\thipCtx_t ctx = %p", args->ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamQuery_spt
		case HIP_API_ID_hipStreamQuery_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamQuery_spt_t* args = (args_hipStreamQuery_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetSymbolSize
		case HIP_API_ID_hipGetSymbolSize : {
			//	size_t * size (unsigned long*);
			//	const void * symbol (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetSymbolSize_t* args = (args_hipGetSymbolSize_t*) func_args;
			printf("\tsize_t * size = %p", args->size);
			if (args->size != NULL) {
				printf(" -> %lu\n", args->size__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMipmappedArrayGetLevel
		case HIP_API_ID_hipMipmappedArrayGetLevel : {
			//	hipArray_t * pLevelArray (struct hipArray **);
			//	hipMipmappedArray_t hMipMappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	unsigned int level (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMipmappedArrayGetLevel_t* args = (args_hipMipmappedArrayGetLevel_t*) func_args;
			printf("\thipArray_t * pLevelArray = %p", args->pLevelArray);
			if (args->pLevelArray != NULL) {
				printf(" -> %p\n", args->pLevelArray__ref.val);
			} else { printf("\n"); };
			printf("\thipMipmappedArray_t hMipMappedArray = %p", args->hMipMappedArray);
			if (args->hMipMappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hMipMappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hMipMappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hMipMappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hMipMappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hMipMappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hMipMappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hMipMappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hMipMappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hMipMappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hMipMappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hMipMappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hMipMappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hMipMappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hMipMappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int level = %u\n", args->level);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExternalMemoryGetMappedMipmappedArray
		case HIP_API_ID_hipExternalMemoryGetMappedMipmappedArray : {
			//	hipMipmappedArray_t * mipmap ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	hipExternalMemory_t extMem (void *);
			//	const hipExternalMemoryMipmappedArrayDesc * mipmapDesc ({
			//		unsigned long long offset (unsigned long long);
			//		hipChannelFormatDesc formatDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int numLevels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipExternalMemoryGetMappedMipmappedArray_t* args = (args_hipExternalMemoryGetMappedMipmappedArray_t*) func_args;
			printf("\thipMipmappedArray_t * mipmap = %p", args->mipmap);
			if (args->mipmap != NULL) {
				printf("-> %p", args->mipmap__ref.ptr1);
				if (args->mipmap__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->mipmap__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->mipmap__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->mipmap__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->mipmap__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmap__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->mipmap__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->mipmap__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->mipmap__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->mipmap__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->mipmap__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->mipmap__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->mipmap__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->mipmap__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->mipmap__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipExternalMemory_t extMem = %p", args->extMem);
			printf("\n");
			printf("\tconst hipExternalMemoryMipmappedArrayDesc * mipmapDesc = %p", args->mipmapDesc);
			if (args->mipmapDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned long long offset = %llu\n", args->mipmapDesc__ref.val.offset);
				printf("\t\thipChannelFormatDesc formatDesc = {\n");
				printf("\t\t\tint x = %d\n", args->mipmapDesc__ref.val.formatDesc.x);
				printf("\t\t\tint y = %d\n", args->mipmapDesc__ref.val.formatDesc.y);
				printf("\t\t\tint z = %d\n", args->mipmapDesc__ref.val.formatDesc.z);
				printf("\t\t\tint w = %d\n", args->mipmapDesc__ref.val.formatDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmapDesc__ref.val.formatDesc.f);
				printf("\t\t}\n");
				printf("\t\thipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->mipmapDesc__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->mipmapDesc__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->mipmapDesc__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->mipmapDesc__ref.val.flags);
				printf("\t\tunsigned int numLevels = %u\n", args->mipmapDesc__ref.val.numLevels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParams
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemcpy3DParms * pNodeParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecMemcpyNodeSetParams_t* args = (args_hipGraphExecMemcpyNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipMemcpy3DParms * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pNodeParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pNodeParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pNodeParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pNodeParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pNodeParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pNodeParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pNodeParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pNodeParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pNodeParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pNodeParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->pNodeParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->pNodeParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->pNodeParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->pNodeParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipUserObjectCreate
		case HIP_API_ID_hipUserObjectCreate : {
			//	hipUserObject_t * object_out (struct hipUserObject **);
			//	void * ptr (void *);
			//	hipHostFn_t destroy (void (*)(void *));
			//	unsigned int initialRefcount (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipUserObjectCreate_t* args = (args_hipUserObjectCreate_t*) func_args;
			printf("\thipUserObject_t * object_out = %p", args->object_out);
			if (args->object_out != NULL) {
				printf(" -> %p\n", args->object_out__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\thipHostFn_t destroy = %p\n", args->destroy);
			printf("\tunsigned int initialRefcount = %u\n", args->initialRefcount);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetCaptureInfo_v2
		case HIP_API_ID_hipStreamGetCaptureInfo_v2 : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * captureStatus_out (enum hipStreamCaptureStatus*);
			//	unsigned long long * id_out (unsigned long long *);
			//	hipGraph_t * graph_out (struct ihipGraph **);
			//	const hipGraphNode_t ** dependencies_out (const struct hipGraphNode * **);
			//	size_t * numDependencies_out (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetCaptureInfo_v2_t* args = (args_hipStreamGetCaptureInfo_v2_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * captureStatus_out = %p", args->captureStatus_out);
			if (args->captureStatus_out != NULL) {
				printf(" -> %d\n", args->captureStatus_out__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * id_out = %p", args->id_out);
			if (args->id_out != NULL) {
				printf(" -> %llu\n", args->id_out__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t * graph_out = %p", args->graph_out);
			if (args->graph_out != NULL) {
				printf(" -> %p\n", args->graph_out__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t ** dependencies_out = %p", args->dependencies_out);
			if (args->dependencies_out != NULL) {
				printf("-> %p", args->dependencies_out__ref.ptr1);
				if (args->dependencies_out__ref.ptr1 != NULL) {
					printf(" -> %p\n", args->dependencies_out__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tsize_t * numDependencies_out = %p", args->numDependencies_out);
			if (args->numDependencies_out != NULL) {
				printf(" -> %lu\n", args->numDependencies_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetArray
		case HIP_API_ID_hipTexRefGetArray : {
			//	hipArray_t * pArray (struct hipArray **);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetArray_t* args = (args_hipTexRefGetArray_t*) func_args;
			printf("\thipArray_t * pArray = %p", args->pArray);
			if (args->pArray != NULL) {
				printf(" -> %p\n", args->pArray__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipImportExternalSemaphore
		case HIP_API_ID_hipImportExternalSemaphore : {
			//	hipExternalSemaphore_t * extSem_out (void **);
			//	const hipExternalSemaphoreHandleDesc * semHandleDesc ({
			//		hipExternalSemaphoreHandleType type (enum hipExternalSemaphoreHandleType_enum);
			//		union (unnamed union at header/hip/hip.h:1475:2) handle ({
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipImportExternalSemaphore_t* args = (args_hipImportExternalSemaphore_t*) func_args;
			printf("\thipExternalSemaphore_t * extSem_out = %p", args->extSem_out);
			if (args->extSem_out != NULL) {
				printf("-> %p", args->extSem_out__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalSemaphoreHandleDesc * semHandleDesc = %p", args->semHandleDesc);
			if (args->semHandleDesc != NULL) {
				printf(" -> {\n");
				printf("\t\thipExternalSemaphoreHandleType type = %d\n", args->semHandleDesc__ref.val.type);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1475:2) handle = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->semHandleDesc__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->semHandleDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetAttribute
		case HIP_API_ID_hipDeviceGetAttribute : {
			//	int * pi (int *);
			//	hipDeviceAttribute_t attr (enum hipDeviceAttribute_t);
			//	int deviceId (int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetAttribute_t* args = (args_hipDeviceGetAttribute_t*) func_args;
			printf("\tint * pi = %p", args->pi);
			if (args->pi != NULL) {
				printf(" -> %d\n", args->pi__ref.val);
			} else { printf("\n"); };
			printf("\thipDeviceAttribute_t attr = %d\n", args->attr);
			printf("\tint deviceId = %d\n", args->deviceId);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemFreeNodeGetParams
		case HIP_API_ID_hipGraphMemFreeNodeGetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dev_ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemFreeNodeGetParams_t* args = (args_hipGraphMemFreeNodeGetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tvoid * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxGetSharedMemConfig
		case HIP_API_ID_hipCtxGetSharedMemConfig : {
			//	hipSharedMemConfig * pConfig (enum hipSharedMemConfig*);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxGetSharedMemConfig_t* args = (args_hipCtxGetSharedMemConfig_t*) func_args;
			printf("\thipSharedMemConfig * pConfig = %p", args->pConfig);
			if (args->pConfig != NULL) {
				printf(" -> %d\n", args->pConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemcpyNodeSetParamsToSymbol
		case HIP_API_ID_hipGraphMemcpyNodeSetParamsToSymbol : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemcpyNodeSetParamsToSymbol_t* args = (args_hipGraphMemcpyNodeSetParamsToSymbol_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tsize_t offset = %lu\n", args->offset);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DToArray
		case HIP_API_ID_hipMemcpy2DToArray : {
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DToArray_t* args = (args_hipMemcpy2DToArray_t*) func_args;
			printf("\thipArray_t dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamIsCapturing_spt
		case HIP_API_ID_hipStreamIsCapturing_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamIsCapturing_spt_t* args = (args_hipStreamIsCapturing_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->pCaptureStatus);
			if (args->pCaptureStatus != NULL) {
				printf(" -> %d\n", args->pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFreeHost
		case HIP_API_ID_hipFreeHost : {
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipFreeHost_t* args = (args_hipFreeHost_t*) func_args;
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphKernelNodeSetParams
		case HIP_API_ID_hipGraphKernelNodeSetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphKernelNodeSetParams_t* args = (args_hipGraphKernelNodeSetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipKernelNodeParams * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocHost
		case HIP_API_ID_hipMallocHost : {
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocHost_t* args = (args_hipMallocHost_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->size);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset3D_spt
		case HIP_API_ID_hipMemset3D_spt : {
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemset3D_spt_t* args = (args_hipMemset3D_spt_t*) func_args;
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamGetCaptureInfo_v2_spt
		case HIP_API_ID_hipStreamGetCaptureInfo_v2_spt : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * captureStatus_out (enum hipStreamCaptureStatus*);
			//	unsigned long long * id_out (unsigned long long *);
			//	hipGraph_t * graph_out (struct ihipGraph **);
			//	const hipGraphNode_t ** dependencies_out (const struct hipGraphNode * **);
			//	size_t * numDependencies_out (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamGetCaptureInfo_v2_spt_t* args = (args_hipStreamGetCaptureInfo_v2_spt_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * captureStatus_out = %p", args->captureStatus_out);
			if (args->captureStatus_out != NULL) {
				printf(" -> %d\n", args->captureStatus_out__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * id_out = %p", args->id_out);
			if (args->id_out != NULL) {
				printf(" -> %llu\n", args->id_out__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t * graph_out = %p", args->graph_out);
			if (args->graph_out != NULL) {
				printf(" -> %p\n", args->graph_out__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t ** dependencies_out = %p", args->dependencies_out);
			if (args->dependencies_out != NULL) {
				printf("-> %p", args->dependencies_out__ref.ptr1);
				if (args->dependencies_out__ref.ptr1 != NULL) {
					printf(" -> %p\n", args->dependencies_out__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tsize_t * numDependencies_out = %p", args->numDependencies_out);
			if (args->numDependencies_out != NULL) {
				printf(" -> %lu\n", args->numDependencies_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetTextureReference
		case HIP_API_ID_hipGetTextureReference : {
			//	const textureReference ** texref ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const void * symbol (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetTextureReference_t* args = (args_hipGetTextureReference_t*) func_args;
			printf("\tconst textureReference ** texref = %p", args->texref);
			if (args->texref != NULL) {
				printf("-> %p", args->texref__ref.ptr1);
				if (args->texref__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tint normalized = %d\n", args->texref__ref.val.normalized);
					printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texref__ref.val.readMode);
					printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texref__ref.val.filterMode);
					printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texref__ref.val.addressMode[0]);
					printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
					printf("\t\t\tint x = %d\n", args->texref__ref.val.channelDesc.x);
					printf("\t\t\tint y = %d\n", args->texref__ref.val.channelDesc.y);
					printf("\t\t\tint z = %d\n", args->texref__ref.val.channelDesc.z);
					printf("\t\t\tint w = %d\n", args->texref__ref.val.channelDesc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texref__ref.val.channelDesc.f);
					printf("\t\t}\n");
					printf("\t\tint sRGB = %d\n", args->texref__ref.val.sRGB);
					printf("\t\tunsigned int maxAnisotropy = %u\n", args->texref__ref.val.maxAnisotropy);
					printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texref__ref.val.mipmapFilterMode);
					printf("\t\tfloat mipmapLevelBias = %f\n", args->texref__ref.val.mipmapLevelBias);
					printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texref__ref.val.minMipmapLevelClamp);
					printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texref__ref.val.maxMipmapLevelClamp);
					printf("\t\tint numChannels = %d\n", args->texref__ref.val.numChannels);
					printf("\t\tenum hipArray_Format format = %d\n", args->texref__ref.val.format);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tconst void * symbol = %p", args->symbol);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecExternalSemaphoresSignalNodeSetParams
		case HIP_API_ID_hipGraphExecExternalSemaphoresSignalNodeSetParams : {
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreSignalNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecExternalSemaphoresSignalNodeSetParams_t* args = (args_hipGraphExecExternalSemaphoresSignalNodeSetParams_t*) func_args;
			printf("\thipGraphExec_t hGraphExec = %p", args->hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreSignalNodeParams * nodeParams = %p", args->nodeParams);
			if (args->nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphAddDependencies
		case HIP_API_ID_hipGraphAddDependencies : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * from (const struct hipGraphNode * *);
			//	const hipGraphNode_t * to (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphAddDependencies_t* args = (args_hipGraphAddDependencies_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * from = %p", args->from);
			if (args->from != NULL) {
				printf(" -> %p\n", args->from__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t * to = %p", args->to);
			if (args->to != NULL) {
				printf(" -> %p\n", args->to__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphNodeGetType
		case HIP_API_ID_hipGraphNodeGetType : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraphNodeType * pType (enum hipGraphNodeType*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphNodeGetType_t* args = (args_hipGraphNodeGetType_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\thipGraphNodeType * pType = %p", args->pType);
			if (args->pType != NULL) {
				printf(" -> %d\n", args->pType__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetBorderColor
		case HIP_API_ID_hipTexRefSetBorderColor : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	float * pBorderColor (float *);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetBorderColor_t* args = (args_hipTexRefSetBorderColor_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tfloat * pBorderColor = %p", args->pBorderColor);
			if (args->pBorderColor != NULL) {
				printf(" -> %f\n", args->pBorderColor__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPrefetchAsync
		case HIP_API_ID_hipMemPrefetchAsync : {
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	int device (int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPrefetchAsync_t* args = (args_hipMemPrefetchAsync_t*) func_args;
			printf("\tconst void * dev_ptr = %p", args->dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\tint device = %d\n", args->device);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxGetDevice
		case HIP_API_ID_hipCtxGetDevice : {
			//	hipDevice_t * device (int*);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxGetDevice_t* args = (args_hipCtxGetDevice_t*) func_args;
			printf("\thipDevice_t * device = %p", args->device);
			if (args->device != NULL) {
				printf(" -> %d\n", args->device__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2DArrayToArray
		case HIP_API_ID_hipMemcpy2DArrayToArray : {
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffsetDst (unsigned long);
			//	size_t hOffsetDst (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffsetSrc (unsigned long);
			//	size_t hOffsetSrc (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2DArrayToArray_t* args = (args_hipMemcpy2DArrayToArray_t*) func_args;
			printf("\thipArray_t dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t wOffsetDst = %lu\n", args->wOffsetDst);
			printf("\tsize_t hOffsetDst = %lu\n", args->hOffsetDst);
			printf("\thipArray_const_t src = %p", args->src);
			printf("\n");
			printf("\tsize_t wOffsetSrc = %lu\n", args->wOffsetSrc);
			printf("\tsize_t hOffsetSrc = %lu\n", args->hOffsetSrc);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipUserObjectRelease
		case HIP_API_ID_hipUserObjectRelease : {
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipUserObjectRelease_t* args = (args_hipUserObjectRelease_t*) func_args;
			printf("\thipUserObject_t object = %p", args->object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->count);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipHostGetFlags
		case HIP_API_ID_hipHostGetFlags : {
			//	unsigned int * flagsPtr (unsigned int *);
			//	void * hostPtr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipHostGetFlags_t* args = (args_hipHostGetFlags_t*) func_args;
			printf("\tunsigned int * flagsPtr = %p", args->flagsPtr);
			if (args->flagsPtr != NULL) {
				printf(" -> %u\n", args->flagsPtr__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * hostPtr = %p", args->hostPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvGraphAddMemsetNode
		case HIP_API_ID_hipDrvGraphAddMemsetNode : {
			//	hipGraphNode_t * phGraphNode (struct hipGraphNode **);
			//	hipGraph_t hGraph (struct ihipGraph *);
			//	const hipGraphNode_t * dependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const HIP_MEMSET_NODE_PARAMS * memsetParams ({
			//		hipDeviceptr_t dst (void *);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		unsigned int elementSize (unsigned int);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//	});
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipDrvGraphAddMemsetNode_t* args = (args_hipDrvGraphAddMemsetNode_t*) func_args;
			printf("\thipGraphNode_t * phGraphNode = %p", args->phGraphNode);
			if (args->phGraphNode != NULL) {
				printf(" -> %p\n", args->phGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t hGraph = %p", args->hGraph);
			printf("\n");
			printf("\tconst hipGraphNode_t * dependencies = %p", args->dependencies);
			if (args->dependencies != NULL) {
				printf(" -> %p\n", args->dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->numDependencies);
			printf("\tconst HIP_MEMSET_NODE_PARAMS * memsetParams = %p", args->memsetParams);
			if (args->memsetParams != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t pitch = %lu\n", args->memsetParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->memsetParams__ref.val.value);
				printf("\t\tunsigned int elementSize = %u\n", args->memsetParams__ref.val.elementSize);
				printf("\t\tsize_t width = %lu\n", args->memsetParams__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->memsetParams__ref.val.height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipCtx_t ctx = %p", args->ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyAtoD
		case HIP_API_ID_hipMemcpyAtoD : {
			//	hipDeviceptr_t dstDevice (void *);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t ByteCount (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyAtoD_t* args = (args_hipMemcpyAtoD_t*) func_args;
			printf("\thipDeviceptr_t dstDevice = %p", args->dstDevice);
			printf("\n");
			printf("\thipArray_t srcArray = %p", args->srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->srcOffset);
			printf("\tsize_t ByteCount = %lu\n", args->ByteCount);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolCreate
		case HIP_API_ID_hipMemPoolCreate : {
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	const hipMemPoolProps * pool_props ({
			//		hipMemAllocationType allocType (enum hipMemAllocationType);
			//		hipMemAllocationHandleType handleTypes (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32SecurityAttributes (void *);
			//		size_t maxSize (unsigned long);
			//		unsigned char[56] reserved (unsigned char[56]);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolCreate_t* args = (args_hipMemPoolCreate_t*) func_args;
			printf("\thipMemPool_t * mem_pool = %p", args->mem_pool);
			if (args->mem_pool != NULL) {
				printf(" -> %p\n", args->mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipMemPoolProps * pool_props = %p", args->pool_props);
			if (args->pool_props != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType allocType = %d\n", args->pool_props__ref.val.allocType);
				printf("\t\thipMemAllocationHandleType handleTypes = %d\n", args->pool_props__ref.val.handleTypes);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->pool_props__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->pool_props__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tsize_t maxSize = %lu\n", args->pool_props__ref.val.maxSize);
				printf("\t\tunsigned char[56] reserved = %hhu\n", args->pool_props__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipKernelNameRef
		case HIP_API_ID_hipKernelNameRef : {
			//	const hipFunction_t f (const struct ihipModuleSymbol_t *);
			//	const char * retval (const char *);
			args_hipKernelNameRef_t* args = (args_hipKernelNameRef_t*) func_args;
			printf("\tconst hipFunction_t f = %p", args->f);
			printf("\n");
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipMemset3DAsync
		case HIP_API_ID_hipMemset3DAsync : {
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset3DAsync_t* args = (args_hipMemset3DAsync_t*) func_args;
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipEventRecord
		case HIP_API_ID_hipEventRecord : {
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipEventRecord_t* args = (args_hipEventRecord_t*) func_args;
			printf("\thipEvent_t event = %p", args->event);
			printf("\n");
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMipmappedArrayDestroy
		case HIP_API_ID_hipMipmappedArrayDestroy : {
			//	hipMipmappedArray_t hMipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipMipmappedArrayDestroy_t* args = (args_hipMipmappedArrayDestroy_t*) func_args;
			printf("\thipMipmappedArray_t hMipmappedArray = %p", args->hMipmappedArray);
			if (args->hMipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hMipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hMipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hMipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hMipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hMipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hMipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hMipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hMipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hMipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hMipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hMipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hMipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hMipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hMipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetAsync_spt
		case HIP_API_ID_hipMemsetAsync_spt : {
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetAsync_spt_t* args = (args_hipMemsetAsync_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDevicePrimaryCtxSetFlags
		case HIP_API_ID_hipDevicePrimaryCtxSetFlags : {
			//	hipDevice_t dev (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipDevicePrimaryCtxSetFlags_t* args = (args_hipDevicePrimaryCtxSetFlags_t*) func_args;
			printf("\thipDevice_t dev = %d\n", args->dev);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipPeekAtLastError
		case HIP_API_ID_hipPeekAtLastError : {
			//	hipError_t retval (enum hipError_t);
			args_hipPeekAtLastError_t* args = (args_hipPeekAtLastError_t*) func_args;
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceGetGraphMemAttribute
		case HIP_API_ID_hipDeviceGetGraphMemAttribute : {
			//	int device (int);
			//	hipGraphMemAttributeType attr (enum hipGraphMemAttributeType);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceGetGraphMemAttribute_t* args = (args_hipDeviceGetGraphMemAttribute_t*) func_args;
			printf("\tint device = %d\n", args->device);
			printf("\thipGraphMemAttributeType attr = %d\n", args->attr);
			printf("\tvoid * value = %p", args->value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDrvGetErrorName
		case HIP_API_ID_hipDrvGetErrorName : {
			//	hipError_t hipError (enum hipError_t);
			//	const char ** errorString (const char **);
			//	hipError_t retval (enum hipError_t);
			args_hipDrvGetErrorName_t* args = (args_hipDrvGetErrorName_t*) func_args;
			printf("\thipError_t hipError = %d\n", args->hipError);
			printf("\tconst char ** errorString = %p", args->errorString);
			if (args->errorString != NULL) {
				printf("-> %p", args->errorString__ref.ptr1);
				if (args->errorString__ref.ptr1 != NULL) {
					printf(" -> %s\n", args->errorString__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy_spt
		case HIP_API_ID_hipMemcpy_spt : {
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy_spt_t* args = (args_hipMemcpy_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCtxSetSharedMemConfig
		case HIP_API_ID_hipCtxSetSharedMemConfig : {
			//	hipSharedMemConfig config (enum hipSharedMemConfig);
			//	hipError_t retval (enum hipError_t);
			args_hipCtxSetSharedMemConfig_t* args = (args_hipCtxSetSharedMemConfig_t*) func_args;
			printf("\thipSharedMemConfig config = %d\n", args->config);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipCreateSurfaceObject
		case HIP_API_ID_hipCreateSurfaceObject : {
			//	hipSurfaceObject_t * pSurfObject (struct __hip_surface **);
			//	const hipResourceDesc * pResDesc ({
			//		enum hipResourceType resType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:612:2) res ({
			//		});
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipCreateSurfaceObject_t* args = (args_hipCreateSurfaceObject_t*) func_args;
			printf("\thipSurfaceObject_t * pSurfObject = %p", args->pSurfObject);
			if (args->pSurfObject != NULL) {
				printf(" -> %p\n", args->pSurfObject__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipResourceDesc * pResDesc = %p", args->pResDesc);
			if (args->pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceType resType = %d\n", args->pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:612:2) res = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetMipmappedArrayLevel
		case HIP_API_ID_hipGetMipmappedArrayLevel : {
			//	hipArray_t * levelArray (struct hipArray **);
			//	hipMipmappedArray_const_t mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	unsigned int level (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipGetMipmappedArrayLevel_t* args = (args_hipGetMipmappedArrayLevel_t*) func_args;
			printf("\thipArray_t * levelArray = %p", args->levelArray);
			if (args->levelArray != NULL) {
				printf(" -> %p\n", args->levelArray__ref.val);
			} else { printf("\n"); };
			printf("\thipMipmappedArray_const_t mipmappedArray = %p", args->mipmappedArray);
			if (args->mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int level = %u\n", args->level);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphExecDestroy
		case HIP_API_ID_hipGraphExecDestroy : {
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphExecDestroy_t* args = (args_hipGraphExecDestroy_t*) func_args;
			printf("\thipGraphExec_t graphExec = %p", args->graphExec);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemsetD32Async
		case HIP_API_ID_hipMemsetD32Async : {
			//	hipDeviceptr_t dst (void *);
			//	int value (int);
			//	size_t count (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemsetD32Async_t* args = (args_hipMemsetD32Async_t*) func_args;
			printf("\thipDeviceptr_t dst = %p", args->dst);
			printf("\n");
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDeviceEnablePeerAccess
		case HIP_API_ID_hipDeviceEnablePeerAccess : {
			//	int peerDeviceId (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipDeviceEnablePeerAccess_t* args = (args_hipDeviceEnablePeerAccess_t*) func_args;
			printf("\tint peerDeviceId = %d\n", args->peerDeviceId);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipArray3DCreate
		case HIP_API_ID_hipArray3DCreate : {
			//	hipArray_t * array (struct hipArray **);
			//	const HIP_ARRAY3D_DESCRIPTOR * pAllocateArray ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//		unsigned int Flags (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipArray3DCreate_t* args = (args_hipArray3DCreate_t*) func_args;
			printf("\thipArray_t * array = %p", args->array);
			if (args->array != NULL) {
				printf(" -> %p\n", args->array__ref.val);
			} else { printf("\n"); };
			printf("\tconst HIP_ARRAY3D_DESCRIPTOR * pAllocateArray = %p", args->pAllocateArray);
			if (args->pAllocateArray != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->pAllocateArray__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->pAllocateArray__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->pAllocateArray__ref.val.Depth);
				printf("\t\tenum hipArray_Format Format = %d\n", args->pAllocateArray__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->pAllocateArray__ref.val.NumChannels);
				printf("\t\tunsigned int Flags = %u\n", args->pAllocateArray__ref.val.Flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipIpcOpenMemHandle
		case HIP_API_ID_hipIpcOpenMemHandle : {
			//	void ** devPtr (void **);
			//	hipIpcMemHandle_t handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipIpcOpenMemHandle_t* args = (args_hipIpcOpenMemHandle_t*) func_args;
			printf("\tvoid ** devPtr = %p", args->devPtr);
			if (args->devPtr != NULL) {
				printf("-> %p", args->devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipIpcMemHandle_t handle = {\n");
			printf("\t\tchar[64] reserved = %c\n", args->handle.reserved[0]);
			printf("\t}\n");
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemPoolTrimTo
		case HIP_API_ID_hipMemPoolTrimTo : {
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	size_t min_bytes_to_hold (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemPoolTrimTo_t* args = (args_hipMemPoolTrimTo_t*) func_args;
			printf("\thipMemPool_t mem_pool = %p", args->mem_pool);
			printf("\n");
			printf("\tsize_t min_bytes_to_hold = %lu\n", args->min_bytes_to_hold);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy2D
		case HIP_API_ID_hipMemcpy2D : {
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy2D_t* args = (args_hipMemcpy2D_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->dpitch);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->spitch);
			printf("\tsize_t width = %lu\n", args->width);
			printf("\tsize_t height = %lu\n", args->height);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFuncGetAttribute
		case HIP_API_ID_hipFuncGetAttribute : {
			//	int * value (int *);
			//	hipFunction_attribute attrib (enum hipFunction_attribute);
			//	hipFunction_t hfunc (struct ihipModuleSymbol_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipFuncGetAttribute_t* args = (args_hipFuncGetAttribute_t*) func_args;
			printf("\tint * value = %p", args->value);
			if (args->value != NULL) {
				printf(" -> %d\n", args->value__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_attribute attrib = %d\n", args->attrib);
			printf("\thipFunction_t hfunc = %p", args->hfunc);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipBindTextureToMipmappedArray
		case HIP_API_ID_hipBindTextureToMipmappedArray : {
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipMipmappedArray_const_t mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipBindTextureToMipmappedArray_t* args = (args_hipBindTextureToMipmappedArray_t*) func_args;
			printf("\tconst textureReference * tex = %p", args->tex);
			if (args->tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipMipmappedArray_const_t mipmappedArray = %p", args->mipmappedArray);
			if (args->mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphicsMapResources
		case HIP_API_ID_hipGraphicsMapResources : {
			//	int count (int);
			//	hipGraphicsResource_t * resources (struct _hipGraphicsResource**);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphicsMapResources_t* args = (args_hipGraphicsMapResources_t*) func_args;
			printf("\tint count = %d\n", args->count);
			printf("\thipGraphicsResource_t * resources = %p", args->resources);
			if (args->resources != NULL) {
				printf(" -> %p\n", args->resources__ref.val);
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipArrayCreate
		case HIP_API_ID_hipArrayCreate : {
			//	hipArray_t * pHandle (struct hipArray **);
			//	const HIP_ARRAY_DESCRIPTOR * pAllocateArray ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipArrayCreate_t* args = (args_hipArrayCreate_t*) func_args;
			printf("\thipArray_t * pHandle = %p", args->pHandle);
			if (args->pHandle != NULL) {
				printf(" -> %p\n", args->pHandle__ref.val);
			} else { printf("\n"); };
			printf("\tconst HIP_ARRAY_DESCRIPTOR * pAllocateArray = %p", args->pAllocateArray);
			if (args->pAllocateArray != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->pAllocateArray__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->pAllocateArray__ref.val.Height);
				printf("\t\tenum hipArray_Format Format = %d\n", args->pAllocateArray__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->pAllocateArray__ref.val.NumChannels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetMaxAnisotropy
		case HIP_API_ID_hipTexRefSetMaxAnisotropy : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	unsigned int maxAniso (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetMaxAnisotropy_t* args = (args_hipTexRefSetMaxAnisotropy_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int maxAniso = %u\n", args->maxAniso);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphKernelNodeGetAttribute
		case HIP_API_ID_hipGraphKernelNodeGetAttribute : {
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipLaunchAttributeID attr (enum hipLaunchAttributeID);
			//	hipLaunchAttributeValue * value ({
			//		hipAccessPolicyWindow accessPolicyWindow ({
			//			void * base_ptr (void *);
			//			hipAccessProperty hitProp (enum hipAccessProperty);
			//			float hitRatio (float);
			//			hipAccessProperty missProp (enum hipAccessProperty);
			//			size_t num_bytes (unsigned long);
			//		});
			//		int cooperative (int);
			//		int priority (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphKernelNodeGetAttribute_t* args = (args_hipGraphKernelNodeGetAttribute_t*) func_args;
			printf("\thipGraphNode_t hNode = %p", args->hNode);
			printf("\n");
			printf("\thipLaunchAttributeID attr = %d\n", args->attr);
			printf("\thipLaunchAttributeValue * value = %p", args->value);
			if (args->value != NULL) {
				printf(" -> {\n");
				printf("\t\thipAccessPolicyWindow accessPolicyWindow = {\n");
				printf("\t\t\thipAccessProperty hitProp = %d\n", args->value__ref.val.accessPolicyWindow.hitProp);
				printf("\t\t\tfloat hitRatio = %f\n", args->value__ref.val.accessPolicyWindow.hitRatio);
				printf("\t\t\thipAccessProperty missProp = %d\n", args->value__ref.val.accessPolicyWindow.missProp);
				printf("\t\t\tsize_t num_bytes = %lu\n", args->value__ref.val.accessPolicyWindow.num_bytes);
				printf("\t\t}\n");
				printf("\t\tint cooperative = %d\n", args->value__ref.val.cooperative);
				printf("\t\tint priority = %d\n", args->value__ref.val.priority);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtLaunchKernel
		case HIP_API_ID_hipExtLaunchKernel : {
			//	const void * function_address (const void *);
			//	dim3 numBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 dimBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** args (void **);
			//	size_t sharedMemBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipEvent_t startEvent (struct ihipEvent_t *);
			//	hipEvent_t stopEvent (struct ihipEvent_t *);
			//	int flags (int);
			//	hipError_t retval (enum hipError_t);
			args_hipExtLaunchKernel_t* args = (args_hipExtLaunchKernel_t*) func_args;
			printf("\tconst void * function_address = %p", args->function_address);
			printf("\n");
			printf("\tdim3 numBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->numBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->numBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->numBlocks.z);
			printf("\t}\n");
			printf("\tdim3 dimBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->dimBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->dimBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->dimBlocks.z);
			printf("\t}\n");
			printf("\tvoid ** args = %p", args->args);
			if (args->args != NULL) {
				printf("-> %p", args->args__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sharedMemBytes = %lu\n", args->sharedMemBytes);
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipEvent_t startEvent = %p", args->startEvent);
			printf("\n");
			printf("\thipEvent_t stopEvent = %p", args->stopEvent);
			printf("\n");
			printf("\tint flags = %d\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetMipmapFilterMode
		case HIP_API_ID_hipTexRefSetMipmapFilterMode : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	enum hipTextureFilterMode fm (enum hipTextureFilterMode);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetMipmapFilterMode_t* args = (args_hipTexRefSetMipmapFilterMode_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tenum hipTextureFilterMode fm = %d\n", args->fm);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemImportFromShareableHandle
		case HIP_API_ID_hipMemImportFromShareableHandle : {
			//	hipMemGenericAllocationHandle_t * handle (struct ihipMemGenericAllocationHandle **);
			//	void * osHandle (void *);
			//	hipMemAllocationHandleType shHandleType (enum hipMemAllocationHandleType);
			//	hipError_t retval (enum hipError_t);
			args_hipMemImportFromShareableHandle_t* args = (args_hipMemImportFromShareableHandle_t*) func_args;
			printf("\thipMemGenericAllocationHandle_t * handle = %p", args->handle);
			if (args->handle != NULL) {
				printf(" -> %p\n", args->handle__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * osHandle = %p", args->osHandle);
			printf("\n");
			printf("\thipMemAllocationHandleType shHandleType = %d\n", args->shHandleType);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetFormat
		case HIP_API_ID_hipTexRefSetFormat : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipArray_Format fmt (enum hipArray_Format);
			//	int NumPackedComponents (int);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetFormat_t* args = (args_hipTexRefSetFormat_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_Format fmt = %d\n", args->fmt);
			printf("\tint NumPackedComponents = %d\n", args->NumPackedComponents);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_amd_dbgapi_get_git_hash
		case HIP_API_ID_amd_dbgapi_get_git_hash : {
			//	const char * retval (const char *);
			args_amd_dbgapi_get_git_hash_t* args = (args_amd_dbgapi_get_git_hash_t*) func_args;
			printf("\tconst char * retval = %p", args->retval);
			if (args->retval != NULL) {
				printf(" -> %s\n", args->retval__ref.val);
			} else { printf("\n"); };
			break;

		}
		#endif
		#if HAVE_hipLaunchByPtr
		case HIP_API_ID_hipLaunchByPtr : {
			//	const void * func (const void *);
			//	hipError_t retval (enum hipError_t);
			args_hipLaunchByPtr_t* args = (args_hipLaunchByPtr_t*) func_args;
			printf("\tconst void * func = %p", args->func);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_amd_dbgapi_get_build_id
		case HIP_API_ID_amd_dbgapi_get_build_id : {
			//	size_t retval (unsigned long);
			args_amd_dbgapi_get_build_id_t* args = (args_amd_dbgapi_get_build_id_t*) func_args;
			printf("\tsize_t retval = %lu\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpy3DAsync
		case HIP_API_ID_hipMemcpy3DAsync : {
			//	const struct hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpy3DAsync_t* args = (args_hipMemcpy3DAsync_t*) func_args;
			printf("\tconst struct hipMemcpy3DParms * p = %p", args->p);
			if (args->p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGetTextureObjectResourceViewDesc
		case HIP_API_ID_hipGetTextureObjectResourceViewDesc : {
			//	struct hipResourceViewDesc * pResViewDesc ({
			//		enum hipResourceViewFormat format (enum hipResourceViewFormat);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//	});
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			args_hipGetTextureObjectResourceViewDesc_t* args = (args_hipGetTextureObjectResourceViewDesc_t*) func_args;
			printf("\tstruct hipResourceViewDesc * pResViewDesc = %p", args->pResViewDesc);
			if (args->pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceViewFormat format = %d\n", args->pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->pResViewDesc__ref.val.lastLayer);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t textureObject = %p", args->textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetFilterMode
		case HIP_API_ID_hipTexRefSetFilterMode : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	enum hipTextureFilterMode fm (enum hipTextureFilterMode);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetFilterMode_t* args = (args_hipTexRefSetFilterMode_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tenum hipTextureFilterMode fm = %d\n", args->fm);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipDriverGetVersion
		case HIP_API_ID_hipDriverGetVersion : {
			//	int * driverVersion (int *);
			//	hipError_t retval (enum hipError_t);
			args_hipDriverGetVersion_t* args = (args_hipDriverGetVersion_t*) func_args;
			printf("\tint * driverVersion = %p", args->driverVersion);
			if (args->driverVersion != NULL) {
				printf(" -> %d\n", args->driverVersion__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipStreamWriteValue64
		case HIP_API_ID_hipStreamWriteValue64 : {
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint64_t value (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipStreamWriteValue64_t* args = (args_hipStreamWriteValue64_t*) func_args;
			printf("\thipStream_t stream = %p", args->stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->ptr);
			printf("\n");
			printf("\tuint64_t value = %lu\n", args->value);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMallocMipmappedArray
		case HIP_API_ID_hipMallocMipmappedArray : {
			//	hipMipmappedArray_t * mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	const struct hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	struct hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	unsigned int numLevels (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipMallocMipmappedArray_t* args = (args_hipMallocMipmappedArray_t*) func_args;
			printf("\thipMipmappedArray_t * mipmappedArray = %p", args->mipmappedArray);
			if (args->mipmappedArray != NULL) {
				printf("-> %p", args->mipmappedArray__ref.ptr1);
				if (args->mipmappedArray__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->mipmappedArray__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->mipmappedArray__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->mipmappedArray__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->mipmappedArray__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmappedArray__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->mipmappedArray__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->mipmappedArray__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->mipmappedArray__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->mipmappedArray__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->mipmappedArray__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->mipmappedArray__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->mipmappedArray__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->mipmappedArray__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->mipmappedArray__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tconst struct hipChannelFormatDesc * desc = %p", args->desc);
			if (args->desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->desc__ref.val.x);
				printf("\t\tint y = %d\n", args->desc__ref.val.y);
				printf("\t\tint z = %d\n", args->desc__ref.val.z);
				printf("\t\tint w = %d\n", args->desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tstruct hipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->extent.width);
			printf("\t\tsize_t height = %lu\n", args->extent.height);
			printf("\t\tsize_t depth = %lu\n", args->extent.depth);
			printf("\t}\n");
			printf("\tunsigned int numLevels = %u\n", args->numLevels);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset_spt
		case HIP_API_ID_hipMemset_spt : {
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset_spt_t* args = (args_hipMemset_spt_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetFlags
		case HIP_API_ID_hipTexRefSetFlags : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	unsigned int Flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetFlags_t* args = (args_hipTexRefSetFlags_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int Flags = %u\n", args->Flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemGetAddressRange
		case HIP_API_ID_hipMemGetAddressRange : {
			//	hipDeviceptr_t * pbase (void **);
			//	size_t * psize (unsigned long*);
			//	hipDeviceptr_t dptr (void *);
			//	hipError_t retval (enum hipError_t);
			args_hipMemGetAddressRange_t* args = (args_hipMemGetAddressRange_t*) func_args;
			printf("\thipDeviceptr_t * pbase = %p", args->pbase);
			if (args->pbase != NULL) {
				printf("-> %p", args->pbase__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * psize = %p", args->psize);
			if (args->psize != NULL) {
				printf(" -> %lu\n", args->psize__ref.val);
			} else { printf("\n"); };
			printf("\thipDeviceptr_t dptr = %p", args->dptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetMipmapLevelClamp
		case HIP_API_ID_hipTexRefSetMipmapLevelClamp : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	float minMipMapLevelClamp (float);
			//	float maxMipMapLevelClamp (float);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetMipmapLevelClamp_t* args = (args_hipTexRefSetMipmapLevelClamp_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tfloat minMipMapLevelClamp = %f\n", args->minMipMapLevelClamp);
			printf("\tfloat maxMipMapLevelClamp = %f\n", args->maxMipMapLevelClamp);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphMemcpyNodeSetParams
		case HIP_API_ID_hipGraphMemcpyNodeSetParams : {
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipMemcpy3DParms * pNodeParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipGraphMemcpyNodeSetParams_t* args = (args_hipGraphMemcpyNodeSetParams_t*) func_args;
			printf("\thipGraphNode_t node = %p", args->node);
			printf("\n");
			printf("\tconst hipMemcpy3DParms * pNodeParams = %p", args->pNodeParams);
			if (args->pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pNodeParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pNodeParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pNodeParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pNodeParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pNodeParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->pNodeParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->pNodeParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->pNodeParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->pNodeParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->pNodeParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->pNodeParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->pNodeParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->pNodeParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->pNodeParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->pNodeParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipGraphGetEdges
		case HIP_API_ID_hipGraphGetEdges : {
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * from (struct hipGraphNode **);
			//	hipGraphNode_t * to (struct hipGraphNode **);
			//	size_t * numEdges (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			args_hipGraphGetEdges_t* args = (args_hipGraphGetEdges_t*) func_args;
			printf("\thipGraph_t graph = %p", args->graph);
			printf("\n");
			printf("\thipGraphNode_t * from = %p", args->from);
			if (args->from != NULL) {
				printf(" -> %p\n", args->from__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphNode_t * to = %p", args->to);
			if (args->to != NULL) {
				printf(" -> %p\n", args->to__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * numEdges = %p", args->numEdges);
			if (args->numEdges != NULL) {
				printf(" -> %lu\n", args->numEdges__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemcpyToArray
		case HIP_API_ID_hipMemcpyToArray : {
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			args_hipMemcpyToArray_t* args = (args_hipMemcpyToArray_t*) func_args;
			printf("\thipArray_t dst = %p", args->dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hOffset);
			printf("\tconst void * src = %p", args->src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->count);
			printf("\thipMemcpyKind kind = %d\n", args->kind);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipExtMallocWithFlags
		case HIP_API_ID_hipExtMallocWithFlags : {
			//	void ** ptr (void **);
			//	size_t sizeBytes (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipExtMallocWithFlags_t* args = (args_hipExtMallocWithFlags_t*) func_args;
			printf("\tvoid ** ptr = %p", args->ptr);
			if (args->ptr != NULL) {
				printf("-> %p", args->ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\tunsigned int flags = %u\n", args->flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipFuncSetAttribute
		case HIP_API_ID_hipFuncSetAttribute : {
			//	const void * func (const void *);
			//	hipFuncAttribute attr (enum hipFuncAttribute);
			//	int value (int);
			//	hipError_t retval (enum hipError_t);
			args_hipFuncSetAttribute_t* args = (args_hipFuncSetAttribute_t*) func_args;
			printf("\tconst void * func = %p", args->func);
			printf("\n");
			printf("\thipFuncAttribute attr = %d\n", args->attr);
			printf("\tint value = %d\n", args->value);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipChooseDeviceR0600
		case HIP_API_ID_hipChooseDeviceR0600 : {
			//	int * device (int *);
			//	const hipDeviceProp_tR0600 * prop ({
			//		char[256] name (char[256]);
			//		hipUUID uuid ({
			//			char[16] bytes (char[16]);
			//		});
			//		char[8] luid (char[8]);
			//		unsigned int luidDeviceNodeMask (unsigned int);
			//		size_t totalGlobalMem (unsigned long);
			//		size_t sharedMemPerBlock (unsigned long);
			//		int regsPerBlock (int);
			//		int warpSize (int);
			//		size_t memPitch (unsigned long);
			//		int maxThreadsPerBlock (int);
			//		int[3] maxThreadsDim (int[3]);
			//		int[3] maxGridSize (int[3]);
			//		int clockRate (int);
			//		size_t totalConstMem (unsigned long);
			//		int major (int);
			//		int minor (int);
			//		size_t textureAlignment (unsigned long);
			//		size_t texturePitchAlignment (unsigned long);
			//		int deviceOverlap (int);
			//		int multiProcessorCount (int);
			//		int kernelExecTimeoutEnabled (int);
			//		int integrated (int);
			//		int canMapHostMemory (int);
			//		int computeMode (int);
			//		int maxTexture1D (int);
			//		int maxTexture1DMipmap (int);
			//		int maxTexture1DLinear (int);
			//		int[2] maxTexture2D (int[2]);
			//		int[2] maxTexture2DMipmap (int[2]);
			//		int[3] maxTexture2DLinear (int[3]);
			//		int[2] maxTexture2DGather (int[2]);
			//		int[3] maxTexture3D (int[3]);
			//		int[3] maxTexture3DAlt (int[3]);
			//		int maxTextureCubemap (int);
			//		int[2] maxTexture1DLayered (int[2]);
			//		int[3] maxTexture2DLayered (int[3]);
			//		int[2] maxTextureCubemapLayered (int[2]);
			//		int maxSurface1D (int);
			//		int[2] maxSurface2D (int[2]);
			//		int[3] maxSurface3D (int[3]);
			//		int[2] maxSurface1DLayered (int[2]);
			//		int[3] maxSurface2DLayered (int[3]);
			//		int maxSurfaceCubemap (int);
			//		int[2] maxSurfaceCubemapLayered (int[2]);
			//		size_t surfaceAlignment (unsigned long);
			//		int concurrentKernels (int);
			//		int ECCEnabled (int);
			//		int pciBusID (int);
			//		int pciDeviceID (int);
			//		int pciDomainID (int);
			//		int tccDriver (int);
			//		int asyncEngineCount (int);
			//		int unifiedAddressing (int);
			//		int memoryClockRate (int);
			//		int memoryBusWidth (int);
			//		int l2CacheSize (int);
			//		int persistingL2CacheMaxSize (int);
			//		int maxThreadsPerMultiProcessor (int);
			//		int streamPrioritiesSupported (int);
			//		int globalL1CacheSupported (int);
			//		int localL1CacheSupported (int);
			//		size_t sharedMemPerMultiprocessor (unsigned long);
			//		int regsPerMultiprocessor (int);
			//		int managedMemory (int);
			//		int isMultiGpuBoard (int);
			//		int multiGpuBoardGroupID (int);
			//		int hostNativeAtomicSupported (int);
			//		int singleToDoublePrecisionPerfRatio (int);
			//		int pageableMemoryAccess (int);
			//		int concurrentManagedAccess (int);
			//		int computePreemptionSupported (int);
			//		int canUseHostPointerForRegisteredMem (int);
			//		int cooperativeLaunch (int);
			//		int cooperativeMultiDeviceLaunch (int);
			//		size_t sharedMemPerBlockOptin (unsigned long);
			//		int pageableMemoryAccessUsesHostPageTables (int);
			//		int directManagedMemAccessFromHost (int);
			//		int maxBlocksPerMultiProcessor (int);
			//		int accessPolicyMaxWindowSize (int);
			//		size_t reservedSharedMemPerBlock (unsigned long);
			//		int hostRegisterSupported (int);
			//		int sparseHipArraySupported (int);
			//		int hostRegisterReadOnlySupported (int);
			//		int timelineSemaphoreInteropSupported (int);
			//		int memoryPoolsSupported (int);
			//		int gpuDirectRDMASupported (int);
			//		unsigned int gpuDirectRDMAFlushWritesOptions (unsigned int);
			//		int gpuDirectRDMAWritesOrdering (int);
			//		unsigned int memoryPoolSupportedHandleTypes (unsigned int);
			//		int deferredMappingHipArraySupported (int);
			//		int ipcEventSupported (int);
			//		int clusterLaunch (int);
			//		int unifiedFunctionPointers (int);
			//		int[63] reserved (int[63]);
			//		int[32] hipReserved (int[32]);
			//		char[256] gcnArchName (char[256]);
			//		size_t maxSharedMemoryPerMultiProcessor (unsigned long);
			//		int clockInstructionRate (int);
			//		hipDeviceArch_t arch ({
			//			unsigned int hasGlobalInt32Atomics (unsigned int);
			//			unsigned int hasGlobalFloatAtomicExch (unsigned int);
			//			unsigned int hasSharedInt32Atomics (unsigned int);
			//			unsigned int hasSharedFloatAtomicExch (unsigned int);
			//			unsigned int hasFloatAtomicAdd (unsigned int);
			//			unsigned int hasGlobalInt64Atomics (unsigned int);
			//			unsigned int hasSharedInt64Atomics (unsigned int);
			//			unsigned int hasDoubles (unsigned int);
			//			unsigned int hasWarpVote (unsigned int);
			//			unsigned int hasWarpBallot (unsigned int);
			//			unsigned int hasWarpShuffle (unsigned int);
			//			unsigned int hasFunnelShift (unsigned int);
			//			unsigned int hasThreadFenceSystem (unsigned int);
			//			unsigned int hasSyncThreadsExt (unsigned int);
			//			unsigned int hasSurfaceFuncs (unsigned int);
			//			unsigned int has3dGrid (unsigned int);
			//			unsigned int hasDynamicParallelism (unsigned int);
			//		});
			//		int cooperativeMultiDeviceUnmatchedFunc (int);
			//		int cooperativeMultiDeviceUnmatchedGridDim (int);
			//		int cooperativeMultiDeviceUnmatchedBlockDim (int);
			//		int cooperativeMultiDeviceUnmatchedSharedMem (int);
			//		int isLargeBar (int);
			//		int asicRevision (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipChooseDeviceR0600_t* args = (args_hipChooseDeviceR0600_t*) func_args;
			printf("\tint * device = %p", args->device);
			if (args->device != NULL) {
				printf(" -> %d\n", args->device__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipDeviceProp_tR0600 * prop = %p", args->prop);
			if (args->prop != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[256] name = %c\n", args->prop__ref.val.name[0]);
				printf("\t\thipUUID uuid = {\n");
				printf("\t\t\tchar[16] bytes = %c\n", args->prop__ref.val.uuid.bytes[0]);
				printf("\t\t}\n");
				printf("\t\tchar[8] luid = %c\n", args->prop__ref.val.luid[0]);
				printf("\t\tunsigned int luidDeviceNodeMask = %u\n", args->prop__ref.val.luidDeviceNodeMask);
				printf("\t\tsize_t totalGlobalMem = %lu\n", args->prop__ref.val.totalGlobalMem);
				printf("\t\tsize_t sharedMemPerBlock = %lu\n", args->prop__ref.val.sharedMemPerBlock);
				printf("\t\tint regsPerBlock = %d\n", args->prop__ref.val.regsPerBlock);
				printf("\t\tint warpSize = %d\n", args->prop__ref.val.warpSize);
				printf("\t\tsize_t memPitch = %lu\n", args->prop__ref.val.memPitch);
				printf("\t\tint maxThreadsPerBlock = %d\n", args->prop__ref.val.maxThreadsPerBlock);
				printf("\t\tint[3] maxThreadsDim = %d\n", args->prop__ref.val.maxThreadsDim[0]);
				printf("\t\tint[3] maxGridSize = %d\n", args->prop__ref.val.maxGridSize[0]);
				printf("\t\tint clockRate = %d\n", args->prop__ref.val.clockRate);
				printf("\t\tsize_t totalConstMem = %lu\n", args->prop__ref.val.totalConstMem);
				printf("\t\tint major = %d\n", args->prop__ref.val.major);
				printf("\t\tint minor = %d\n", args->prop__ref.val.minor);
				printf("\t\tsize_t textureAlignment = %lu\n", args->prop__ref.val.textureAlignment);
				printf("\t\tsize_t texturePitchAlignment = %lu\n", args->prop__ref.val.texturePitchAlignment);
				printf("\t\tint deviceOverlap = %d\n", args->prop__ref.val.deviceOverlap);
				printf("\t\tint multiProcessorCount = %d\n", args->prop__ref.val.multiProcessorCount);
				printf("\t\tint kernelExecTimeoutEnabled = %d\n", args->prop__ref.val.kernelExecTimeoutEnabled);
				printf("\t\tint integrated = %d\n", args->prop__ref.val.integrated);
				printf("\t\tint canMapHostMemory = %d\n", args->prop__ref.val.canMapHostMemory);
				printf("\t\tint computeMode = %d\n", args->prop__ref.val.computeMode);
				printf("\t\tint maxTexture1D = %d\n", args->prop__ref.val.maxTexture1D);
				printf("\t\tint maxTexture1DMipmap = %d\n", args->prop__ref.val.maxTexture1DMipmap);
				printf("\t\tint maxTexture1DLinear = %d\n", args->prop__ref.val.maxTexture1DLinear);
				printf("\t\tint[2] maxTexture2D = %d\n", args->prop__ref.val.maxTexture2D[0]);
				printf("\t\tint[2] maxTexture2DMipmap = %d\n", args->prop__ref.val.maxTexture2DMipmap[0]);
				printf("\t\tint[3] maxTexture2DLinear = %d\n", args->prop__ref.val.maxTexture2DLinear[0]);
				printf("\t\tint[2] maxTexture2DGather = %d\n", args->prop__ref.val.maxTexture2DGather[0]);
				printf("\t\tint[3] maxTexture3D = %d\n", args->prop__ref.val.maxTexture3D[0]);
				printf("\t\tint[3] maxTexture3DAlt = %d\n", args->prop__ref.val.maxTexture3DAlt[0]);
				printf("\t\tint maxTextureCubemap = %d\n", args->prop__ref.val.maxTextureCubemap);
				printf("\t\tint[2] maxTexture1DLayered = %d\n", args->prop__ref.val.maxTexture1DLayered[0]);
				printf("\t\tint[3] maxTexture2DLayered = %d\n", args->prop__ref.val.maxTexture2DLayered[0]);
				printf("\t\tint[2] maxTextureCubemapLayered = %d\n", args->prop__ref.val.maxTextureCubemapLayered[0]);
				printf("\t\tint maxSurface1D = %d\n", args->prop__ref.val.maxSurface1D);
				printf("\t\tint[2] maxSurface2D = %d\n", args->prop__ref.val.maxSurface2D[0]);
				printf("\t\tint[3] maxSurface3D = %d\n", args->prop__ref.val.maxSurface3D[0]);
				printf("\t\tint[2] maxSurface1DLayered = %d\n", args->prop__ref.val.maxSurface1DLayered[0]);
				printf("\t\tint[3] maxSurface2DLayered = %d\n", args->prop__ref.val.maxSurface2DLayered[0]);
				printf("\t\tint maxSurfaceCubemap = %d\n", args->prop__ref.val.maxSurfaceCubemap);
				printf("\t\tint[2] maxSurfaceCubemapLayered = %d\n", args->prop__ref.val.maxSurfaceCubemapLayered[0]);
				printf("\t\tsize_t surfaceAlignment = %lu\n", args->prop__ref.val.surfaceAlignment);
				printf("\t\tint concurrentKernels = %d\n", args->prop__ref.val.concurrentKernels);
				printf("\t\tint ECCEnabled = %d\n", args->prop__ref.val.ECCEnabled);
				printf("\t\tint pciBusID = %d\n", args->prop__ref.val.pciBusID);
				printf("\t\tint pciDeviceID = %d\n", args->prop__ref.val.pciDeviceID);
				printf("\t\tint pciDomainID = %d\n", args->prop__ref.val.pciDomainID);
				printf("\t\tint tccDriver = %d\n", args->prop__ref.val.tccDriver);
				printf("\t\tint asyncEngineCount = %d\n", args->prop__ref.val.asyncEngineCount);
				printf("\t\tint unifiedAddressing = %d\n", args->prop__ref.val.unifiedAddressing);
				printf("\t\tint memoryClockRate = %d\n", args->prop__ref.val.memoryClockRate);
				printf("\t\tint memoryBusWidth = %d\n", args->prop__ref.val.memoryBusWidth);
				printf("\t\tint l2CacheSize = %d\n", args->prop__ref.val.l2CacheSize);
				printf("\t\tint persistingL2CacheMaxSize = %d\n", args->prop__ref.val.persistingL2CacheMaxSize);
				printf("\t\tint maxThreadsPerMultiProcessor = %d\n", args->prop__ref.val.maxThreadsPerMultiProcessor);
				printf("\t\tint streamPrioritiesSupported = %d\n", args->prop__ref.val.streamPrioritiesSupported);
				printf("\t\tint globalL1CacheSupported = %d\n", args->prop__ref.val.globalL1CacheSupported);
				printf("\t\tint localL1CacheSupported = %d\n", args->prop__ref.val.localL1CacheSupported);
				printf("\t\tsize_t sharedMemPerMultiprocessor = %lu\n", args->prop__ref.val.sharedMemPerMultiprocessor);
				printf("\t\tint regsPerMultiprocessor = %d\n", args->prop__ref.val.regsPerMultiprocessor);
				printf("\t\tint managedMemory = %d\n", args->prop__ref.val.managedMemory);
				printf("\t\tint isMultiGpuBoard = %d\n", args->prop__ref.val.isMultiGpuBoard);
				printf("\t\tint multiGpuBoardGroupID = %d\n", args->prop__ref.val.multiGpuBoardGroupID);
				printf("\t\tint hostNativeAtomicSupported = %d\n", args->prop__ref.val.hostNativeAtomicSupported);
				printf("\t\tint singleToDoublePrecisionPerfRatio = %d\n", args->prop__ref.val.singleToDoublePrecisionPerfRatio);
				printf("\t\tint pageableMemoryAccess = %d\n", args->prop__ref.val.pageableMemoryAccess);
				printf("\t\tint concurrentManagedAccess = %d\n", args->prop__ref.val.concurrentManagedAccess);
				printf("\t\tint computePreemptionSupported = %d\n", args->prop__ref.val.computePreemptionSupported);
				printf("\t\tint canUseHostPointerForRegisteredMem = %d\n", args->prop__ref.val.canUseHostPointerForRegisteredMem);
				printf("\t\tint cooperativeLaunch = %d\n", args->prop__ref.val.cooperativeLaunch);
				printf("\t\tint cooperativeMultiDeviceLaunch = %d\n", args->prop__ref.val.cooperativeMultiDeviceLaunch);
				printf("\t\tsize_t sharedMemPerBlockOptin = %lu\n", args->prop__ref.val.sharedMemPerBlockOptin);
				printf("\t\tint pageableMemoryAccessUsesHostPageTables = %d\n", args->prop__ref.val.pageableMemoryAccessUsesHostPageTables);
				printf("\t\tint directManagedMemAccessFromHost = %d\n", args->prop__ref.val.directManagedMemAccessFromHost);
				printf("\t\tint maxBlocksPerMultiProcessor = %d\n", args->prop__ref.val.maxBlocksPerMultiProcessor);
				printf("\t\tint accessPolicyMaxWindowSize = %d\n", args->prop__ref.val.accessPolicyMaxWindowSize);
				printf("\t\tsize_t reservedSharedMemPerBlock = %lu\n", args->prop__ref.val.reservedSharedMemPerBlock);
				printf("\t\tint hostRegisterSupported = %d\n", args->prop__ref.val.hostRegisterSupported);
				printf("\t\tint sparseHipArraySupported = %d\n", args->prop__ref.val.sparseHipArraySupported);
				printf("\t\tint hostRegisterReadOnlySupported = %d\n", args->prop__ref.val.hostRegisterReadOnlySupported);
				printf("\t\tint timelineSemaphoreInteropSupported = %d\n", args->prop__ref.val.timelineSemaphoreInteropSupported);
				printf("\t\tint memoryPoolsSupported = %d\n", args->prop__ref.val.memoryPoolsSupported);
				printf("\t\tint gpuDirectRDMASupported = %d\n", args->prop__ref.val.gpuDirectRDMASupported);
				printf("\t\tunsigned int gpuDirectRDMAFlushWritesOptions = %u\n", args->prop__ref.val.gpuDirectRDMAFlushWritesOptions);
				printf("\t\tint gpuDirectRDMAWritesOrdering = %d\n", args->prop__ref.val.gpuDirectRDMAWritesOrdering);
				printf("\t\tunsigned int memoryPoolSupportedHandleTypes = %u\n", args->prop__ref.val.memoryPoolSupportedHandleTypes);
				printf("\t\tint deferredMappingHipArraySupported = %d\n", args->prop__ref.val.deferredMappingHipArraySupported);
				printf("\t\tint ipcEventSupported = %d\n", args->prop__ref.val.ipcEventSupported);
				printf("\t\tint clusterLaunch = %d\n", args->prop__ref.val.clusterLaunch);
				printf("\t\tint unifiedFunctionPointers = %d\n", args->prop__ref.val.unifiedFunctionPointers);
				printf("\t\tint[63] reserved = %d\n", args->prop__ref.val.reserved[0]);
				printf("\t\tint[32] hipReserved = %d\n", args->prop__ref.val.hipReserved[0]);
				printf("\t\tchar[256] gcnArchName = %c\n", args->prop__ref.val.gcnArchName[0]);
				printf("\t\tsize_t maxSharedMemoryPerMultiProcessor = %lu\n", args->prop__ref.val.maxSharedMemoryPerMultiProcessor);
				printf("\t\tint clockInstructionRate = %d\n", args->prop__ref.val.clockInstructionRate);
				printf("\t\thipDeviceArch_t arch = {\n");
				printf("\t\t\tunsigned int hasGlobalInt32Atomics = %u\n", args->prop__ref.val.arch.hasGlobalInt32Atomics);
				printf("\t\t\tunsigned int hasGlobalFloatAtomicExch = %u\n", args->prop__ref.val.arch.hasGlobalFloatAtomicExch);
				printf("\t\t\tunsigned int hasSharedInt32Atomics = %u\n", args->prop__ref.val.arch.hasSharedInt32Atomics);
				printf("\t\t\tunsigned int hasSharedFloatAtomicExch = %u\n", args->prop__ref.val.arch.hasSharedFloatAtomicExch);
				printf("\t\t\tunsigned int hasFloatAtomicAdd = %u\n", args->prop__ref.val.arch.hasFloatAtomicAdd);
				printf("\t\t\tunsigned int hasGlobalInt64Atomics = %u\n", args->prop__ref.val.arch.hasGlobalInt64Atomics);
				printf("\t\t\tunsigned int hasSharedInt64Atomics = %u\n", args->prop__ref.val.arch.hasSharedInt64Atomics);
				printf("\t\t\tunsigned int hasDoubles = %u\n", args->prop__ref.val.arch.hasDoubles);
				printf("\t\t\tunsigned int hasWarpVote = %u\n", args->prop__ref.val.arch.hasWarpVote);
				printf("\t\t\tunsigned int hasWarpBallot = %u\n", args->prop__ref.val.arch.hasWarpBallot);
				printf("\t\t\tunsigned int hasWarpShuffle = %u\n", args->prop__ref.val.arch.hasWarpShuffle);
				printf("\t\t\tunsigned int hasFunnelShift = %u\n", args->prop__ref.val.arch.hasFunnelShift);
				printf("\t\t\tunsigned int hasThreadFenceSystem = %u\n", args->prop__ref.val.arch.hasThreadFenceSystem);
				printf("\t\t\tunsigned int hasSyncThreadsExt = %u\n", args->prop__ref.val.arch.hasSyncThreadsExt);
				printf("\t\t\tunsigned int hasSurfaceFuncs = %u\n", args->prop__ref.val.arch.hasSurfaceFuncs);
				printf("\t\t\tunsigned int has3dGrid = %u\n", args->prop__ref.val.arch.has3dGrid);
				printf("\t\t\tunsigned int hasDynamicParallelism = %u\n", args->prop__ref.val.arch.hasDynamicParallelism);
				printf("\t\t}\n");
				printf("\t\tint cooperativeMultiDeviceUnmatchedFunc = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedFunc);
				printf("\t\tint cooperativeMultiDeviceUnmatchedGridDim = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedGridDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedBlockDim = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedBlockDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedSharedMem = %d\n", args->prop__ref.val.cooperativeMultiDeviceUnmatchedSharedMem);
				printf("\t\tint isLargeBar = %d\n", args->prop__ref.val.isLargeBar);
				printf("\t\tint asicRevision = %d\n", args->prop__ref.val.asicRevision);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefSetMipmappedArray
		case HIP_API_ID_hipTexRefSetMipmappedArray : {
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	struct hipMipmappedArray * mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	unsigned int Flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefSetMipmappedArray_t* args = (args_hipTexRefSetMipmappedArray_t*) func_args;
			printf("\ttextureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tstruct hipMipmappedArray * mipmappedArray = %p", args->mipmappedArray);
			if (args->mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int Flags = %u\n", args->Flags);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipMemset
		case HIP_API_ID_hipMemset : {
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			args_hipMemset_t* args = (args_hipMemset_t*) func_args;
			printf("\tvoid * dst = %p", args->dst);
			printf("\n");
			printf("\tint value = %d\n", args->value);
			printf("\tsize_t sizeBytes = %lu\n", args->sizeBytes);
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
		#if HAVE_hipTexRefGetMipmapLevelClamp
		case HIP_API_ID_hipTexRefGetMipmapLevelClamp : {
			//	float * pminMipmapLevelClamp (float *);
			//	float * pmaxMipmapLevelClamp (float *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			args_hipTexRefGetMipmapLevelClamp_t* args = (args_hipTexRefGetMipmapLevelClamp_t*) func_args;
			printf("\tfloat * pminMipmapLevelClamp = %p", args->pminMipmapLevelClamp);
			if (args->pminMipmapLevelClamp != NULL) {
				printf(" -> %f\n", args->pminMipmapLevelClamp__ref.val);
			} else { printf("\n"); };
			printf("\tfloat * pmaxMipmapLevelClamp = %p", args->pmaxMipmapLevelClamp);
			if (args->pmaxMipmapLevelClamp != NULL) {
				printf(" -> %f\n", args->pmaxMipmapLevelClamp__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->texRef);
			if (args->texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->retval);
			break;

		}
		#endif
        default : break;
    }
}