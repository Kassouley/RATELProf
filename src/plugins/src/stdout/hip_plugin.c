/** THIS FILE HAS BEEN AUTOMATICALLY GENERATED BY THE GILDA TOOL.
 * DO NOT MODIFY UNLESS YOU KNOW WHAT YOU ARE DOING.
 * ANY CHANGES MAY BE OVERWRITTEN BY SUBSEQUENT RUNS OF GILDA. 
 */
 
#include <stdio.h>
#include <ratelprof.h>
#include "hip_plugin.h"

void on_enter_hip_callback(ratelprof_domain_t domain, ratelprof_api_id_t id, void* user_activity)
{
    ratelprof_api_activity_t* activity = (ratelprof_api_activity_t*)user_activity;
    get_hip_pointed_args_for(id, &activity->hip_args, 1);
    activity->phase = ratelprof_get_current_phase();
    activity->domain = domain;
    get_correlation_id(&activity->corr_id);
    get_id(&activity->id);
    activity->funid = id;
}

void on_exit_hip_callback(ratelprof_domain_t domain, ratelprof_api_id_t id, void* user_activity)
{
    ratelprof_api_activity_t* activity = (ratelprof_api_activity_t*)user_activity;
    get_hip_pointed_args_for(id, &activity->hip_args, 0);
    activity->pid = get_pid();
    activity->tid = get_tid();
    printf("-----------\n");
    printf("PHASE:%d : %s | ID: %lu | CID: %lu\n", activity->phase, get_hip_funame_by_id(activity->funid), activity->id, activity->corr_id);
    ratelprof_get_and_print_location(activity->return_address);
    process_hip_args_for(activity->funid, &activity->hip_args, NULL);
    pop_id();
}

void process_hip_args_for(hip_api_id_t funid, const hip_api_args_t* args, void* user_args)
{
    switch(funid) {
		#if HAVE_hipMemPtrGetInfo
		case HIP_API_ID_hipMemPtrGetInfo :
			//	void * ptr (void *);
			//	size_t * size (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipMemPtrGetInfo.ptr);
			printf("\n");
			printf("\tsize_t * size = %p", args->hipMemPtrGetInfo.size);
			if (args->hipMemPtrGetInfo.size != NULL) {
				printf(" -> %lu\n", args->hipMemPtrGetInfo.size__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemPtrGetInfo.retval);
			break;

		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParams1D
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParams1D :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecMemcpyNodeSetParams1D.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecMemcpyNodeSetParams1D.node);
			printf("\n");
			printf("\tvoid * dst = %p", args->hipGraphExecMemcpyNodeSetParams1D.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipGraphExecMemcpyNodeSetParams1D.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphExecMemcpyNodeSetParams1D.count);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphExecMemcpyNodeSetParams1D.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphExecMemcpyNodeSetParams1D.retval);
			break;

		#endif
		#if HAVE_hipCtxEnablePeerAccess
		case HIP_API_ID_hipCtxEnablePeerAccess :
			//	hipCtx_t peerCtx (struct ihipCtx_t *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t peerCtx = %p", args->hipCtxEnablePeerAccess.peerCtx);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipCtxEnablePeerAccess.flags);
			printf("\thipError_t retval = %d\n", args->hipCtxEnablePeerAccess.retval);
			break;

		#endif
		#if HAVE_hipHostUnregister
		case HIP_API_ID_hipHostUnregister :
			//	void * hostPtr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * hostPtr = %p", args->hipHostUnregister.hostPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipHostUnregister.retval);
			break;

		#endif
		#if HAVE_hipDevicePrimaryCtxGetState
		case HIP_API_ID_hipDevicePrimaryCtxGetState :
			//	hipDevice_t dev (int);
			//	unsigned int * flags (unsigned int *);
			//	int * active (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDevice_t dev = %d\n", args->hipDevicePrimaryCtxGetState.dev);
			printf("\tunsigned int * flags = %p", args->hipDevicePrimaryCtxGetState.flags);
			if (args->hipDevicePrimaryCtxGetState.flags != NULL) {
				printf(" -> %u\n", args->hipDevicePrimaryCtxGetState.flags__ref.val);
			} else { printf("\n"); };
			printf("\tint * active = %p", args->hipDevicePrimaryCtxGetState.active);
			if (args->hipDevicePrimaryCtxGetState.active != NULL) {
				printf(" -> %d\n", args->hipDevicePrimaryCtxGetState.active__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDevicePrimaryCtxGetState.retval);
			break;

		#endif
		#if HAVE_hipPointerGetAttribute
		case HIP_API_ID_hipPointerGetAttribute :
			//	void * data (void *);
			//	hipPointer_attribute attribute (enum hipPointer_attribute);
			//	hipDeviceptr_t ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * data = %p", args->hipPointerGetAttribute.data);
			printf("\n");
			printf("\thipPointer_attribute attribute = %d\n", args->hipPointerGetAttribute.attribute);
			printf("\thipDeviceptr_t ptr = %p", args->hipPointerGetAttribute.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipPointerGetAttribute.retval);
			break;

		#endif
		#if HAVE_hipMemPoolGetAccess
		case HIP_API_ID_hipMemPoolGetAccess :
			//	hipMemAccessFlags * flags (enum hipMemAccessFlags*);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemLocation * location ({
			//		hipMemLocationType type (enum hipMemLocationType);
			//		int id (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemAccessFlags * flags = %p", args->hipMemPoolGetAccess.flags);
			if (args->hipMemPoolGetAccess.flags != NULL) {
				printf(" -> %d\n", args->hipMemPoolGetAccess.flags__ref.val);
			} else { printf("\n"); };
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolGetAccess.mem_pool);
			printf("\n");
			printf("\thipMemLocation * location = %p", args->hipMemPoolGetAccess.location);
			if (args->hipMemPoolGetAccess.location != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocationType type = %d\n", args->hipMemPoolGetAccess.location__ref.val.type);
				printf("\t\tint id = %d\n", args->hipMemPoolGetAccess.location__ref.val.id);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemPoolGetAccess.retval);
			break;

		#endif
		#if HAVE_hipMemsetD32
		case HIP_API_ID_hipMemsetD32 :
			//	hipDeviceptr_t dest (void *);
			//	int value (int);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dest = %p", args->hipMemsetD32.dest);
			printf("\n");
			printf("\tint value = %d\n", args->hipMemsetD32.value);
			printf("\tsize_t count = %lu\n", args->hipMemsetD32.count);
			printf("\thipError_t retval = %d\n", args->hipMemsetD32.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetMipMappedArray
		case HIP_API_ID_hipTexRefGetMipMappedArray :
			//	hipMipmappedArray_t * pArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipMipmappedArray_t * pArray = %p", args->hipTexRefGetMipMappedArray.pArray);
			if (args->hipTexRefGetMipMappedArray.pArray != NULL) {
				printf("-> %p", args->hipTexRefGetMipMappedArray.pArray__ref.ptr1);
				if (args->hipTexRefGetMipMappedArray.pArray__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->hipTexRefGetMipMappedArray.pArray__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetMipMappedArray.texRef);
			if (args->hipTexRefGetMipMappedArray.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetMipMappedArray.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetMipMappedArray.retval);
			break;

		#endif
		#if HAVE_hipMalloc3D
		case HIP_API_ID_hipMalloc3D :
			//	hipPitchedPtr * pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipPitchedPtr * pitchedDevPtr = %p", args->hipMalloc3D.pitchedDevPtr);
			if (args->hipMalloc3D.pitchedDevPtr != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t pitch = %lu\n", args->hipMalloc3D.pitchedDevPtr__ref.val.pitch);
				printf("\t\tsize_t xsize = %lu\n", args->hipMalloc3D.pitchedDevPtr__ref.val.xsize);
				printf("\t\tsize_t ysize = %lu\n", args->hipMalloc3D.pitchedDevPtr__ref.val.ysize);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMalloc3D.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMalloc3D.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMalloc3D.extent.depth);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->hipMalloc3D.retval);
			break;

		#endif
		#if HAVE_hipMemsetD8
		case HIP_API_ID_hipMemsetD8 :
			//	hipDeviceptr_t dest (void *);
			//	unsigned char value (unsigned char);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dest = %p", args->hipMemsetD8.dest);
			printf("\n");
			printf("\tunsigned char value = %hhu\n", args->hipMemsetD8.value);
			printf("\tsize_t count = %lu\n", args->hipMemsetD8.count);
			printf("\thipError_t retval = %d\n", args->hipMemsetD8.retval);
			break;

		#endif
		#if HAVE_hipMallocArray
		case HIP_API_ID_hipMallocArray :
			//	hipArray_t * array (struct hipArray **);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * array = %p", args->hipMallocArray.array);
			if (args->hipMallocArray.array != NULL) {
				printf(" -> %p\n", args->hipMallocArray.array__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipChannelFormatDesc * desc = %p", args->hipMallocArray.desc);
			if (args->hipMallocArray.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipMallocArray.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipMallocArray.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipMallocArray.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipMallocArray.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipMallocArray.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t width = %lu\n", args->hipMallocArray.width);
			printf("\tsize_t height = %lu\n", args->hipMallocArray.height);
			printf("\tunsigned int flags = %u\n", args->hipMallocArray.flags);
			printf("\thipError_t retval = %d\n", args->hipMallocArray.retval);
			break;

		#endif
		#if HAVE_hipGraphEventWaitNodeGetEvent
		case HIP_API_ID_hipGraphEventWaitNodeGetEvent :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t * event_out (struct ihipEvent_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphEventWaitNodeGetEvent.node);
			printf("\n");
			printf("\thipEvent_t * event_out = %p", args->hipGraphEventWaitNodeGetEvent.event_out);
			if (args->hipGraphEventWaitNodeGetEvent.event_out != NULL) {
				printf(" -> %p\n", args->hipGraphEventWaitNodeGetEvent.event_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphEventWaitNodeGetEvent.retval);
			break;

		#endif
		#if HAVE_hipDrvMemcpy3D
		case HIP_API_ID_hipDrvMemcpy3D :
			//	const HIP_MEMCPY3D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		size_t srcZ (unsigned long);
			//		size_t srcLOD (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t srcHeight (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		size_t dstZ (unsigned long);
			//		size_t dstLOD (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t dstHeight (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst HIP_MEMCPY3D * pCopy = %p", args->hipDrvMemcpy3D.pCopy);
			if (args->hipDrvMemcpy3D.pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcY);
				printf("\t\tsize_t srcZ = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcZ);
				printf("\t\tsize_t srcLOD = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcLOD);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcPitch);
				printf("\t\tsize_t srcHeight = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.srcHeight);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstY);
				printf("\t\tsize_t dstZ = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstZ);
				printf("\t\tsize_t dstLOD = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstLOD);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstPitch);
				printf("\t\tsize_t dstHeight = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.dstHeight);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->hipDrvMemcpy3D.pCopy__ref.val.Depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDrvMemcpy3D.retval);
			break;

		#endif
		#if HAVE_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
		case HIP_API_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags :
			//	int * numBlocks (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * numBlocks = %p", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks);
			if (args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks != NULL) {
				printf(" -> %d\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk);
			printf("\tunsigned int flags = %u\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.retval);
			break;

		#endif
		#if HAVE_hipHostMalloc
		case HIP_API_ID_hipHostMalloc :
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipHostMalloc.ptr);
			if (args->hipHostMalloc.ptr != NULL) {
				printf("-> %p", args->hipHostMalloc.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipHostMalloc.size);
			printf("\tunsigned int flags = %u\n", args->hipHostMalloc.flags);
			printf("\thipError_t retval = %d\n", args->hipHostMalloc.retval);
			break;

		#endif
		#if HAVE_hipModuleGetTexRef
		case HIP_API_ID_hipModuleGetTexRef :
			//	textureReference ** texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipModule_t hmod (struct ihipModule_t *);
			//	const char * name (const char *);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference ** texRef = %p", args->hipModuleGetTexRef.texRef);
			if (args->hipModuleGetTexRef.texRef != NULL) {
				printf("-> %p", args->hipModuleGetTexRef.texRef__ref.ptr1);
				if (args->hipModuleGetTexRef.texRef__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tint normalized = %d\n", args->hipModuleGetTexRef.texRef__ref.val.normalized);
					printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipModuleGetTexRef.texRef__ref.val.readMode);
					printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipModuleGetTexRef.texRef__ref.val.filterMode);
					printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipModuleGetTexRef.texRef__ref.val.addressMode[0]);
					printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
					printf("\t\t\tint x = %d\n", args->hipModuleGetTexRef.texRef__ref.val.channelDesc.x);
					printf("\t\t\tint y = %d\n", args->hipModuleGetTexRef.texRef__ref.val.channelDesc.y);
					printf("\t\t\tint z = %d\n", args->hipModuleGetTexRef.texRef__ref.val.channelDesc.z);
					printf("\t\t\tint w = %d\n", args->hipModuleGetTexRef.texRef__ref.val.channelDesc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipModuleGetTexRef.texRef__ref.val.channelDesc.f);
					printf("\t\t}\n");
					printf("\t\tint sRGB = %d\n", args->hipModuleGetTexRef.texRef__ref.val.sRGB);
					printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipModuleGetTexRef.texRef__ref.val.maxAnisotropy);
					printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipModuleGetTexRef.texRef__ref.val.mipmapFilterMode);
					printf("\t\tfloat mipmapLevelBias = %f\n", args->hipModuleGetTexRef.texRef__ref.val.mipmapLevelBias);
					printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipModuleGetTexRef.texRef__ref.val.minMipmapLevelClamp);
					printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipModuleGetTexRef.texRef__ref.val.maxMipmapLevelClamp);
					printf("\t\tint numChannels = %d\n", args->hipModuleGetTexRef.texRef__ref.val.numChannels);
					printf("\t\tenum hipArray_Format format = %d\n", args->hipModuleGetTexRef.texRef__ref.val.format);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipModule_t hmod = %p", args->hipModuleGetTexRef.hmod);
			printf("\n");
			printf("\tconst char * name = %p", args->hipModuleGetTexRef.name);
			if (args->hipModuleGetTexRef.name != NULL) {
				printf(" -> %s\n", args->hipModuleGetTexRef.name__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleGetTexRef.retval);
			break;

		#endif
		#if HAVE_hipIpcGetMemHandle
		case HIP_API_ID_hipIpcGetMemHandle :
			//	hipIpcMemHandle_t * handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	void * devPtr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipIpcMemHandle_t * handle = %p", args->hipIpcGetMemHandle.handle);
			if (args->hipIpcGetMemHandle.handle != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[64] reserved = %c\n", args->hipIpcGetMemHandle.handle__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tvoid * devPtr = %p", args->hipIpcGetMemHandle.devPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipIpcGetMemHandle.retval);
			break;

		#endif
		#if HAVE_hipMemcpyDtoHAsync
		case HIP_API_ID_hipMemcpyDtoHAsync :
			//	void * dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyDtoHAsync.dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->hipMemcpyDtoHAsync.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyDtoHAsync.sizeBytes);
			printf("\thipStream_t stream = %p", args->hipMemcpyDtoHAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyDtoHAsync.retval);
			break;

		#endif
		#if HAVE_hipModuleLoad
		case HIP_API_ID_hipModuleLoad :
			//	hipModule_t * module (struct ihipModule_t **);
			//	const char * fname (const char *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipModule_t * module = %p", args->hipModuleLoad.module);
			if (args->hipModuleLoad.module != NULL) {
				printf(" -> %p\n", args->hipModuleLoad.module__ref.val);
			} else { printf("\n"); };
			printf("\tconst char * fname = %p", args->hipModuleLoad.fname);
			if (args->hipModuleLoad.fname != NULL) {
				printf(" -> %s\n", args->hipModuleLoad.fname__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleLoad.retval);
			break;

		#endif
		#if HAVE_hipWaitExternalSemaphoresAsync
		case HIP_API_ID_hipWaitExternalSemaphoresAsync :
			//	const hipExternalSemaphore_t * extSemArray (const void * *);
			//	const hipExternalSemaphoreWaitParams * paramsArray ({
			//		struct (unnamed struct at header/hip/hip.h:1505:2) params ({
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	unsigned int numExtSems (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst hipExternalSemaphore_t * extSemArray = %p", args->hipWaitExternalSemaphoresAsync.extSemArray);
			if (args->hipWaitExternalSemaphoresAsync.extSemArray != NULL) {
				printf("-> %p", args->hipWaitExternalSemaphoresAsync.extSemArray__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalSemaphoreWaitParams * paramsArray = %p", args->hipWaitExternalSemaphoresAsync.paramsArray);
			if (args->hipWaitExternalSemaphoresAsync.paramsArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1505:2) params = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->hipWaitExternalSemaphoresAsync.paramsArray__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipWaitExternalSemaphoresAsync.paramsArray__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numExtSems = %u\n", args->hipWaitExternalSemaphoresAsync.numExtSems);
			printf("\thipStream_t stream = %p", args->hipWaitExternalSemaphoresAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipWaitExternalSemaphoresAsync.retval);
			break;

		#endif
		#if HAVE_hipGraphKernelNodeGetParams
		case HIP_API_ID_hipGraphKernelNodeGetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphKernelNodeGetParams.node);
			printf("\n");
			printf("\thipKernelNodeParams * pNodeParams = %p", args->hipGraphKernelNodeGetParams.pNodeParams);
			if (args->hipGraphKernelNodeGetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->hipGraphKernelNodeGetParams.pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphKernelNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipGraphLaunch
		case HIP_API_ID_hipGraphLaunch :
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t graphExec = %p", args->hipGraphLaunch.graphExec);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipGraphLaunch.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphLaunch.retval);
			break;

		#endif
		#if HAVE_hipHostAlloc
		case HIP_API_ID_hipHostAlloc :
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipHostAlloc.ptr);
			if (args->hipHostAlloc.ptr != NULL) {
				printf("-> %p", args->hipHostAlloc.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipHostAlloc.size);
			printf("\tunsigned int flags = %u\n", args->hipHostAlloc.flags);
			printf("\thipError_t retval = %d\n", args->hipHostAlloc.retval);
			break;

		#endif
		#if HAVE_hipSetDevice
		case HIP_API_ID_hipSetDevice :
			//	int deviceId (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint deviceId = %d\n", args->hipSetDevice.deviceId);
			printf("\thipError_t retval = %d\n", args->hipSetDevice.retval);
			break;

		#endif
		#if HAVE_hipModuleOccupancyMaxPotentialBlockSizeWithFlags
		case HIP_API_ID_hipModuleOccupancyMaxPotentialBlockSizeWithFlags :
			//	int * gridSize (int *);
			//	int * blockSize (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	int blockSizeLimit (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * gridSize = %p", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize);
			if (args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize != NULL) {
				printf(" -> %d\n", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.gridSize__ref.val);
			} else { printf("\n"); };
			printf("\tint * blockSize = %p", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize);
			if (args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize != NULL) {
				printf(" -> %d\n", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSize__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.f);
			printf("\n");
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.dynSharedMemPerBlk);
			printf("\tint blockSizeLimit = %d\n", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.blockSizeLimit);
			printf("\tunsigned int flags = %u\n", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipModuleOccupancyMaxPotentialBlockSizeWithFlags.retval);
			break;

		#endif
		#if HAVE_hipGraphNodeGetDependentNodes
		case HIP_API_ID_hipGraphNodeGetDependentNodes :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraphNode_t * pDependentNodes (struct hipGraphNode **);
			//	size_t * pNumDependentNodes (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphNodeGetDependentNodes.node);
			printf("\n");
			printf("\thipGraphNode_t * pDependentNodes = %p", args->hipGraphNodeGetDependentNodes.pDependentNodes);
			if (args->hipGraphNodeGetDependentNodes.pDependentNodes != NULL) {
				printf(" -> %p\n", args->hipGraphNodeGetDependentNodes.pDependentNodes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * pNumDependentNodes = %p", args->hipGraphNodeGetDependentNodes.pNumDependentNodes);
			if (args->hipGraphNodeGetDependentNodes.pNumDependentNodes != NULL) {
				printf(" -> %lu\n", args->hipGraphNodeGetDependentNodes.pNumDependentNodes__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphNodeGetDependentNodes.retval);
			break;

		#endif
		#if HAVE_hipExtStreamGetCUMask
		case HIP_API_ID_hipExtStreamGetCUMask :
			//	hipStream_t stream (struct ihipStream_t *);
			//	uint32_t cuMaskSize (unsigned int);
			//	uint32_t * cuMask (unsigned int*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipExtStreamGetCUMask.stream);
			printf("\n");
			printf("\tuint32_t cuMaskSize = %u\n", args->hipExtStreamGetCUMask.cuMaskSize);
			printf("\tuint32_t * cuMask = %p", args->hipExtStreamGetCUMask.cuMask);
			if (args->hipExtStreamGetCUMask.cuMask != NULL) {
				printf(" -> %u\n", args->hipExtStreamGetCUMask.cuMask__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipExtStreamGetCUMask.retval);
			break;

		#endif
		#if HAVE_hipMemsetD16
		case HIP_API_ID_hipMemsetD16 :
			//	hipDeviceptr_t dest (void *);
			//	unsigned short value (unsigned short);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dest = %p", args->hipMemsetD16.dest);
			printf("\n");
			printf("\tunsigned short value = %hu\n", args->hipMemsetD16.value);
			printf("\tsize_t count = %lu\n", args->hipMemsetD16.count);
			printf("\thipError_t retval = %d\n", args->hipMemsetD16.retval);
			break;

		#endif
		#if HAVE_hipLaunchKernel
		case HIP_API_ID_hipLaunchKernel :
			//	const void * function_address (const void *);
			//	dim3 numBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 dimBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** args (void **);
			//	size_t sharedMemBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * function_address = %p", args->hipLaunchKernel.function_address);
			printf("\n");
			printf("\tdim3 numBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchKernel.numBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchKernel.numBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchKernel.numBlocks.z);
			printf("\t}\n");
			printf("\tdim3 dimBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchKernel.dimBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchKernel.dimBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchKernel.dimBlocks.z);
			printf("\t}\n");
			printf("\tvoid ** args = %p", args->hipLaunchKernel.args);
			if (args->hipLaunchKernel.args != NULL) {
				printf("-> %p", args->hipLaunchKernel.args__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sharedMemBytes = %lu\n", args->hipLaunchKernel.sharedMemBytes);
			printf("\thipStream_t stream = %p", args->hipLaunchKernel.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchKernel.retval);
			break;

		#endif
		#if HAVE_hipGetErrorString
		case HIP_API_ID_hipGetErrorString :
			//	hipError_t hipError (enum hipError_t);
			//	const char * retval (const char *);
			printf("\thipError_t hipError = %d\n", args->hipGetErrorString.hipError);
			printf("\tconst char * retval = %p", args->hipGetErrorString.retval);
			if (args->hipGetErrorString.retval != NULL) {
				printf(" -> %s\n", args->hipGetErrorString.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipModuleLoadDataEx
		case HIP_API_ID_hipModuleLoadDataEx :
			//	hipModule_t * module (struct ihipModule_t **);
			//	const void * image (const void *);
			//	unsigned int numOptions (unsigned int);
			//	hipJitOption * options (enum hipJitOption*);
			//	void ** optionValues (void **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipModule_t * module = %p", args->hipModuleLoadDataEx.module);
			if (args->hipModuleLoadDataEx.module != NULL) {
				printf(" -> %p\n", args->hipModuleLoadDataEx.module__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * image = %p", args->hipModuleLoadDataEx.image);
			printf("\n");
			printf("\tunsigned int numOptions = %u\n", args->hipModuleLoadDataEx.numOptions);
			printf("\thipJitOption * options = %p", args->hipModuleLoadDataEx.options);
			if (args->hipModuleLoadDataEx.options != NULL) {
				printf(" -> %d\n", args->hipModuleLoadDataEx.options__ref.val);
			} else { printf("\n"); };
			printf("\tvoid ** optionValues = %p", args->hipModuleLoadDataEx.optionValues);
			if (args->hipModuleLoadDataEx.optionValues != NULL) {
				printf("-> %p", args->hipModuleLoadDataEx.optionValues__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleLoadDataEx.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetFilterMode
		case HIP_API_ID_hipTexRefGetFilterMode :
			//	enum hipTextureFilterMode * pfm (enum hipTextureFilterMode *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tenum hipTextureFilterMode * pfm = %p", args->hipTexRefGetFilterMode.pfm);
			if (args->hipTexRefGetFilterMode.pfm != NULL) {
				printf(" -> %d\n", args->hipTexRefGetFilterMode.pfm__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetFilterMode.texRef);
			if (args->hipTexRefGetFilterMode.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetFilterMode.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetFilterMode.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetFilterMode.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetFilterMode.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetFilterMode.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetFilterMode.retval);
			break;

		#endif
		#if HAVE_hipGraphInstantiateWithParams
		case HIP_API_ID_hipGraphInstantiateWithParams :
			//	hipGraphExec_t * pGraphExec (struct hipGraphExec **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphInstantiateParams * instantiateParams ({
			//		hipGraphNode_t errNode_out (struct hipGraphNode *);
			//		unsigned long long flags (unsigned long long);
			//		hipGraphInstantiateResult result_out (enum hipGraphInstantiateResult);
			//		hipStream_t uploadStream (struct ihipStream_t *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t * pGraphExec = %p", args->hipGraphInstantiateWithParams.pGraphExec);
			if (args->hipGraphInstantiateWithParams.pGraphExec != NULL) {
				printf(" -> %p\n", args->hipGraphInstantiateWithParams.pGraphExec__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphInstantiateWithParams.graph);
			printf("\n");
			printf("\thipGraphInstantiateParams * instantiateParams = %p", args->hipGraphInstantiateWithParams.instantiateParams);
			if (args->hipGraphInstantiateWithParams.instantiateParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned long long flags = %llu\n", args->hipGraphInstantiateWithParams.instantiateParams__ref.val.flags);
				printf("\t\thipGraphInstantiateResult result_out = %d\n", args->hipGraphInstantiateWithParams.instantiateParams__ref.val.result_out);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphInstantiateWithParams.retval);
			break;

		#endif
		#if HAVE_hipGraphMemcpyNodeSetParams1D
		case HIP_API_ID_hipGraphMemcpyNodeSetParams1D :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemcpyNodeSetParams1D.node);
			printf("\n");
			printf("\tvoid * dst = %p", args->hipGraphMemcpyNodeSetParams1D.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipGraphMemcpyNodeSetParams1D.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphMemcpyNodeSetParams1D.count);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphMemcpyNodeSetParams1D.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphMemcpyNodeSetParams1D.retval);
			break;

		#endif
		#if HAVE_hipStreamSynchronize
		case HIP_API_ID_hipStreamSynchronize :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamSynchronize.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipStreamSynchronize.retval);
			break;

		#endif
		#if HAVE_hipGraphicsUnmapResources
		case HIP_API_ID_hipGraphicsUnmapResources :
			//	int count (int);
			//	hipGraphicsResource_t * resources (struct _hipGraphicsResource**);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint count = %d\n", args->hipGraphicsUnmapResources.count);
			printf("\thipGraphicsResource_t * resources = %p", args->hipGraphicsUnmapResources.resources);
			if (args->hipGraphicsUnmapResources.resources != NULL) {
				printf(" -> %p\n", args->hipGraphicsUnmapResources.resources__ref.val);
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->hipGraphicsUnmapResources.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphicsUnmapResources.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DFromArray_spt
		case HIP_API_ID_hipMemcpy2DFromArray_spt :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2DFromArray_spt.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2DFromArray_spt.dpitch);
			printf("\thipArray_const_t src = %p", args->hipMemcpy2DFromArray_spt.src);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DFromArray_spt.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DFromArray_spt.hOffset);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DFromArray_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DFromArray_spt.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DFromArray_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DFromArray_spt.retval);
			break;

		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParamsFromSymbol
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParamsFromSymbol :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.node);
			printf("\n");
			printf("\tvoid * dst = %p", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.symbol);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.count);
			printf("\tsize_t offset = %lu\n", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphExecMemcpyNodeSetParamsFromSymbol.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetMipmapLevelBias
		case HIP_API_ID_hipTexRefGetMipmapLevelBias :
			//	float * pbias (float *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tfloat * pbias = %p", args->hipTexRefGetMipmapLevelBias.pbias);
			if (args->hipTexRefGetMipmapLevelBias.pbias != NULL) {
				printf(" -> %f\n", args->hipTexRefGetMipmapLevelBias.pbias__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetMipmapLevelBias.texRef);
			if (args->hipTexRefGetMipmapLevelBias.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetMipmapLevelBias.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetMipmapLevelBias.retval);
			break;

		#endif
		#if HAVE_hipGraphAddExternalSemaphoresSignalNode
		case HIP_API_ID_hipGraphAddExternalSemaphoresSignalNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipExternalSemaphoreSignalNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddExternalSemaphoresSignalNode.pGraphNode);
			if (args->hipGraphAddExternalSemaphoresSignalNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddExternalSemaphoresSignalNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddExternalSemaphoresSignalNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddExternalSemaphoresSignalNode.pDependencies);
			if (args->hipGraphAddExternalSemaphoresSignalNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddExternalSemaphoresSignalNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddExternalSemaphoresSignalNode.numDependencies);
			printf("\tconst hipExternalSemaphoreSignalNodeParams * nodeParams = %p", args->hipGraphAddExternalSemaphoresSignalNode.nodeParams);
			if (args->hipGraphAddExternalSemaphoresSignalNode.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphAddExternalSemaphoresSignalNode.nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddExternalSemaphoresSignalNode.retval);
			break;

		#endif
		#if HAVE_hipExtGetLastError
		case HIP_API_ID_hipExtGetLastError :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipExtGetLastError.retval);
			break;

		#endif
		#if HAVE_hipMemMapArrayAsync
		case HIP_API_ID_hipMemMapArrayAsync :
			//	hipArrayMapInfo * mapInfoList ({
			//		hipResourceType resourceType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:1643:2) resource ({
			//		});
			//		hipArraySparseSubresourceType subresourceType (enum hipArraySparseSubresourceType);
			//		union (unnamed union at header/hip/hip.h:1648:2) subresource ({
			//		});
			//		hipMemOperationType memOperationType (enum hipMemOperationType);
			//		hipMemHandleType memHandleType (enum hipMemHandleType);
			//		union (unnamed union at header/hip/hip.h:1667:2) memHandle ({
			//		});
			//		unsigned long long offset (unsigned long long);
			//		unsigned int deviceBitMask (unsigned int);
			//		unsigned int flags (unsigned int);
			//		unsigned int[2] reserved (unsigned int[2]);
			//	});
			//	unsigned int count (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArrayMapInfo * mapInfoList = %p", args->hipMemMapArrayAsync.mapInfoList);
			if (args->hipMemMapArrayAsync.mapInfoList != NULL) {
				printf(" -> {\n");
				printf("\t\thipResourceType resourceType = %d\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.resourceType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1643:2) resource = {\n");
				printf("\t\t}\n");
				printf("\t\thipArraySparseSubresourceType subresourceType = %d\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.subresourceType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1648:2) subresource = {\n");
				printf("\t\t}\n");
				printf("\t\thipMemOperationType memOperationType = %d\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.memOperationType);
				printf("\t\thipMemHandleType memHandleType = %d\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.memHandleType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1667:2) memHandle = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned long long offset = %llu\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.offset);
				printf("\t\tunsigned int deviceBitMask = %u\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.deviceBitMask);
				printf("\t\tunsigned int flags = %u\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.flags);
				printf("\t\tunsigned int[2] reserved = %u\n", args->hipMemMapArrayAsync.mapInfoList__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int count = %u\n", args->hipMemMapArrayAsync.count);
			printf("\thipStream_t stream = %p", args->hipMemMapArrayAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemMapArrayAsync.retval);
			break;

		#endif
		#if HAVE_hipMemcpyAsync
		case HIP_API_ID_hipMemcpyAsync :
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyAsync.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyAsync.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyAsync.sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyAsync.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyAsync.retval);
			break;

		#endif
		#if HAVE_hipGraphKernelNodeSetAttribute
		case HIP_API_ID_hipGraphKernelNodeSetAttribute :
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipLaunchAttributeID attr (enum hipLaunchAttributeID);
			//	const hipLaunchAttributeValue * value ({
			//		hipAccessPolicyWindow accessPolicyWindow ({
			//			void * base_ptr (void *);
			//			hipAccessProperty hitProp (enum hipAccessProperty);
			//			float hitRatio (float);
			//			hipAccessProperty missProp (enum hipAccessProperty);
			//			size_t num_bytes (unsigned long);
			//		});
			//		int cooperative (int);
			//		int priority (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hNode = %p", args->hipGraphKernelNodeSetAttribute.hNode);
			printf("\n");
			printf("\thipLaunchAttributeID attr = %d\n", args->hipGraphKernelNodeSetAttribute.attr);
			printf("\tconst hipLaunchAttributeValue * value = %p", args->hipGraphKernelNodeSetAttribute.value);
			if (args->hipGraphKernelNodeSetAttribute.value != NULL) {
				printf(" -> {\n");
				printf("\t\thipAccessPolicyWindow accessPolicyWindow = {\n");
				printf("\t\t\thipAccessProperty hitProp = %d\n", args->hipGraphKernelNodeSetAttribute.value__ref.val.accessPolicyWindow.hitProp);
				printf("\t\t\tfloat hitRatio = %f\n", args->hipGraphKernelNodeSetAttribute.value__ref.val.accessPolicyWindow.hitRatio);
				printf("\t\t\thipAccessProperty missProp = %d\n", args->hipGraphKernelNodeSetAttribute.value__ref.val.accessPolicyWindow.missProp);
				printf("\t\t\tsize_t num_bytes = %lu\n", args->hipGraphKernelNodeSetAttribute.value__ref.val.accessPolicyWindow.num_bytes);
				printf("\t\t}\n");
				printf("\t\tint cooperative = %d\n", args->hipGraphKernelNodeSetAttribute.value__ref.val.cooperative);
				printf("\t\tint priority = %d\n", args->hipGraphKernelNodeSetAttribute.value__ref.val.priority);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphKernelNodeSetAttribute.retval);
			break;

		#endif
		#if HAVE_hipDrvMemcpy2DUnaligned
		case HIP_API_ID_hipDrvMemcpy2DUnaligned :
			//	const hip_Memcpy2D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst hip_Memcpy2D * pCopy = %p", args->hipDrvMemcpy2DUnaligned.pCopy);
			if (args->hipDrvMemcpy2DUnaligned.pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.srcY);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.srcPitch);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.dstY);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.dstPitch);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->hipDrvMemcpy2DUnaligned.pCopy__ref.val.Height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDrvMemcpy2DUnaligned.retval);
			break;

		#endif
		#if HAVE_hipMemPoolDestroy
		case HIP_API_ID_hipMemPoolDestroy :
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolDestroy.mem_pool);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemPoolDestroy.retval);
			break;

		#endif
		#if HAVE_hipGraphRemoveDependencies
		case HIP_API_ID_hipGraphRemoveDependencies :
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * from (const struct hipGraphNode * *);
			//	const hipGraphNode_t * to (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphRemoveDependencies.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * from = %p", args->hipGraphRemoveDependencies.from);
			if (args->hipGraphRemoveDependencies.from != NULL) {
				printf(" -> %p\n", args->hipGraphRemoveDependencies.from__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t * to = %p", args->hipGraphRemoveDependencies.to);
			if (args->hipGraphRemoveDependencies.to != NULL) {
				printf(" -> %p\n", args->hipGraphRemoveDependencies.to__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphRemoveDependencies.numDependencies);
			printf("\thipError_t retval = %d\n", args->hipGraphRemoveDependencies.retval);
			break;

		#endif
		#if HAVE_hipGraphCreate
		case HIP_API_ID_hipGraphCreate :
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t * pGraph = %p", args->hipGraphCreate.pGraph);
			if (args->hipGraphCreate.pGraph != NULL) {
				printf(" -> %p\n", args->hipGraphCreate.pGraph__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->hipGraphCreate.flags);
			printf("\thipError_t retval = %d\n", args->hipGraphCreate.retval);
			break;

		#endif
		#if HAVE_hipExtLaunchMultiKernelMultiDevice
		case HIP_API_ID_hipExtLaunchMultiKernelMultiDevice :
			//	hipLaunchParams * launchParamsList ({
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** args (void **);
			//		size_t sharedMem (unsigned long);
			//		hipStream_t stream (struct ihipStream_t *);
			//	});
			//	int numDevices (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipLaunchParams * launchParamsList = %p", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList);
			if (args->hipExtLaunchMultiKernelMultiDevice.launchParamsList != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tsize_t sharedMem = %lu\n", args->hipExtLaunchMultiKernelMultiDevice.launchParamsList__ref.val.sharedMem);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint numDevices = %d\n", args->hipExtLaunchMultiKernelMultiDevice.numDevices);
			printf("\tunsigned int flags = %u\n", args->hipExtLaunchMultiKernelMultiDevice.flags);
			printf("\thipError_t retval = %d\n", args->hipExtLaunchMultiKernelMultiDevice.retval);
			break;

		#endif
		#if HAVE_hipGetDeviceCount
		case HIP_API_ID_hipGetDeviceCount :
			//	int * count (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * count = %p", args->hipGetDeviceCount.count);
			if (args->hipGetDeviceCount.count != NULL) {
				printf(" -> %d\n", args->hipGetDeviceCount.count__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGetDeviceCount.retval);
			break;

		#endif
		#if HAVE_hipMemUnmap
		case HIP_API_ID_hipMemUnmap :
			//	void * ptr (void *);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipMemUnmap.ptr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->hipMemUnmap.size);
			printf("\thipError_t retval = %d\n", args->hipMemUnmap.retval);
			break;

		#endif
		#if HAVE_hipTexObjectGetResourceDesc
		case HIP_API_ID_hipTexObjectGetResourceDesc :
			//	HIP_RESOURCE_DESC * pResDesc ({
			//		HIPresourcetype resType (enum HIPresourcetype_enum);
			//		union (unnamed union at header/hip/hip.h:635:2) res ({
			//		});
			//		unsigned int flags (unsigned int);
			//	});
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\tHIP_RESOURCE_DESC * pResDesc = %p", args->hipTexObjectGetResourceDesc.pResDesc);
			if (args->hipTexObjectGetResourceDesc.pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourcetype resType = %d\n", args->hipTexObjectGetResourceDesc.pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:635:2) res = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->hipTexObjectGetResourceDesc.pResDesc__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t texObject = %p", args->hipTexObjectGetResourceDesc.texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipTexObjectGetResourceDesc.retval);
			break;

		#endif
		#if HAVE_hipGraphExecEventRecordNodeSetEvent
		case HIP_API_ID_hipGraphExecEventRecordNodeSetEvent :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecEventRecordNodeSetEvent.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExecEventRecordNodeSetEvent.hNode);
			printf("\n");
			printf("\thipEvent_t event = %p", args->hipGraphExecEventRecordNodeSetEvent.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphExecEventRecordNodeSetEvent.retval);
			break;

		#endif
		#if HAVE_hipInit
		case HIP_API_ID_hipInit :
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int flags = %u\n", args->hipInit.flags);
			printf("\thipError_t retval = %d\n", args->hipInit.retval);
			break;

		#endif
		#if HAVE_hipThreadExchangeStreamCaptureMode
		case HIP_API_ID_hipThreadExchangeStreamCaptureMode :
			//	hipStreamCaptureMode * mode (enum hipStreamCaptureMode*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStreamCaptureMode * mode = %p", args->hipThreadExchangeStreamCaptureMode.mode);
			if (args->hipThreadExchangeStreamCaptureMode.mode != NULL) {
				printf(" -> %d\n", args->hipThreadExchangeStreamCaptureMode.mode__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipThreadExchangeStreamCaptureMode.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetP2PAttribute
		case HIP_API_ID_hipDeviceGetP2PAttribute :
			//	int * value (int *);
			//	hipDeviceP2PAttr attr (enum hipDeviceP2PAttr);
			//	int srcDevice (int);
			//	int dstDevice (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * value = %p", args->hipDeviceGetP2PAttribute.value);
			if (args->hipDeviceGetP2PAttribute.value != NULL) {
				printf(" -> %d\n", args->hipDeviceGetP2PAttribute.value__ref.val);
			} else { printf("\n"); };
			printf("\thipDeviceP2PAttr attr = %d\n", args->hipDeviceGetP2PAttribute.attr);
			printf("\tint srcDevice = %d\n", args->hipDeviceGetP2PAttribute.srcDevice);
			printf("\tint dstDevice = %d\n", args->hipDeviceGetP2PAttribute.dstDevice);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetP2PAttribute.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetByPCIBusId
		case HIP_API_ID_hipDeviceGetByPCIBusId :
			//	int * device (int *);
			//	const char * pciBusId (const char *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * device = %p", args->hipDeviceGetByPCIBusId.device);
			if (args->hipDeviceGetByPCIBusId.device != NULL) {
				printf(" -> %d\n", args->hipDeviceGetByPCIBusId.device__ref.val);
			} else { printf("\n"); };
			printf("\tconst char * pciBusId = %p", args->hipDeviceGetByPCIBusId.pciBusId);
			if (args->hipDeviceGetByPCIBusId.pciBusId != NULL) {
				printf(" -> %s\n", args->hipDeviceGetByPCIBusId.pciBusId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDeviceGetByPCIBusId.retval);
			break;

		#endif
		#if HAVE_hipHostFree
		case HIP_API_ID_hipHostFree :
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipHostFree.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipHostFree.retval);
			break;

		#endif
		#if HAVE_hipExtGetLinkTypeAndHopCount
		case HIP_API_ID_hipExtGetLinkTypeAndHopCount :
			//	int device1 (int);
			//	int device2 (int);
			//	uint32_t * linktype (unsigned int*);
			//	uint32_t * hopcount (unsigned int*);
			//	hipError_t retval (enum hipError_t);
			printf("\tint device1 = %d\n", args->hipExtGetLinkTypeAndHopCount.device1);
			printf("\tint device2 = %d\n", args->hipExtGetLinkTypeAndHopCount.device2);
			printf("\tuint32_t * linktype = %p", args->hipExtGetLinkTypeAndHopCount.linktype);
			if (args->hipExtGetLinkTypeAndHopCount.linktype != NULL) {
				printf(" -> %u\n", args->hipExtGetLinkTypeAndHopCount.linktype__ref.val);
			} else { printf("\n"); };
			printf("\tuint32_t * hopcount = %p", args->hipExtGetLinkTypeAndHopCount.hopcount);
			if (args->hipExtGetLinkTypeAndHopCount.hopcount != NULL) {
				printf(" -> %u\n", args->hipExtGetLinkTypeAndHopCount.hopcount__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipExtGetLinkTypeAndHopCount.retval);
			break;

		#endif
		#if HAVE_hipMemcpyToSymbolAsync_spt
		case HIP_API_ID_hipMemcpyToSymbolAsync_spt :
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * symbol = %p", args->hipMemcpyToSymbolAsync_spt.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyToSymbolAsync_spt.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyToSymbolAsync_spt.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyToSymbolAsync_spt.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyToSymbolAsync_spt.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyToSymbolAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyToSymbolAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipCtxDisablePeerAccess
		case HIP_API_ID_hipCtxDisablePeerAccess :
			//	hipCtx_t peerCtx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t peerCtx = %p", args->hipCtxDisablePeerAccess.peerCtx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipCtxDisablePeerAccess.retval);
			break;

		#endif
		#if HAVE_hipSetupArgument
		case HIP_API_ID_hipSetupArgument :
			//	const void * arg (const void *);
			//	size_t size (unsigned long);
			//	size_t offset (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * arg = %p", args->hipSetupArgument.arg);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->hipSetupArgument.size);
			printf("\tsize_t offset = %lu\n", args->hipSetupArgument.offset);
			printf("\thipError_t retval = %d\n", args->hipSetupArgument.retval);
			break;

		#endif
		#if HAVE_hipMemcpyAtoHAsync
		case HIP_API_ID_hipMemcpyAtoHAsync :
			//	void * dstHost (void *);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t ByteCount (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dstHost = %p", args->hipMemcpyAtoHAsync.dstHost);
			printf("\n");
			printf("\thipArray_t srcArray = %p", args->hipMemcpyAtoHAsync.srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->hipMemcpyAtoHAsync.srcOffset);
			printf("\tsize_t ByteCount = %lu\n", args->hipMemcpyAtoHAsync.ByteCount);
			printf("\thipStream_t stream = %p", args->hipMemcpyAtoHAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyAtoHAsync.retval);
			break;

		#endif
		#if HAVE_hipCtxSetCacheConfig
		case HIP_API_ID_hipCtxSetCacheConfig :
			//	hipFuncCache_t cacheConfig (enum hipFuncCache_t);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFuncCache_t cacheConfig = %d\n", args->hipCtxSetCacheConfig.cacheConfig);
			printf("\thipError_t retval = %d\n", args->hipCtxSetCacheConfig.retval);
			break;

		#endif
		#if HAVE_hipMemRelease
		case HIP_API_ID_hipMemRelease :
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->hipMemRelease.handle);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemRelease.retval);
			break;

		#endif
		#if HAVE_hipUnbindTexture
		case HIP_API_ID_hipUnbindTexture :
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst textureReference * tex = %p", args->hipUnbindTexture.tex);
			if (args->hipUnbindTexture.tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipUnbindTexture.tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipUnbindTexture.tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipUnbindTexture.tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipUnbindTexture.tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipUnbindTexture.tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipUnbindTexture.tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipUnbindTexture.tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipUnbindTexture.tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipUnbindTexture.tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipUnbindTexture.tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipUnbindTexture.tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipUnbindTexture.tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipUnbindTexture.tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipUnbindTexture.tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipUnbindTexture.tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipUnbindTexture.tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipUnbindTexture.tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipUnbindTexture.retval);
			break;

		#endif
		#if HAVE_hipDrvMemcpy3DAsync
		case HIP_API_ID_hipDrvMemcpy3DAsync :
			//	const HIP_MEMCPY3D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		size_t srcZ (unsigned long);
			//		size_t srcLOD (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t srcHeight (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		size_t dstZ (unsigned long);
			//		size_t dstLOD (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t dstHeight (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst HIP_MEMCPY3D * pCopy = %p", args->hipDrvMemcpy3DAsync.pCopy);
			if (args->hipDrvMemcpy3DAsync.pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcY);
				printf("\t\tsize_t srcZ = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcZ);
				printf("\t\tsize_t srcLOD = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcLOD);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcPitch);
				printf("\t\tsize_t srcHeight = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.srcHeight);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstY);
				printf("\t\tsize_t dstZ = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstZ);
				printf("\t\tsize_t dstLOD = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstLOD);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstPitch);
				printf("\t\tsize_t dstHeight = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.dstHeight);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->hipDrvMemcpy3DAsync.pCopy__ref.val.Depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->hipDrvMemcpy3DAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDrvMemcpy3DAsync.retval);
			break;

		#endif
		#if HAVE_hipIpcGetEventHandle
		case HIP_API_ID_hipIpcGetEventHandle :
			//	hipIpcEventHandle_t * handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipIpcEventHandle_t * handle = %p", args->hipIpcGetEventHandle.handle);
			if (args->hipIpcGetEventHandle.handle != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[64] reserved = %c\n", args->hipIpcGetEventHandle.handle__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipEvent_t event = %p", args->hipIpcGetEventHandle.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipIpcGetEventHandle.retval);
			break;

		#endif
		#if HAVE_hipGraphReleaseUserObject
		case HIP_API_ID_hipGraphReleaseUserObject :
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphReleaseUserObject.graph);
			printf("\n");
			printf("\thipUserObject_t object = %p", args->hipGraphReleaseUserObject.object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->hipGraphReleaseUserObject.count);
			printf("\thipError_t retval = %d\n", args->hipGraphReleaseUserObject.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetMemPool
		case HIP_API_ID_hipDeviceGetMemPool :
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t * mem_pool = %p", args->hipDeviceGetMemPool.mem_pool);
			if (args->hipDeviceGetMemPool.mem_pool != NULL) {
				printf(" -> %p\n", args->hipDeviceGetMemPool.mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tint device = %d\n", args->hipDeviceGetMemPool.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetMemPool.retval);
			break;

		#endif
		#if HAVE_hipGraphHostNodeSetParams
		case HIP_API_ID_hipGraphHostNodeSetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphHostNodeSetParams.node);
			printf("\n");
			printf("\tconst hipHostNodeParams * pNodeParams = %p", args->hipGraphHostNodeSetParams.pNodeParams);
			if (args->hipGraphHostNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->hipGraphHostNodeSetParams.pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphHostNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipGraphAddEventWaitNode
		case HIP_API_ID_hipGraphAddEventWaitNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddEventWaitNode.pGraphNode);
			if (args->hipGraphAddEventWaitNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddEventWaitNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddEventWaitNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddEventWaitNode.pDependencies);
			if (args->hipGraphAddEventWaitNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddEventWaitNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddEventWaitNode.numDependencies);
			printf("\thipEvent_t event = %p", args->hipGraphAddEventWaitNode.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphAddEventWaitNode.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DFromArrayAsync_spt
		case HIP_API_ID_hipMemcpy2DFromArrayAsync_spt :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffsetSrc (unsigned long);
			//	size_t hOffsetSrc (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2DFromArrayAsync_spt.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2DFromArrayAsync_spt.dpitch);
			printf("\thipArray_const_t src = %p", args->hipMemcpy2DFromArrayAsync_spt.src);
			printf("\n");
			printf("\tsize_t wOffsetSrc = %lu\n", args->hipMemcpy2DFromArrayAsync_spt.wOffsetSrc);
			printf("\tsize_t hOffsetSrc = %lu\n", args->hipMemcpy2DFromArrayAsync_spt.hOffsetSrc);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DFromArrayAsync_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DFromArrayAsync_spt.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DFromArrayAsync_spt.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpy2DFromArrayAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DFromArrayAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipLaunchHostFunc_spt
		case HIP_API_ID_hipLaunchHostFunc_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipHostFn_t fn (void (*)(void *));
			//	void * userData (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipLaunchHostFunc_spt.stream);
			printf("\n");
			printf("\thipHostFn_t fn = %p\n", args->hipLaunchHostFunc_spt.fn);
			printf("\tvoid * userData = %p", args->hipLaunchHostFunc_spt.userData);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchHostFunc_spt.retval);
			break;

		#endif
		#if HAVE_hipStreamWaitEvent_spt
		case HIP_API_ID_hipStreamWaitEvent_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamWaitEvent_spt.stream);
			printf("\n");
			printf("\thipEvent_t event = %p", args->hipStreamWaitEvent_spt.event);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipStreamWaitEvent_spt.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamWaitEvent_spt.retval);
			break;

		#endif
		#if HAVE_hipArrayGetDescriptor
		case HIP_API_ID_hipArrayGetDescriptor :
			//	HIP_ARRAY_DESCRIPTOR * pArrayDescriptor ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//	});
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			printf("\tHIP_ARRAY_DESCRIPTOR * pArrayDescriptor = %p", args->hipArrayGetDescriptor.pArrayDescriptor);
			if (args->hipArrayGetDescriptor.pArrayDescriptor != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->hipArrayGetDescriptor.pArrayDescriptor__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->hipArrayGetDescriptor.pArrayDescriptor__ref.val.Height);
				printf("\t\tenum hipArray_Format Format = %d\n", args->hipArrayGetDescriptor.pArrayDescriptor__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->hipArrayGetDescriptor.pArrayDescriptor__ref.val.NumChannels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_t array = %p", args->hipArrayGetDescriptor.array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipArrayGetDescriptor.retval);
			break;

		#endif
		#if HAVE_hipGraphExecUpdate
		case HIP_API_ID_hipGraphExecUpdate :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraph_t hGraph (struct ihipGraph *);
			//	hipGraphNode_t * hErrorNode_out (struct hipGraphNode **);
			//	hipGraphExecUpdateResult * updateResult_out (enum hipGraphExecUpdateResult*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecUpdate.hGraphExec);
			printf("\n");
			printf("\thipGraph_t hGraph = %p", args->hipGraphExecUpdate.hGraph);
			printf("\n");
			printf("\thipGraphNode_t * hErrorNode_out = %p", args->hipGraphExecUpdate.hErrorNode_out);
			if (args->hipGraphExecUpdate.hErrorNode_out != NULL) {
				printf(" -> %p\n", args->hipGraphExecUpdate.hErrorNode_out__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphExecUpdateResult * updateResult_out = %p", args->hipGraphExecUpdate.updateResult_out);
			if (args->hipGraphExecUpdate.updateResult_out != NULL) {
				printf(" -> %d\n", args->hipGraphExecUpdate.updateResult_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecUpdate.retval);
			break;

		#endif
		#if HAVE_hipMemGetAllocationPropertiesFromHandle
		case HIP_API_ID_hipMemGetAllocationPropertiesFromHandle :
			//	hipMemAllocationProp * prop ({
			//		hipMemAllocationType type (enum hipMemAllocationType);
			//		hipMemAllocationHandleType requestedHandleType (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32HandleMetaData (void *);
			//		struct (unnamed struct at header/hip/hip.h:1616:2) allocFlags ({
			//		});
			//	});
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemAllocationProp * prop = %p", args->hipMemGetAllocationPropertiesFromHandle.prop);
			if (args->hipMemGetAllocationPropertiesFromHandle.prop != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType type = %d\n", args->hipMemGetAllocationPropertiesFromHandle.prop__ref.val.type);
				printf("\t\thipMemAllocationHandleType requestedHandleType = %d\n", args->hipMemGetAllocationPropertiesFromHandle.prop__ref.val.requestedHandleType);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->hipMemGetAllocationPropertiesFromHandle.prop__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->hipMemGetAllocationPropertiesFromHandle.prop__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1616:2) allocFlags = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->hipMemGetAllocationPropertiesFromHandle.handle);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemGetAllocationPropertiesFromHandle.retval);
			break;

		#endif
		#if HAVE_hipMemcpyWithStream
		case HIP_API_ID_hipMemcpyWithStream :
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyWithStream.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyWithStream.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyWithStream.sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyWithStream.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyWithStream.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyWithStream.retval);
			break;

		#endif
		#if HAVE_hipGraphAddExternalSemaphoresWaitNode
		case HIP_API_ID_hipGraphAddExternalSemaphoresWaitNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipExternalSemaphoreWaitNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddExternalSemaphoresWaitNode.pGraphNode);
			if (args->hipGraphAddExternalSemaphoresWaitNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddExternalSemaphoresWaitNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddExternalSemaphoresWaitNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddExternalSemaphoresWaitNode.pDependencies);
			if (args->hipGraphAddExternalSemaphoresWaitNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddExternalSemaphoresWaitNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddExternalSemaphoresWaitNode.numDependencies);
			printf("\tconst hipExternalSemaphoreWaitNodeParams * nodeParams = %p", args->hipGraphAddExternalSemaphoresWaitNode.nodeParams);
			if (args->hipGraphAddExternalSemaphoresWaitNode.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphAddExternalSemaphoresWaitNode.nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddExternalSemaphoresWaitNode.retval);
			break;

		#endif
		#if HAVE_hipMemcpyAtoH
		case HIP_API_ID_hipMemcpyAtoH :
			//	void * dst (void *);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyAtoH.dst);
			printf("\n");
			printf("\thipArray_t srcArray = %p", args->hipMemcpyAtoH.srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->hipMemcpyAtoH.srcOffset);
			printf("\tsize_t count = %lu\n", args->hipMemcpyAtoH.count);
			printf("\thipError_t retval = %d\n", args->hipMemcpyAtoH.retval);
			break;

		#endif
		#if HAVE_hipStreamQuery
		case HIP_API_ID_hipStreamQuery :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamQuery.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipStreamQuery.retval);
			break;

		#endif
		#if HAVE_hipIpcCloseMemHandle
		case HIP_API_ID_hipIpcCloseMemHandle :
			//	void * devPtr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * devPtr = %p", args->hipIpcCloseMemHandle.devPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipIpcCloseMemHandle.retval);
			break;

		#endif
		#if HAVE_hipMemsetAsync
		case HIP_API_ID_hipMemsetAsync :
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemsetAsync.dst);
			printf("\n");
			printf("\tint value = %d\n", args->hipMemsetAsync.value);
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemsetAsync.sizeBytes);
			printf("\thipStream_t stream = %p", args->hipMemsetAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemsetAsync.retval);
			break;

		#endif
		#if HAVE_hipMemcpyDtoD
		case HIP_API_ID_hipMemcpyDtoD :
			//	hipDeviceptr_t dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dst = %p", args->hipMemcpyDtoD.dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->hipMemcpyDtoD.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyDtoD.sizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemcpyDtoD.retval);
			break;

		#endif
		#if HAVE_hipModuleUnload
		case HIP_API_ID_hipModuleUnload :
			//	hipModule_t module (struct ihipModule_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipModule_t module = %p", args->hipModuleUnload.module);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipModuleUnload.retval);
			break;

		#endif
		#if HAVE_hipGetDevicePropertiesR0600
		case HIP_API_ID_hipGetDevicePropertiesR0600 :
			//	hipDeviceProp_tR0600 * prop ({
			//		char[256] name (char[256]);
			//		hipUUID uuid ({
			//			char[16] bytes (char[16]);
			//		});
			//		char[8] luid (char[8]);
			//		unsigned int luidDeviceNodeMask (unsigned int);
			//		size_t totalGlobalMem (unsigned long);
			//		size_t sharedMemPerBlock (unsigned long);
			//		int regsPerBlock (int);
			//		int warpSize (int);
			//		size_t memPitch (unsigned long);
			//		int maxThreadsPerBlock (int);
			//		int[3] maxThreadsDim (int[3]);
			//		int[3] maxGridSize (int[3]);
			//		int clockRate (int);
			//		size_t totalConstMem (unsigned long);
			//		int major (int);
			//		int minor (int);
			//		size_t textureAlignment (unsigned long);
			//		size_t texturePitchAlignment (unsigned long);
			//		int deviceOverlap (int);
			//		int multiProcessorCount (int);
			//		int kernelExecTimeoutEnabled (int);
			//		int integrated (int);
			//		int canMapHostMemory (int);
			//		int computeMode (int);
			//		int maxTexture1D (int);
			//		int maxTexture1DMipmap (int);
			//		int maxTexture1DLinear (int);
			//		int[2] maxTexture2D (int[2]);
			//		int[2] maxTexture2DMipmap (int[2]);
			//		int[3] maxTexture2DLinear (int[3]);
			//		int[2] maxTexture2DGather (int[2]);
			//		int[3] maxTexture3D (int[3]);
			//		int[3] maxTexture3DAlt (int[3]);
			//		int maxTextureCubemap (int);
			//		int[2] maxTexture1DLayered (int[2]);
			//		int[3] maxTexture2DLayered (int[3]);
			//		int[2] maxTextureCubemapLayered (int[2]);
			//		int maxSurface1D (int);
			//		int[2] maxSurface2D (int[2]);
			//		int[3] maxSurface3D (int[3]);
			//		int[2] maxSurface1DLayered (int[2]);
			//		int[3] maxSurface2DLayered (int[3]);
			//		int maxSurfaceCubemap (int);
			//		int[2] maxSurfaceCubemapLayered (int[2]);
			//		size_t surfaceAlignment (unsigned long);
			//		int concurrentKernels (int);
			//		int ECCEnabled (int);
			//		int pciBusID (int);
			//		int pciDeviceID (int);
			//		int pciDomainID (int);
			//		int tccDriver (int);
			//		int asyncEngineCount (int);
			//		int unifiedAddressing (int);
			//		int memoryClockRate (int);
			//		int memoryBusWidth (int);
			//		int l2CacheSize (int);
			//		int persistingL2CacheMaxSize (int);
			//		int maxThreadsPerMultiProcessor (int);
			//		int streamPrioritiesSupported (int);
			//		int globalL1CacheSupported (int);
			//		int localL1CacheSupported (int);
			//		size_t sharedMemPerMultiprocessor (unsigned long);
			//		int regsPerMultiprocessor (int);
			//		int managedMemory (int);
			//		int isMultiGpuBoard (int);
			//		int multiGpuBoardGroupID (int);
			//		int hostNativeAtomicSupported (int);
			//		int singleToDoublePrecisionPerfRatio (int);
			//		int pageableMemoryAccess (int);
			//		int concurrentManagedAccess (int);
			//		int computePreemptionSupported (int);
			//		int canUseHostPointerForRegisteredMem (int);
			//		int cooperativeLaunch (int);
			//		int cooperativeMultiDeviceLaunch (int);
			//		size_t sharedMemPerBlockOptin (unsigned long);
			//		int pageableMemoryAccessUsesHostPageTables (int);
			//		int directManagedMemAccessFromHost (int);
			//		int maxBlocksPerMultiProcessor (int);
			//		int accessPolicyMaxWindowSize (int);
			//		size_t reservedSharedMemPerBlock (unsigned long);
			//		int hostRegisterSupported (int);
			//		int sparseHipArraySupported (int);
			//		int hostRegisterReadOnlySupported (int);
			//		int timelineSemaphoreInteropSupported (int);
			//		int memoryPoolsSupported (int);
			//		int gpuDirectRDMASupported (int);
			//		unsigned int gpuDirectRDMAFlushWritesOptions (unsigned int);
			//		int gpuDirectRDMAWritesOrdering (int);
			//		unsigned int memoryPoolSupportedHandleTypes (unsigned int);
			//		int deferredMappingHipArraySupported (int);
			//		int ipcEventSupported (int);
			//		int clusterLaunch (int);
			//		int unifiedFunctionPointers (int);
			//		int[63] reserved (int[63]);
			//		int[32] hipReserved (int[32]);
			//		char[256] gcnArchName (char[256]);
			//		size_t maxSharedMemoryPerMultiProcessor (unsigned long);
			//		int clockInstructionRate (int);
			//		hipDeviceArch_t arch ({
			//			unsigned int hasGlobalInt32Atomics (unsigned int);
			//			unsigned int hasGlobalFloatAtomicExch (unsigned int);
			//			unsigned int hasSharedInt32Atomics (unsigned int);
			//			unsigned int hasSharedFloatAtomicExch (unsigned int);
			//			unsigned int hasFloatAtomicAdd (unsigned int);
			//			unsigned int hasGlobalInt64Atomics (unsigned int);
			//			unsigned int hasSharedInt64Atomics (unsigned int);
			//			unsigned int hasDoubles (unsigned int);
			//			unsigned int hasWarpVote (unsigned int);
			//			unsigned int hasWarpBallot (unsigned int);
			//			unsigned int hasWarpShuffle (unsigned int);
			//			unsigned int hasFunnelShift (unsigned int);
			//			unsigned int hasThreadFenceSystem (unsigned int);
			//			unsigned int hasSyncThreadsExt (unsigned int);
			//			unsigned int hasSurfaceFuncs (unsigned int);
			//			unsigned int has3dGrid (unsigned int);
			//			unsigned int hasDynamicParallelism (unsigned int);
			//		});
			//		int cooperativeMultiDeviceUnmatchedFunc (int);
			//		int cooperativeMultiDeviceUnmatchedGridDim (int);
			//		int cooperativeMultiDeviceUnmatchedBlockDim (int);
			//		int cooperativeMultiDeviceUnmatchedSharedMem (int);
			//		int isLargeBar (int);
			//		int asicRevision (int);
			//	});
			//	int deviceId (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceProp_tR0600 * prop = %p", args->hipGetDevicePropertiesR0600.prop);
			if (args->hipGetDevicePropertiesR0600.prop != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[256] name = %c\n", args->hipGetDevicePropertiesR0600.prop__ref.val.name[0]);
				printf("\t\thipUUID uuid = {\n");
				printf("\t\t\tchar[16] bytes = %c\n", args->hipGetDevicePropertiesR0600.prop__ref.val.uuid.bytes[0]);
				printf("\t\t}\n");
				printf("\t\tchar[8] luid = %c\n", args->hipGetDevicePropertiesR0600.prop__ref.val.luid[0]);
				printf("\t\tunsigned int luidDeviceNodeMask = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.luidDeviceNodeMask);
				printf("\t\tsize_t totalGlobalMem = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.totalGlobalMem);
				printf("\t\tsize_t sharedMemPerBlock = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.sharedMemPerBlock);
				printf("\t\tint regsPerBlock = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.regsPerBlock);
				printf("\t\tint warpSize = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.warpSize);
				printf("\t\tsize_t memPitch = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.memPitch);
				printf("\t\tint maxThreadsPerBlock = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxThreadsPerBlock);
				printf("\t\tint[3] maxThreadsDim = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxThreadsDim[0]);
				printf("\t\tint[3] maxGridSize = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxGridSize[0]);
				printf("\t\tint clockRate = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.clockRate);
				printf("\t\tsize_t totalConstMem = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.totalConstMem);
				printf("\t\tint major = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.major);
				printf("\t\tint minor = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.minor);
				printf("\t\tsize_t textureAlignment = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.textureAlignment);
				printf("\t\tsize_t texturePitchAlignment = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.texturePitchAlignment);
				printf("\t\tint deviceOverlap = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.deviceOverlap);
				printf("\t\tint multiProcessorCount = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.multiProcessorCount);
				printf("\t\tint kernelExecTimeoutEnabled = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.kernelExecTimeoutEnabled);
				printf("\t\tint integrated = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.integrated);
				printf("\t\tint canMapHostMemory = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.canMapHostMemory);
				printf("\t\tint computeMode = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.computeMode);
				printf("\t\tint maxTexture1D = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture1D);
				printf("\t\tint maxTexture1DMipmap = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture1DMipmap);
				printf("\t\tint maxTexture1DLinear = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture1DLinear);
				printf("\t\tint[2] maxTexture2D = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture2D[0]);
				printf("\t\tint[2] maxTexture2DMipmap = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture2DMipmap[0]);
				printf("\t\tint[3] maxTexture2DLinear = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture2DLinear[0]);
				printf("\t\tint[2] maxTexture2DGather = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture2DGather[0]);
				printf("\t\tint[3] maxTexture3D = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture3D[0]);
				printf("\t\tint[3] maxTexture3DAlt = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture3DAlt[0]);
				printf("\t\tint maxTextureCubemap = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTextureCubemap);
				printf("\t\tint[2] maxTexture1DLayered = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture1DLayered[0]);
				printf("\t\tint[3] maxTexture2DLayered = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTexture2DLayered[0]);
				printf("\t\tint[2] maxTextureCubemapLayered = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxTextureCubemapLayered[0]);
				printf("\t\tint maxSurface1D = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurface1D);
				printf("\t\tint[2] maxSurface2D = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurface2D[0]);
				printf("\t\tint[3] maxSurface3D = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurface3D[0]);
				printf("\t\tint[2] maxSurface1DLayered = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurface1DLayered[0]);
				printf("\t\tint[3] maxSurface2DLayered = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurface2DLayered[0]);
				printf("\t\tint maxSurfaceCubemap = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurfaceCubemap);
				printf("\t\tint[2] maxSurfaceCubemapLayered = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSurfaceCubemapLayered[0]);
				printf("\t\tsize_t surfaceAlignment = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.surfaceAlignment);
				printf("\t\tint concurrentKernels = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.concurrentKernels);
				printf("\t\tint ECCEnabled = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.ECCEnabled);
				printf("\t\tint pciBusID = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.pciBusID);
				printf("\t\tint pciDeviceID = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.pciDeviceID);
				printf("\t\tint pciDomainID = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.pciDomainID);
				printf("\t\tint tccDriver = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.tccDriver);
				printf("\t\tint asyncEngineCount = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.asyncEngineCount);
				printf("\t\tint unifiedAddressing = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.unifiedAddressing);
				printf("\t\tint memoryClockRate = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.memoryClockRate);
				printf("\t\tint memoryBusWidth = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.memoryBusWidth);
				printf("\t\tint l2CacheSize = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.l2CacheSize);
				printf("\t\tint persistingL2CacheMaxSize = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.persistingL2CacheMaxSize);
				printf("\t\tint maxThreadsPerMultiProcessor = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxThreadsPerMultiProcessor);
				printf("\t\tint streamPrioritiesSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.streamPrioritiesSupported);
				printf("\t\tint globalL1CacheSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.globalL1CacheSupported);
				printf("\t\tint localL1CacheSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.localL1CacheSupported);
				printf("\t\tsize_t sharedMemPerMultiprocessor = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.sharedMemPerMultiprocessor);
				printf("\t\tint regsPerMultiprocessor = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.regsPerMultiprocessor);
				printf("\t\tint managedMemory = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.managedMemory);
				printf("\t\tint isMultiGpuBoard = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.isMultiGpuBoard);
				printf("\t\tint multiGpuBoardGroupID = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.multiGpuBoardGroupID);
				printf("\t\tint hostNativeAtomicSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.hostNativeAtomicSupported);
				printf("\t\tint singleToDoublePrecisionPerfRatio = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.singleToDoublePrecisionPerfRatio);
				printf("\t\tint pageableMemoryAccess = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.pageableMemoryAccess);
				printf("\t\tint concurrentManagedAccess = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.concurrentManagedAccess);
				printf("\t\tint computePreemptionSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.computePreemptionSupported);
				printf("\t\tint canUseHostPointerForRegisteredMem = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.canUseHostPointerForRegisteredMem);
				printf("\t\tint cooperativeLaunch = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.cooperativeLaunch);
				printf("\t\tint cooperativeMultiDeviceLaunch = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.cooperativeMultiDeviceLaunch);
				printf("\t\tsize_t sharedMemPerBlockOptin = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.sharedMemPerBlockOptin);
				printf("\t\tint pageableMemoryAccessUsesHostPageTables = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.pageableMemoryAccessUsesHostPageTables);
				printf("\t\tint directManagedMemAccessFromHost = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.directManagedMemAccessFromHost);
				printf("\t\tint maxBlocksPerMultiProcessor = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxBlocksPerMultiProcessor);
				printf("\t\tint accessPolicyMaxWindowSize = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.accessPolicyMaxWindowSize);
				printf("\t\tsize_t reservedSharedMemPerBlock = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.reservedSharedMemPerBlock);
				printf("\t\tint hostRegisterSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.hostRegisterSupported);
				printf("\t\tint sparseHipArraySupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.sparseHipArraySupported);
				printf("\t\tint hostRegisterReadOnlySupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.hostRegisterReadOnlySupported);
				printf("\t\tint timelineSemaphoreInteropSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.timelineSemaphoreInteropSupported);
				printf("\t\tint memoryPoolsSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.memoryPoolsSupported);
				printf("\t\tint gpuDirectRDMASupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.gpuDirectRDMASupported);
				printf("\t\tunsigned int gpuDirectRDMAFlushWritesOptions = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.gpuDirectRDMAFlushWritesOptions);
				printf("\t\tint gpuDirectRDMAWritesOrdering = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.gpuDirectRDMAWritesOrdering);
				printf("\t\tunsigned int memoryPoolSupportedHandleTypes = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.memoryPoolSupportedHandleTypes);
				printf("\t\tint deferredMappingHipArraySupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.deferredMappingHipArraySupported);
				printf("\t\tint ipcEventSupported = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.ipcEventSupported);
				printf("\t\tint clusterLaunch = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.clusterLaunch);
				printf("\t\tint unifiedFunctionPointers = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.unifiedFunctionPointers);
				printf("\t\tint[63] reserved = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.reserved[0]);
				printf("\t\tint[32] hipReserved = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.hipReserved[0]);
				printf("\t\tchar[256] gcnArchName = %c\n", args->hipGetDevicePropertiesR0600.prop__ref.val.gcnArchName[0]);
				printf("\t\tsize_t maxSharedMemoryPerMultiProcessor = %lu\n", args->hipGetDevicePropertiesR0600.prop__ref.val.maxSharedMemoryPerMultiProcessor);
				printf("\t\tint clockInstructionRate = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.clockInstructionRate);
				printf("\t\thipDeviceArch_t arch = {\n");
				printf("\t\t\tunsigned int hasGlobalInt32Atomics = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasGlobalInt32Atomics);
				printf("\t\t\tunsigned int hasGlobalFloatAtomicExch = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasGlobalFloatAtomicExch);
				printf("\t\t\tunsigned int hasSharedInt32Atomics = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasSharedInt32Atomics);
				printf("\t\t\tunsigned int hasSharedFloatAtomicExch = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasSharedFloatAtomicExch);
				printf("\t\t\tunsigned int hasFloatAtomicAdd = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasFloatAtomicAdd);
				printf("\t\t\tunsigned int hasGlobalInt64Atomics = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasGlobalInt64Atomics);
				printf("\t\t\tunsigned int hasSharedInt64Atomics = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasSharedInt64Atomics);
				printf("\t\t\tunsigned int hasDoubles = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasDoubles);
				printf("\t\t\tunsigned int hasWarpVote = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasWarpVote);
				printf("\t\t\tunsigned int hasWarpBallot = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasWarpBallot);
				printf("\t\t\tunsigned int hasWarpShuffle = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasWarpShuffle);
				printf("\t\t\tunsigned int hasFunnelShift = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasFunnelShift);
				printf("\t\t\tunsigned int hasThreadFenceSystem = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasThreadFenceSystem);
				printf("\t\t\tunsigned int hasSyncThreadsExt = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasSyncThreadsExt);
				printf("\t\t\tunsigned int hasSurfaceFuncs = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasSurfaceFuncs);
				printf("\t\t\tunsigned int has3dGrid = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.has3dGrid);
				printf("\t\t\tunsigned int hasDynamicParallelism = %u\n", args->hipGetDevicePropertiesR0600.prop__ref.val.arch.hasDynamicParallelism);
				printf("\t\t}\n");
				printf("\t\tint cooperativeMultiDeviceUnmatchedFunc = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedFunc);
				printf("\t\tint cooperativeMultiDeviceUnmatchedGridDim = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedGridDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedBlockDim = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedBlockDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedSharedMem = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedSharedMem);
				printf("\t\tint isLargeBar = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.isLargeBar);
				printf("\t\tint asicRevision = %d\n", args->hipGetDevicePropertiesR0600.prop__ref.val.asicRevision);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint deviceId = %d\n", args->hipGetDevicePropertiesR0600.deviceId);
			printf("\thipError_t retval = %d\n", args->hipGetDevicePropertiesR0600.retval);
			break;

		#endif
		#if HAVE_hipMemcpyFromArray
		case HIP_API_ID_hipMemcpyFromArray :
			//	void * dst (void *);
			//	hipArray_const_t srcArray (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyFromArray.dst);
			printf("\n");
			printf("\thipArray_const_t srcArray = %p", args->hipMemcpyFromArray.srcArray);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpyFromArray.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpyFromArray.hOffset);
			printf("\tsize_t count = %lu\n", args->hipMemcpyFromArray.count);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyFromArray.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyFromArray.retval);
			break;

		#endif
		#if HAVE_hipDeviceCanAccessPeer
		case HIP_API_ID_hipDeviceCanAccessPeer :
			//	int * canAccessPeer (int *);
			//	int deviceId (int);
			//	int peerDeviceId (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * canAccessPeer = %p", args->hipDeviceCanAccessPeer.canAccessPeer);
			if (args->hipDeviceCanAccessPeer.canAccessPeer != NULL) {
				printf(" -> %d\n", args->hipDeviceCanAccessPeer.canAccessPeer__ref.val);
			} else { printf("\n"); };
			printf("\tint deviceId = %d\n", args->hipDeviceCanAccessPeer.deviceId);
			printf("\tint peerDeviceId = %d\n", args->hipDeviceCanAccessPeer.peerDeviceId);
			printf("\thipError_t retval = %d\n", args->hipDeviceCanAccessPeer.retval);
			break;

		#endif
		#if HAVE_hipMemSetAccess
		case HIP_API_ID_hipMemSetAccess :
			//	void * ptr (void *);
			//	size_t size (unsigned long);
			//	const hipMemAccessDesc * desc ({
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		hipMemAccessFlags flags (enum hipMemAccessFlags);
			//	});
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipMemSetAccess.ptr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->hipMemSetAccess.size);
			printf("\tconst hipMemAccessDesc * desc = %p", args->hipMemSetAccess.desc);
			if (args->hipMemSetAccess.desc != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->hipMemSetAccess.desc__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->hipMemSetAccess.desc__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\thipMemAccessFlags flags = %d\n", args->hipMemSetAccess.desc__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t count = %lu\n", args->hipMemSetAccess.count);
			printf("\thipError_t retval = %d\n", args->hipMemSetAccess.retval);
			break;

		#endif
		#if HAVE_hipStreamWaitValue32
		case HIP_API_ID_hipStreamWaitValue32 :
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint32_t value (unsigned int);
			//	unsigned int flags (unsigned int);
			//	uint32_t mask (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamWaitValue32.stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->hipStreamWaitValue32.ptr);
			printf("\n");
			printf("\tuint32_t value = %u\n", args->hipStreamWaitValue32.value);
			printf("\tunsigned int flags = %u\n", args->hipStreamWaitValue32.flags);
			printf("\tuint32_t mask = %u\n", args->hipStreamWaitValue32.mask);
			printf("\thipError_t retval = %d\n", args->hipStreamWaitValue32.retval);
			break;

		#endif
		#if HAVE_hipApiName
		case HIP_API_ID_hipApiName :
			//	uint32_t id (unsigned int);
			//	const char * retval (const char *);
			printf("\tuint32_t id = %u\n", args->hipApiName.id);
			printf("\tconst char * retval = %p", args->hipApiName.retval);
			if (args->hipApiName.retval != NULL) {
				printf(" -> %s\n", args->hipApiName.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipGraphicsSubResourceGetMappedArray
		case HIP_API_ID_hipGraphicsSubResourceGetMappedArray :
			//	hipArray_t * array (struct hipArray **);
			//	hipGraphicsResource_t resource (struct _hipGraphicsResource*);
			//	unsigned int arrayIndex (unsigned int);
			//	unsigned int mipLevel (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * array = %p", args->hipGraphicsSubResourceGetMappedArray.array);
			if (args->hipGraphicsSubResourceGetMappedArray.array != NULL) {
				printf(" -> %p\n", args->hipGraphicsSubResourceGetMappedArray.array__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphicsResource_t resource = %p", args->hipGraphicsSubResourceGetMappedArray.resource);
			printf("\n");
			printf("\tunsigned int arrayIndex = %u\n", args->hipGraphicsSubResourceGetMappedArray.arrayIndex);
			printf("\tunsigned int mipLevel = %u\n", args->hipGraphicsSubResourceGetMappedArray.mipLevel);
			printf("\thipError_t retval = %d\n", args->hipGraphicsSubResourceGetMappedArray.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DToArrayAsync
		case HIP_API_ID_hipMemcpy2DToArrayAsync :
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dst = %p", args->hipMemcpy2DToArrayAsync.dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DToArrayAsync.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DToArrayAsync.hOffset);
			printf("\tconst void * src = %p", args->hipMemcpy2DToArrayAsync.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2DToArrayAsync.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DToArrayAsync.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DToArrayAsync.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DToArrayAsync.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpy2DToArrayAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DToArrayAsync.retval);
			break;

		#endif
		#if HAVE_hipGraphDestroy
		case HIP_API_ID_hipGraphDestroy :
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphDestroy.graph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphDestroy.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetBorderColor
		case HIP_API_ID_hipTexRefGetBorderColor :
			//	float * pBorderColor (float *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tfloat * pBorderColor = %p", args->hipTexRefGetBorderColor.pBorderColor);
			if (args->hipTexRefGetBorderColor.pBorderColor != NULL) {
				printf(" -> %f\n", args->hipTexRefGetBorderColor.pBorderColor__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetBorderColor.texRef);
			if (args->hipTexRefGetBorderColor.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetBorderColor.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetBorderColor.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetBorderColor.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetBorderColor.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetBorderColor.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetBorderColor.retval);
			break;

		#endif
		#if HAVE_hipGraphAddMemcpyNode1D
		case HIP_API_ID_hipGraphAddMemcpyNode1D :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemcpyNode1D.pGraphNode);
			if (args->hipGraphAddMemcpyNode1D.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNode1D.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemcpyNode1D.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemcpyNode1D.pDependencies);
			if (args->hipGraphAddMemcpyNode1D.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNode1D.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemcpyNode1D.numDependencies);
			printf("\tvoid * dst = %p", args->hipGraphAddMemcpyNode1D.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipGraphAddMemcpyNode1D.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphAddMemcpyNode1D.count);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphAddMemcpyNode1D.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemcpyNode1D.retval);
			break;

		#endif
		#if HAVE_hipGraphGetNodes
		case HIP_API_ID_hipGraphGetNodes :
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * nodes (struct hipGraphNode **);
			//	size_t * numNodes (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphGetNodes.graph);
			printf("\n");
			printf("\thipGraphNode_t * nodes = %p", args->hipGraphGetNodes.nodes);
			if (args->hipGraphGetNodes.nodes != NULL) {
				printf(" -> %p\n", args->hipGraphGetNodes.nodes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * numNodes = %p", args->hipGraphGetNodes.numNodes);
			if (args->hipGraphGetNodes.numNodes != NULL) {
				printf(" -> %lu\n", args->hipGraphGetNodes.numNodes__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphGetNodes.retval);
			break;

		#endif
		#if HAVE_hipStreamGetFlags_spt
		case HIP_API_ID_hipStreamGetFlags_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetFlags_spt.stream);
			printf("\n");
			printf("\tunsigned int * flags = %p", args->hipStreamGetFlags_spt.flags);
			if (args->hipStreamGetFlags_spt.flags != NULL) {
				printf(" -> %u\n", args->hipStreamGetFlags_spt.flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetFlags_spt.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetAddress2D
		case HIP_API_ID_hipTexRefSetAddress2D :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const HIP_ARRAY_DESCRIPTOR * desc ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//	});
			//	hipDeviceptr_t dptr (void *);
			//	size_t Pitch (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetAddress2D.texRef);
			if (args->hipTexRefSetAddress2D.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetAddress2D.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetAddress2D.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetAddress2D.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetAddress2D.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetAddress2D.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst HIP_ARRAY_DESCRIPTOR * desc = %p", args->hipTexRefSetAddress2D.desc);
			if (args->hipTexRefSetAddress2D.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->hipTexRefSetAddress2D.desc__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->hipTexRefSetAddress2D.desc__ref.val.Height);
				printf("\t\tenum hipArray_Format Format = %d\n", args->hipTexRefSetAddress2D.desc__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->hipTexRefSetAddress2D.desc__ref.val.NumChannels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipDeviceptr_t dptr = %p", args->hipTexRefSetAddress2D.dptr);
			printf("\n");
			printf("\tsize_t Pitch = %lu\n", args->hipTexRefSetAddress2D.Pitch);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetAddress2D.retval);
			break;

		#endif
		#if HAVE_hipStreamGetPriority
		case HIP_API_ID_hipStreamGetPriority :
			//	hipStream_t stream (struct ihipStream_t *);
			//	int * priority (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetPriority.stream);
			printf("\n");
			printf("\tint * priority = %p", args->hipStreamGetPriority.priority);
			if (args->hipStreamGetPriority.priority != NULL) {
				printf(" -> %d\n", args->hipStreamGetPriority.priority__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetPriority.retval);
			break;

		#endif
		#if HAVE_hipStreamCreate
		case HIP_API_ID_hipStreamCreate :
			//	hipStream_t * stream (struct ihipStream_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t * stream = %p", args->hipStreamCreate.stream);
			if (args->hipStreamCreate.stream != NULL) {
				printf(" -> %p\n", args->hipStreamCreate.stream__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamCreate.retval);
			break;

		#endif
		#if HAVE_hipMemcpyFromSymbol
		case HIP_API_ID_hipMemcpyFromSymbol :
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyFromSymbol.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipMemcpyFromSymbol.symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyFromSymbol.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyFromSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyFromSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyFromSymbol.retval);
			break;

		#endif
		#if HAVE_hipGraphNodeGetEnabled
		case HIP_API_ID_hipGraphNodeGetEnabled :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	unsigned int * isEnabled (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphNodeGetEnabled.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hipGraphNodeGetEnabled.hNode);
			printf("\n");
			printf("\tunsigned int * isEnabled = %p", args->hipGraphNodeGetEnabled.isEnabled);
			if (args->hipGraphNodeGetEnabled.isEnabled != NULL) {
				printf(" -> %u\n", args->hipGraphNodeGetEnabled.isEnabled__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphNodeGetEnabled.retval);
			break;

		#endif
		#if HAVE_hipCreateChannelDesc
		case HIP_API_ID_hipCreateChannelDesc :
			//	int x (int);
			//	int y (int);
			//	int z (int);
			//	int w (int);
			//	enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	struct hipChannelFormatDesc retval ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			printf("\tint x = %d\n", args->hipCreateChannelDesc.x);
			printf("\tint y = %d\n", args->hipCreateChannelDesc.y);
			printf("\tint z = %d\n", args->hipCreateChannelDesc.z);
			printf("\tint w = %d\n", args->hipCreateChannelDesc.w);
			printf("\tenum hipChannelFormatKind f = %d\n", args->hipCreateChannelDesc.f);
			printf("\tstruct hipChannelFormatDesc retval = {\n");
			printf("\t\tint x = %d\n", args->hipCreateChannelDesc.retval.x);
			printf("\t\tint y = %d\n", args->hipCreateChannelDesc.retval.y);
			printf("\t\tint z = %d\n", args->hipCreateChannelDesc.retval.z);
			printf("\t\tint w = %d\n", args->hipCreateChannelDesc.retval.w);
			printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipCreateChannelDesc.retval.f);
			printf("\t}\n");
			break;

		#endif
		#if HAVE_hipFreeMipmappedArray
		case HIP_API_ID_hipFreeMipmappedArray :
			//	hipMipmappedArray_t mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipMipmappedArray_t mipmappedArray = %p", args->hipFreeMipmappedArray.mipmappedArray);
			if (args->hipFreeMipmappedArray.mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hipFreeMipmappedArray.mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipFreeMipmappedArray.retval);
			break;

		#endif
		#if HAVE_hipGetTextureAlignmentOffset
		case HIP_API_ID_hipGetTextureAlignmentOffset :
			//	size_t * offset (unsigned long*);
			//	const textureReference * texref ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * offset = %p", args->hipGetTextureAlignmentOffset.offset);
			if (args->hipGetTextureAlignmentOffset.offset != NULL) {
				printf(" -> %lu\n", args->hipGetTextureAlignmentOffset.offset__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texref = %p", args->hipGetTextureAlignmentOffset.texref);
			if (args->hipGetTextureAlignmentOffset.texref != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipGetTextureAlignmentOffset.texref__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipGetTextureAlignmentOffset.texref__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipGetTextureAlignmentOffset.texref__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipGetTextureAlignmentOffset.texref__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipGetTextureAlignmentOffset.texref__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGetTextureAlignmentOffset.retval);
			break;

		#endif
		#if HAVE_hipGraphAddEventRecordNode
		case HIP_API_ID_hipGraphAddEventRecordNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddEventRecordNode.pGraphNode);
			if (args->hipGraphAddEventRecordNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddEventRecordNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddEventRecordNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddEventRecordNode.pDependencies);
			if (args->hipGraphAddEventRecordNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddEventRecordNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddEventRecordNode.numDependencies);
			printf("\thipEvent_t event = %p", args->hipGraphAddEventRecordNode.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphAddEventRecordNode.retval);
			break;

		#endif
		#if HAVE_hipGraphNodeFindInClone
		case HIP_API_ID_hipGraphNodeFindInClone :
			//	hipGraphNode_t * pNode (struct hipGraphNode **);
			//	hipGraphNode_t originalNode (struct hipGraphNode *);
			//	hipGraph_t clonedGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pNode = %p", args->hipGraphNodeFindInClone.pNode);
			if (args->hipGraphNodeFindInClone.pNode != NULL) {
				printf(" -> %p\n", args->hipGraphNodeFindInClone.pNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphNode_t originalNode = %p", args->hipGraphNodeFindInClone.originalNode);
			printf("\n");
			printf("\thipGraph_t clonedGraph = %p", args->hipGraphNodeFindInClone.clonedGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphNodeFindInClone.retval);
			break;

		#endif
		#if HAVE_hipMemcpyFromSymbol_spt
		case HIP_API_ID_hipMemcpyFromSymbol_spt :
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyFromSymbol_spt.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipMemcpyFromSymbol_spt.symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyFromSymbol_spt.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyFromSymbol_spt.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyFromSymbol_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyFromSymbol_spt.retval);
			break;

		#endif
		#if HAVE_hipMemset3DAsync_spt
		case HIP_API_ID_hipMemset3DAsync_spt :
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->hipMemset3DAsync_spt.pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->hipMemset3DAsync_spt.pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->hipMemset3DAsync_spt.pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->hipMemset3DAsync_spt.value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMemset3DAsync_spt.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMemset3DAsync_spt.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMemset3DAsync_spt.extent.depth);
			printf("\t}\n");
			printf("\thipStream_t stream = %p", args->hipMemset3DAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemset3DAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipMemsetD16Async
		case HIP_API_ID_hipMemsetD16Async :
			//	hipDeviceptr_t dest (void *);
			//	unsigned short value (unsigned short);
			//	size_t count (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dest = %p", args->hipMemsetD16Async.dest);
			printf("\n");
			printf("\tunsigned short value = %hu\n", args->hipMemsetD16Async.value);
			printf("\tsize_t count = %lu\n", args->hipMemsetD16Async.count);
			printf("\thipStream_t stream = %p", args->hipMemsetD16Async.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemsetD16Async.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetCacheConfig
		case HIP_API_ID_hipDeviceGetCacheConfig :
			//	hipFuncCache_t * cacheConfig (enum hipFuncCache_t*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFuncCache_t * cacheConfig = %p", args->hipDeviceGetCacheConfig.cacheConfig);
			if (args->hipDeviceGetCacheConfig.cacheConfig != NULL) {
				printf(" -> %d\n", args->hipDeviceGetCacheConfig.cacheConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDeviceGetCacheConfig.retval);
			break;

		#endif
		#if HAVE_hipMemCreate
		case HIP_API_ID_hipMemCreate :
			//	hipMemGenericAllocationHandle_t * handle (struct ihipMemGenericAllocationHandle **);
			//	size_t size (unsigned long);
			//	const hipMemAllocationProp * prop ({
			//		hipMemAllocationType type (enum hipMemAllocationType);
			//		hipMemAllocationHandleType requestedHandleType (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32HandleMetaData (void *);
			//		struct (unnamed struct at header/hip/hip.h:1616:2) allocFlags ({
			//		});
			//	});
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemGenericAllocationHandle_t * handle = %p", args->hipMemCreate.handle);
			if (args->hipMemCreate.handle != NULL) {
				printf(" -> %p\n", args->hipMemCreate.handle__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMemCreate.size);
			printf("\tconst hipMemAllocationProp * prop = %p", args->hipMemCreate.prop);
			if (args->hipMemCreate.prop != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType type = %d\n", args->hipMemCreate.prop__ref.val.type);
				printf("\t\thipMemAllocationHandleType requestedHandleType = %d\n", args->hipMemCreate.prop__ref.val.requestedHandleType);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->hipMemCreate.prop__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->hipMemCreate.prop__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1616:2) allocFlags = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned long long flags = %llu\n", args->hipMemCreate.flags);
			printf("\thipError_t retval = %d\n", args->hipMemCreate.retval);
			break;

		#endif
		#if HAVE_hipGraphExternalSemaphoresWaitNodeGetParams
		case HIP_API_ID_hipGraphExternalSemaphoresWaitNodeGetParams :
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipExternalSemaphoreWaitNodeParams * params_out ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExternalSemaphoresWaitNodeGetParams.hNode);
			printf("\n");
			printf("\thipExternalSemaphoreWaitNodeParams * params_out = %p", args->hipGraphExternalSemaphoresWaitNodeGetParams.params_out);
			if (args->hipGraphExternalSemaphoresWaitNodeGetParams.params_out != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphExternalSemaphoresWaitNodeGetParams.params_out__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExternalSemaphoresWaitNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipStreamEndCapture
		case HIP_API_ID_hipStreamEndCapture :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamEndCapture.stream);
			printf("\n");
			printf("\thipGraph_t * pGraph = %p", args->hipStreamEndCapture.pGraph);
			if (args->hipStreamEndCapture.pGraph != NULL) {
				printf(" -> %p\n", args->hipStreamEndCapture.pGraph__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamEndCapture.retval);
			break;

		#endif
		#if HAVE_hipMemcpyFromSymbolAsync_spt
		case HIP_API_ID_hipMemcpyFromSymbolAsync_spt :
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyFromSymbolAsync_spt.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipMemcpyFromSymbolAsync_spt.symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyFromSymbolAsync_spt.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyFromSymbolAsync_spt.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyFromSymbolAsync_spt.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyFromSymbolAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyFromSymbolAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipMemcpyHtoA
		case HIP_API_ID_hipMemcpyHtoA :
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	const void * srcHost (const void *);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dstArray = %p", args->hipMemcpyHtoA.dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->hipMemcpyHtoA.dstOffset);
			printf("\tconst void * srcHost = %p", args->hipMemcpyHtoA.srcHost);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipMemcpyHtoA.count);
			printf("\thipError_t retval = %d\n", args->hipMemcpyHtoA.retval);
			break;

		#endif
		#if HAVE_hipGraphExecHostNodeSetParams
		case HIP_API_ID_hipGraphExecHostNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecHostNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecHostNodeSetParams.node);
			printf("\n");
			printf("\tconst hipHostNodeParams * pNodeParams = %p", args->hipGraphExecHostNodeSetParams.pNodeParams);
			if (args->hipGraphExecHostNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->hipGraphExecHostNodeSetParams.pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecHostNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipMalloc
		case HIP_API_ID_hipMalloc :
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipMalloc.ptr);
			if (args->hipMalloc.ptr != NULL) {
				printf("-> %p", args->hipMalloc.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMalloc.size);
			printf("\thipError_t retval = %d\n", args->hipMalloc.retval);
			break;

		#endif
		#if HAVE_hipMalloc3DArray
		case HIP_API_ID_hipMalloc3DArray :
			//	hipArray_t * array (struct hipArray **);
			//	const struct hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	struct hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * array = %p", args->hipMalloc3DArray.array);
			if (args->hipMalloc3DArray.array != NULL) {
				printf(" -> %p\n", args->hipMalloc3DArray.array__ref.val);
			} else { printf("\n"); };
			printf("\tconst struct hipChannelFormatDesc * desc = %p", args->hipMalloc3DArray.desc);
			if (args->hipMalloc3DArray.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipMalloc3DArray.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipMalloc3DArray.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipMalloc3DArray.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipMalloc3DArray.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipMalloc3DArray.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tstruct hipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMalloc3DArray.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMalloc3DArray.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMalloc3DArray.extent.depth);
			printf("\t}\n");
			printf("\tunsigned int flags = %u\n", args->hipMalloc3DArray.flags);
			printf("\thipError_t retval = %d\n", args->hipMalloc3DArray.retval);
			break;

		#endif
		#if HAVE_hipGraphExecKernelNodeSetParams
		case HIP_API_ID_hipGraphExecKernelNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecKernelNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecKernelNodeSetParams.node);
			printf("\n");
			printf("\tconst hipKernelNodeParams * pNodeParams = %p", args->hipGraphExecKernelNodeSetParams.pNodeParams);
			if (args->hipGraphExecKernelNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->hipGraphExecKernelNodeSetParams.pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecKernelNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipGetTextureObjectResourceDesc
		case HIP_API_ID_hipGetTextureObjectResourceDesc :
			//	hipResourceDesc * pResDesc ({
			//		enum hipResourceType resType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:612:2) res ({
			//		});
			//	});
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipResourceDesc * pResDesc = %p", args->hipGetTextureObjectResourceDesc.pResDesc);
			if (args->hipGetTextureObjectResourceDesc.pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceType resType = %d\n", args->hipGetTextureObjectResourceDesc.pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:612:2) res = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t textureObject = %p", args->hipGetTextureObjectResourceDesc.textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetTextureObjectResourceDesc.retval);
			break;

		#endif
		#if HAVE___hipPushCallConfiguration
		case HIP_API_ID___hipPushCallConfiguration :
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	size_t sharedMem (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->__hipPushCallConfiguration.gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->__hipPushCallConfiguration.gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->__hipPushCallConfiguration.gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->__hipPushCallConfiguration.blockDim.x);
			printf("\t\tuint32_t y = %u\n", args->__hipPushCallConfiguration.blockDim.y);
			printf("\t\tuint32_t z = %u\n", args->__hipPushCallConfiguration.blockDim.z);
			printf("\t}\n");
			printf("\tsize_t sharedMem = %lu\n", args->__hipPushCallConfiguration.sharedMem);
			printf("\thipStream_t stream = %p", args->__hipPushCallConfiguration.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->__hipPushCallConfiguration.retval);
			break;

		#endif
		#if HAVE_hipMemcpy3DAsync_spt
		case HIP_API_ID_hipMemcpy3DAsync_spt :
			//	const hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst hipMemcpy3DParms * p = %p", args->hipMemcpy3DAsync_spt.p);
			if (args->hipMemcpy3DAsync_spt.p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipMemcpy3DAsync_spt.p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipMemcpy3DAsync_spt.p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->hipMemcpy3DAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy3DAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipMemsetD8Async
		case HIP_API_ID_hipMemsetD8Async :
			//	hipDeviceptr_t dest (void *);
			//	unsigned char value (unsigned char);
			//	size_t count (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dest = %p", args->hipMemsetD8Async.dest);
			printf("\n");
			printf("\tunsigned char value = %hhu\n", args->hipMemsetD8Async.value);
			printf("\tsize_t count = %lu\n", args->hipMemsetD8Async.count);
			printf("\thipStream_t stream = %p", args->hipMemsetD8Async.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemsetD8Async.retval);
			break;

		#endif
		#if HAVE_hipStreamAddCallback
		case HIP_API_ID_hipStreamAddCallback :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCallback_t callback (void (*)(struct ihipStream_t *, enum hipError_t, void *));
			//	void * userData (void *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamAddCallback.stream);
			printf("\n");
			printf("\thipStreamCallback_t callback = %p\n", args->hipStreamAddCallback.callback);
			printf("\tvoid * userData = %p", args->hipStreamAddCallback.userData);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipStreamAddCallback.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamAddCallback.retval);
			break;

		#endif
		#if HAVE_hipMemPoolImportPointer
		case HIP_API_ID_hipMemPoolImportPointer :
			//	void ** dev_ptr (void **);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemPoolPtrExportData * export_data ({
			//		unsigned char[64] reserved (unsigned char[64]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** dev_ptr = %p", args->hipMemPoolImportPointer.dev_ptr);
			if (args->hipMemPoolImportPointer.dev_ptr != NULL) {
				printf("-> %p", args->hipMemPoolImportPointer.dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolImportPointer.mem_pool);
			printf("\n");
			printf("\thipMemPoolPtrExportData * export_data = %p", args->hipMemPoolImportPointer.export_data);
			if (args->hipMemPoolImportPointer.export_data != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned char[64] reserved = %hhu\n", args->hipMemPoolImportPointer.export_data__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemPoolImportPointer.retval);
			break;

		#endif
		#if HAVE_hipFuncGetAttributes
		case HIP_API_ID_hipFuncGetAttributes :
			//	struct hipFuncAttributes * attr ({
			//		int binaryVersion (int);
			//		int cacheModeCA (int);
			//		size_t constSizeBytes (unsigned long);
			//		size_t localSizeBytes (unsigned long);
			//		int maxDynamicSharedSizeBytes (int);
			//		int maxThreadsPerBlock (int);
			//		int numRegs (int);
			//		int preferredShmemCarveout (int);
			//		int ptxVersion (int);
			//		size_t sharedSizeBytes (unsigned long);
			//	});
			//	const void * func (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tstruct hipFuncAttributes * attr = %p", args->hipFuncGetAttributes.attr);
			if (args->hipFuncGetAttributes.attr != NULL) {
				printf(" -> {\n");
				printf("\t\tint binaryVersion = %d\n", args->hipFuncGetAttributes.attr__ref.val.binaryVersion);
				printf("\t\tint cacheModeCA = %d\n", args->hipFuncGetAttributes.attr__ref.val.cacheModeCA);
				printf("\t\tsize_t constSizeBytes = %lu\n", args->hipFuncGetAttributes.attr__ref.val.constSizeBytes);
				printf("\t\tsize_t localSizeBytes = %lu\n", args->hipFuncGetAttributes.attr__ref.val.localSizeBytes);
				printf("\t\tint maxDynamicSharedSizeBytes = %d\n", args->hipFuncGetAttributes.attr__ref.val.maxDynamicSharedSizeBytes);
				printf("\t\tint maxThreadsPerBlock = %d\n", args->hipFuncGetAttributes.attr__ref.val.maxThreadsPerBlock);
				printf("\t\tint numRegs = %d\n", args->hipFuncGetAttributes.attr__ref.val.numRegs);
				printf("\t\tint preferredShmemCarveout = %d\n", args->hipFuncGetAttributes.attr__ref.val.preferredShmemCarveout);
				printf("\t\tint ptxVersion = %d\n", args->hipFuncGetAttributes.attr__ref.val.ptxVersion);
				printf("\t\tsize_t sharedSizeBytes = %lu\n", args->hipFuncGetAttributes.attr__ref.val.sharedSizeBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * func = %p", args->hipFuncGetAttributes.func);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipFuncGetAttributes.retval);
			break;

		#endif
		#if HAVE_hipCtxGetCurrent
		case HIP_API_ID_hipCtxGetCurrent :
			//	hipCtx_t * ctx (struct ihipCtx_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t * ctx = %p", args->hipCtxGetCurrent.ctx);
			if (args->hipCtxGetCurrent.ctx != NULL) {
				printf(" -> %p\n", args->hipCtxGetCurrent.ctx__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxGetCurrent.retval);
			break;

		#endif
		#if HAVE_hipGraphAddChildGraphNode
		case HIP_API_ID_hipGraphAddChildGraphNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipGraph_t childGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddChildGraphNode.pGraphNode);
			if (args->hipGraphAddChildGraphNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddChildGraphNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddChildGraphNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddChildGraphNode.pDependencies);
			if (args->hipGraphAddChildGraphNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddChildGraphNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddChildGraphNode.numDependencies);
			printf("\thipGraph_t childGraph = %p", args->hipGraphAddChildGraphNode.childGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphAddChildGraphNode.retval);
			break;

		#endif
		#if HAVE_hipEventCreate
		case HIP_API_ID_hipEventCreate :
			//	hipEvent_t * event (struct ihipEvent_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t * event = %p", args->hipEventCreate.event);
			if (args->hipEventCreate.event != NULL) {
				printf(" -> %p\n", args->hipEventCreate.event__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipEventCreate.retval);
			break;

		#endif
		#if HAVE_hipHostGetDevicePointer
		case HIP_API_ID_hipHostGetDevicePointer :
			//	void ** devPtr (void **);
			//	void * hstPtr (void *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** devPtr = %p", args->hipHostGetDevicePointer.devPtr);
			if (args->hipHostGetDevicePointer.devPtr != NULL) {
				printf("-> %p", args->hipHostGetDevicePointer.devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tvoid * hstPtr = %p", args->hipHostGetDevicePointer.hstPtr);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipHostGetDevicePointer.flags);
			printf("\thipError_t retval = %d\n", args->hipHostGetDevicePointer.retval);
			break;

		#endif
		#if HAVE_hipEventQuery
		case HIP_API_ID_hipEventQuery :
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t event = %p", args->hipEventQuery.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipEventQuery.retval);
			break;

		#endif
		#if HAVE_hipMemcpyPeerAsync
		case HIP_API_ID_hipMemcpyPeerAsync :
			//	void * dst (void *);
			//	int dstDeviceId (int);
			//	const void * src (const void *);
			//	int srcDevice (int);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyPeerAsync.dst);
			printf("\n");
			printf("\tint dstDeviceId = %d\n", args->hipMemcpyPeerAsync.dstDeviceId);
			printf("\tconst void * src = %p", args->hipMemcpyPeerAsync.src);
			printf("\n");
			printf("\tint srcDevice = %d\n", args->hipMemcpyPeerAsync.srcDevice);
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyPeerAsync.sizeBytes);
			printf("\thipStream_t stream = %p", args->hipMemcpyPeerAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyPeerAsync.retval);
			break;

		#endif
		#if HAVE_hipMemMap
		case HIP_API_ID_hipMemMap :
			//	void * ptr (void *);
			//	size_t size (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipMemMap.ptr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->hipMemMap.size);
			printf("\tsize_t offset = %lu\n", args->hipMemMap.offset);
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->hipMemMap.handle);
			printf("\n");
			printf("\tunsigned long long flags = %llu\n", args->hipMemMap.flags);
			printf("\thipError_t retval = %d\n", args->hipMemMap.retval);
			break;

		#endif
		#if HAVE_hipBindTextureToArray
		case HIP_API_ID_hipBindTextureToArray :
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipArray_const_t array (const struct hipArray *);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst textureReference * tex = %p", args->hipBindTextureToArray.tex);
			if (args->hipBindTextureToArray.tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipBindTextureToArray.tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipBindTextureToArray.tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipBindTextureToArray.tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipBindTextureToArray.tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipBindTextureToArray.tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipBindTextureToArray.tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipBindTextureToArray.tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipBindTextureToArray.tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTextureToArray.tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipBindTextureToArray.tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipBindTextureToArray.tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipBindTextureToArray.tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipBindTextureToArray.tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipBindTextureToArray.tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipBindTextureToArray.tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipBindTextureToArray.tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipBindTextureToArray.tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_const_t array = %p", args->hipBindTextureToArray.array);
			printf("\n");
			printf("\tconst hipChannelFormatDesc * desc = %p", args->hipBindTextureToArray.desc);
			if (args->hipBindTextureToArray.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipBindTextureToArray.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipBindTextureToArray.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipBindTextureToArray.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipBindTextureToArray.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTextureToArray.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipBindTextureToArray.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DAsync_spt
		case HIP_API_ID_hipMemcpy2DAsync_spt :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2DAsync_spt.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2DAsync_spt.dpitch);
			printf("\tconst void * src = %p", args->hipMemcpy2DAsync_spt.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2DAsync_spt.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DAsync_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DAsync_spt.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DAsync_spt.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpy2DAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipMemPoolSetAttribute
		case HIP_API_ID_hipMemPoolSetAttribute :
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemPoolAttr attr (enum hipMemPoolAttr);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolSetAttribute.mem_pool);
			printf("\n");
			printf("\thipMemPoolAttr attr = %d\n", args->hipMemPoolSetAttribute.attr);
			printf("\tvoid * value = %p", args->hipMemPoolSetAttribute.value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemPoolSetAttribute.retval);
			break;

		#endif
		#if HAVE_hipGetLastError
		case HIP_API_ID_hipGetLastError :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipGetLastError.retval);
			break;

		#endif
		#if HAVE_hipStreamEndCapture_spt
		case HIP_API_ID_hipStreamEndCapture_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamEndCapture_spt.stream);
			printf("\n");
			printf("\thipGraph_t * pGraph = %p", args->hipStreamEndCapture_spt.pGraph);
			if (args->hipStreamEndCapture_spt.pGraph != NULL) {
				printf(" -> %p\n", args->hipStreamEndCapture_spt.pGraph__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamEndCapture_spt.retval);
			break;

		#endif
		#if HAVE_hipModuleOccupancyMaxPotentialBlockSize
		case HIP_API_ID_hipModuleOccupancyMaxPotentialBlockSize :
			//	int * gridSize (int *);
			//	int * blockSize (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	int blockSizeLimit (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * gridSize = %p", args->hipModuleOccupancyMaxPotentialBlockSize.gridSize);
			if (args->hipModuleOccupancyMaxPotentialBlockSize.gridSize != NULL) {
				printf(" -> %d\n", args->hipModuleOccupancyMaxPotentialBlockSize.gridSize__ref.val);
			} else { printf("\n"); };
			printf("\tint * blockSize = %p", args->hipModuleOccupancyMaxPotentialBlockSize.blockSize);
			if (args->hipModuleOccupancyMaxPotentialBlockSize.blockSize != NULL) {
				printf(" -> %d\n", args->hipModuleOccupancyMaxPotentialBlockSize.blockSize__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->hipModuleOccupancyMaxPotentialBlockSize.f);
			printf("\n");
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipModuleOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk);
			printf("\tint blockSizeLimit = %d\n", args->hipModuleOccupancyMaxPotentialBlockSize.blockSizeLimit);
			printf("\thipError_t retval = %d\n", args->hipModuleOccupancyMaxPotentialBlockSize.retval);
			break;

		#endif
		#if HAVE_hipKernelNameRefByPtr
		case HIP_API_ID_hipKernelNameRefByPtr :
			//	const void * hostFunction (const void *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	const char * retval (const char *);
			printf("\tconst void * hostFunction = %p", args->hipKernelNameRefByPtr.hostFunction);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipKernelNameRefByPtr.stream);
			printf("\n");
			printf("\tconst char * retval = %p", args->hipKernelNameRefByPtr.retval);
			if (args->hipKernelNameRefByPtr.retval != NULL) {
				printf(" -> %s\n", args->hipKernelNameRefByPtr.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipGetDevice
		case HIP_API_ID_hipGetDevice :
			//	int * deviceId (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * deviceId = %p", args->hipGetDevice.deviceId);
			if (args->hipGetDevice.deviceId != NULL) {
				printf(" -> %d\n", args->hipGetDevice.deviceId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGetDevice.retval);
			break;

		#endif
		#if HAVE_hipMemcpy3D_spt
		case HIP_API_ID_hipMemcpy3D_spt :
			//	const struct hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst struct hipMemcpy3DParms * p = %p", args->hipMemcpy3D_spt.p);
			if (args->hipMemcpy3D_spt.p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3D_spt.p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3D_spt.p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3D_spt.p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3D_spt.p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3D_spt.p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3D_spt.p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3D_spt.p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3D_spt.p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3D_spt.p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3D_spt.p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3D_spt.p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3D_spt.p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipMemcpy3D_spt.p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipMemcpy3D_spt.p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipMemcpy3D_spt.p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipMemcpy3D_spt.p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemcpy3D_spt.retval);
			break;

		#endif
		#if HAVE_hipTexObjectGetTextureDesc
		case HIP_API_ID_hipTexObjectGetTextureDesc :
			//	HIP_TEXTURE_DESC * pTexDesc ({
			//		HIPaddress_mode[3] addressMode (enum HIPaddress_mode_enum[3]);
			//		HIPfilter_mode filterMode (enum HIPfilter_mode_enum);
			//		unsigned int flags (unsigned int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		HIPfilter_mode mipmapFilterMode (enum HIPfilter_mode_enum);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		float[4] borderColor (float[4]);
			//		int[12] reserved (int[12]);
			//	});
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\tHIP_TEXTURE_DESC * pTexDesc = %p", args->hipTexObjectGetTextureDesc.pTexDesc);
			if (args->hipTexObjectGetTextureDesc.pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPaddress_mode[3] addressMode = %d\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.addressMode[0]);
				printf("\t\tHIPfilter_mode filterMode = %d\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.filterMode);
				printf("\t\tunsigned int flags = %u\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.flags);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tHIPfilter_mode mipmapFilterMode = %d\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t\tfloat[4] borderColor = %f\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint[12] reserved = %d\n", args->hipTexObjectGetTextureDesc.pTexDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t texObject = %p", args->hipTexObjectGetTextureDesc.texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipTexObjectGetTextureDesc.retval);
			break;

		#endif
		#if HAVE_hipDeviceGet
		case HIP_API_ID_hipDeviceGet :
			//	hipDevice_t * device (int*);
			//	int ordinal (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDevice_t * device = %p", args->hipDeviceGet.device);
			if (args->hipDeviceGet.device != NULL) {
				printf(" -> %d\n", args->hipDeviceGet.device__ref.val);
			} else { printf("\n"); };
			printf("\tint ordinal = %d\n", args->hipDeviceGet.ordinal);
			printf("\thipError_t retval = %d\n", args->hipDeviceGet.retval);
			break;

		#endif
		#if HAVE_hipGraphExternalSemaphoresSignalNodeSetParams
		case HIP_API_ID_hipGraphExternalSemaphoresSignalNodeSetParams :
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreSignalNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExternalSemaphoresSignalNodeSetParams.hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreSignalNodeParams * nodeParams = %p", args->hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams);
			if (args->hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphExternalSemaphoresSignalNodeSetParams.nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExternalSemaphoresSignalNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipDestroySurfaceObject
		case HIP_API_ID_hipDestroySurfaceObject :
			//	hipSurfaceObject_t surfaceObject (struct __hip_surface *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipSurfaceObject_t surfaceObject = %p", args->hipDestroySurfaceObject.surfaceObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDestroySurfaceObject.retval);
			break;

		#endif
		#if HAVE_hipStreamGetDevice
		case HIP_API_ID_hipStreamGetDevice :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipDevice_t * device (int*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetDevice.stream);
			printf("\n");
			printf("\thipDevice_t * device = %p", args->hipStreamGetDevice.device);
			if (args->hipStreamGetDevice.device != NULL) {
				printf(" -> %d\n", args->hipStreamGetDevice.device__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetDevice.retval);
			break;

		#endif
		#if HAVE_hipMemAllocPitch
		case HIP_API_ID_hipMemAllocPitch :
			//	hipDeviceptr_t * dptr (void **);
			//	size_t * pitch (unsigned long*);
			//	size_t widthInBytes (unsigned long);
			//	size_t height (unsigned long);
			//	unsigned int elementSizeBytes (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t * dptr = %p", args->hipMemAllocPitch.dptr);
			if (args->hipMemAllocPitch.dptr != NULL) {
				printf("-> %p", args->hipMemAllocPitch.dptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * pitch = %p", args->hipMemAllocPitch.pitch);
			if (args->hipMemAllocPitch.pitch != NULL) {
				printf(" -> %lu\n", args->hipMemAllocPitch.pitch__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t widthInBytes = %lu\n", args->hipMemAllocPitch.widthInBytes);
			printf("\tsize_t height = %lu\n", args->hipMemAllocPitch.height);
			printf("\tunsigned int elementSizeBytes = %u\n", args->hipMemAllocPitch.elementSizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemAllocPitch.retval);
			break;

		#endif
		#if HAVE_hipGraphAddNode
		case HIP_API_ID_hipGraphAddNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipGraphNodeParams * nodeParams ({
			//		hipGraphNodeType type (enum hipGraphNodeType);
			//		int[3] reserved0 (int[3]);
			//		long long reserved2 (long long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddNode.pGraphNode);
			if (args->hipGraphAddNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddNode.pDependencies);
			if (args->hipGraphAddNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddNode.numDependencies);
			printf("\thipGraphNodeParams * nodeParams = %p", args->hipGraphAddNode.nodeParams);
			if (args->hipGraphAddNode.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipGraphNodeType type = %d\n", args->hipGraphAddNode.nodeParams__ref.val.type);
				printf("\t\tint[3] reserved0 = %d\n", args->hipGraphAddNode.nodeParams__ref.val.reserved0[0]);
				printf("\t\tlong long reserved2 = %lld\n", args->hipGraphAddNode.nodeParams__ref.val.reserved2);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddNode.retval);
			break;

		#endif
		#if HAVE_hipDeviceSetSharedMemConfig
		case HIP_API_ID_hipDeviceSetSharedMemConfig :
			//	hipSharedMemConfig config (enum hipSharedMemConfig);
			//	hipError_t retval (enum hipError_t);
			printf("\thipSharedMemConfig config = %d\n", args->hipDeviceSetSharedMemConfig.config);
			printf("\thipError_t retval = %d\n", args->hipDeviceSetSharedMemConfig.retval);
			break;

		#endif
		#if HAVE_hipRuntimeGetVersion
		case HIP_API_ID_hipRuntimeGetVersion :
			//	int * runtimeVersion (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * runtimeVersion = %p", args->hipRuntimeGetVersion.runtimeVersion);
			if (args->hipRuntimeGetVersion.runtimeVersion != NULL) {
				printf(" -> %d\n", args->hipRuntimeGetVersion.runtimeVersion__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipRuntimeGetVersion.retval);
			break;

		#endif
		#if HAVE_hipGraphChildGraphNodeGetGraph
		case HIP_API_ID_hipGraphChildGraphNodeGetGraph :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraph_t * pGraph (struct ihipGraph **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphChildGraphNodeGetGraph.node);
			printf("\n");
			printf("\thipGraph_t * pGraph = %p", args->hipGraphChildGraphNodeGetGraph.pGraph);
			if (args->hipGraphChildGraphNodeGetGraph.pGraph != NULL) {
				printf(" -> %p\n", args->hipGraphChildGraphNodeGetGraph.pGraph__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphChildGraphNodeGetGraph.retval);
			break;

		#endif
		#if HAVE_hipGraphExecMemsetNodeSetParams
		case HIP_API_ID_hipGraphExecMemsetNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipMemsetParams * pNodeParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecMemsetNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecMemsetNodeSetParams.node);
			printf("\n");
			printf("\tconst hipMemsetParams * pNodeParams = %p", args->hipGraphExecMemsetNodeSetParams.pNodeParams);
			if (args->hipGraphExecMemsetNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->hipGraphExecMemsetNodeSetParams.pNodeParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->hipGraphExecMemsetNodeSetParams.pNodeParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->hipGraphExecMemsetNodeSetParams.pNodeParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->hipGraphExecMemsetNodeSetParams.pNodeParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->hipGraphExecMemsetNodeSetParams.pNodeParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecMemsetNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipGraphicsUnregisterResource
		case HIP_API_ID_hipGraphicsUnregisterResource :
			//	hipGraphicsResource_t resource (struct _hipGraphicsResource*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphicsResource_t resource = %p", args->hipGraphicsUnregisterResource.resource);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphicsUnregisterResource.retval);
			break;

		#endif
		#if HAVE_hipEventElapsedTime
		case HIP_API_ID_hipEventElapsedTime :
			//	float * ms (float *);
			//	hipEvent_t start (struct ihipEvent_t *);
			//	hipEvent_t stop (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tfloat * ms = %p", args->hipEventElapsedTime.ms);
			if (args->hipEventElapsedTime.ms != NULL) {
				printf(" -> %f\n", args->hipEventElapsedTime.ms__ref.val);
			} else { printf("\n"); };
			printf("\thipEvent_t start = %p", args->hipEventElapsedTime.start);
			printf("\n");
			printf("\thipEvent_t stop = %p", args->hipEventElapsedTime.stop);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipEventElapsedTime.retval);
			break;

		#endif
		#if HAVE_hipFreeAsync
		case HIP_API_ID_hipFreeAsync :
			//	void * dev_ptr (void *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dev_ptr = %p", args->hipFreeAsync.dev_ptr);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipFreeAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipFreeAsync.retval);
			break;

		#endif
		#if HAVE_hipStreamCreateWithFlags
		case HIP_API_ID_hipStreamCreateWithFlags :
			//	hipStream_t * stream (struct ihipStream_t **);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t * stream = %p", args->hipStreamCreateWithFlags.stream);
			if (args->hipStreamCreateWithFlags.stream != NULL) {
				printf(" -> %p\n", args->hipStreamCreateWithFlags.stream__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->hipStreamCreateWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamCreateWithFlags.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetAddress
		case HIP_API_ID_hipTexRefSetAddress :
			//	size_t * ByteOffset (unsigned long*);
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipDeviceptr_t dptr (void *);
			//	size_t bytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * ByteOffset = %p", args->hipTexRefSetAddress.ByteOffset);
			if (args->hipTexRefSetAddress.ByteOffset != NULL) {
				printf(" -> %lu\n", args->hipTexRefSetAddress.ByteOffset__ref.val);
			} else { printf("\n"); };
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetAddress.texRef);
			if (args->hipTexRefSetAddress.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetAddress.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetAddress.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetAddress.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetAddress.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetAddress.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetAddress.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetAddress.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetAddress.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetAddress.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetAddress.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetAddress.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetAddress.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetAddress.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetAddress.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetAddress.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetAddress.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetAddress.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipDeviceptr_t dptr = %p", args->hipTexRefSetAddress.dptr);
			printf("\n");
			printf("\tsize_t bytes = %lu\n", args->hipTexRefSetAddress.bytes);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetAddress.retval);
			break;

		#endif
		#if HAVE_hipStreamAddCallback_spt
		case HIP_API_ID_hipStreamAddCallback_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCallback_t callback (void (*)(struct ihipStream_t *, enum hipError_t, void *));
			//	void * userData (void *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamAddCallback_spt.stream);
			printf("\n");
			printf("\thipStreamCallback_t callback = %p\n", args->hipStreamAddCallback_spt.callback);
			printf("\tvoid * userData = %p", args->hipStreamAddCallback_spt.userData);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipStreamAddCallback_spt.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamAddCallback_spt.retval);
			break;

		#endif
		#if HAVE_hipGraphAddKernelNode
		case HIP_API_ID_hipGraphAddKernelNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddKernelNode.pGraphNode);
			if (args->hipGraphAddKernelNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddKernelNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddKernelNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddKernelNode.pDependencies);
			if (args->hipGraphAddKernelNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddKernelNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddKernelNode.numDependencies);
			printf("\tconst hipKernelNodeParams * pNodeParams = %p", args->hipGraphAddKernelNode.pNodeParams);
			if (args->hipGraphAddKernelNode.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->hipGraphAddKernelNode.pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddKernelNode.retval);
			break;

		#endif
		#if HAVE_hipMemcpyDtoH
		case HIP_API_ID_hipMemcpyDtoH :
			//	void * dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyDtoH.dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->hipMemcpyDtoH.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyDtoH.sizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemcpyDtoH.retval);
			break;

		#endif
		#if HAVE_hipDeviceTotalMem
		case HIP_API_ID_hipDeviceTotalMem :
			//	size_t * bytes (unsigned long*);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * bytes = %p", args->hipDeviceTotalMem.bytes);
			if (args->hipDeviceTotalMem.bytes != NULL) {
				printf(" -> %lu\n", args->hipDeviceTotalMem.bytes__ref.val);
			} else { printf("\n"); };
			printf("\thipDevice_t device = %d\n", args->hipDeviceTotalMem.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceTotalMem.retval);
			break;

		#endif
		#if HAVE_hipMemset2D
		case HIP_API_ID_hipMemset2D :
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemset2D.dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->hipMemset2D.pitch);
			printf("\tint value = %d\n", args->hipMemset2D.value);
			printf("\tsize_t width = %lu\n", args->hipMemset2D.width);
			printf("\tsize_t height = %lu\n", args->hipMemset2D.height);
			printf("\thipError_t retval = %d\n", args->hipMemset2D.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DToArray_spt
		case HIP_API_ID_hipMemcpy2DToArray_spt :
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dst = %p", args->hipMemcpy2DToArray_spt.dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DToArray_spt.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DToArray_spt.hOffset);
			printf("\tconst void * src = %p", args->hipMemcpy2DToArray_spt.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2DToArray_spt.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DToArray_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DToArray_spt.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DToArray_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DToArray_spt.retval);
			break;

		#endif
		#if HAVE_hipMemAllocHost
		case HIP_API_ID_hipMemAllocHost :
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipMemAllocHost.ptr);
			if (args->hipMemAllocHost.ptr != NULL) {
				printf("-> %p", args->hipMemAllocHost.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMemAllocHost.size);
			printf("\thipError_t retval = %d\n", args->hipMemAllocHost.retval);
			break;

		#endif
		#if HAVE_hipPointerSetAttribute
		case HIP_API_ID_hipPointerSetAttribute :
			//	const void * value (const void *);
			//	hipPointer_attribute attribute (enum hipPointer_attribute);
			//	hipDeviceptr_t ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * value = %p", args->hipPointerSetAttribute.value);
			printf("\n");
			printf("\thipPointer_attribute attribute = %d\n", args->hipPointerSetAttribute.attribute);
			printf("\thipDeviceptr_t ptr = %p", args->hipPointerSetAttribute.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipPointerSetAttribute.retval);
			break;

		#endif
		#if HAVE_hipGraphHostNodeGetParams
		case HIP_API_ID_hipGraphHostNodeGetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphHostNodeGetParams.node);
			printf("\n");
			printf("\thipHostNodeParams * pNodeParams = %p", args->hipGraphHostNodeGetParams.pNodeParams);
			if (args->hipGraphHostNodeGetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->hipGraphHostNodeGetParams.pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphHostNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipMemset3D
		case HIP_API_ID_hipMemset3D :
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->hipMemset3D.pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->hipMemset3D.pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->hipMemset3D.pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->hipMemset3D.value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMemset3D.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMemset3D.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMemset3D.extent.depth);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->hipMemset3D.retval);
			break;

		#endif
		#if HAVE_hipDestroyTextureObject
		case HIP_API_ID_hipDestroyTextureObject :
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipTextureObject_t textureObject = %p", args->hipDestroyTextureObject.textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDestroyTextureObject.retval);
			break;

		#endif
		#if HAVE_hipMemAdvise
		case HIP_API_ID_hipMemAdvise :
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	hipMemoryAdvise advice (enum hipMemoryAdvise);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * dev_ptr = %p", args->hipMemAdvise.dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipMemAdvise.count);
			printf("\thipMemoryAdvise advice = %d\n", args->hipMemAdvise.advice);
			printf("\tint device = %d\n", args->hipMemAdvise.device);
			printf("\thipError_t retval = %d\n", args->hipMemAdvise.retval);
			break;

		#endif
		#if HAVE_hipCtxGetCacheConfig
		case HIP_API_ID_hipCtxGetCacheConfig :
			//	hipFuncCache_t * cacheConfig (enum hipFuncCache_t*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFuncCache_t * cacheConfig = %p", args->hipCtxGetCacheConfig.cacheConfig);
			if (args->hipCtxGetCacheConfig.cacheConfig != NULL) {
				printf(" -> %d\n", args->hipCtxGetCacheConfig.cacheConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxGetCacheConfig.retval);
			break;

		#endif
		#if HAVE_hipDrvPointerGetAttributes
		case HIP_API_ID_hipDrvPointerGetAttributes :
			//	unsigned int numAttributes (unsigned int);
			//	hipPointer_attribute * attributes (enum hipPointer_attribute*);
			//	void ** data (void **);
			//	hipDeviceptr_t ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int numAttributes = %u\n", args->hipDrvPointerGetAttributes.numAttributes);
			printf("\thipPointer_attribute * attributes = %p", args->hipDrvPointerGetAttributes.attributes);
			if (args->hipDrvPointerGetAttributes.attributes != NULL) {
				printf(" -> %d\n", args->hipDrvPointerGetAttributes.attributes__ref.val);
			} else { printf("\n"); };
			printf("\tvoid ** data = %p", args->hipDrvPointerGetAttributes.data);
			if (args->hipDrvPointerGetAttributes.data != NULL) {
				printf("-> %p", args->hipDrvPointerGetAttributes.data__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipDeviceptr_t ptr = %p", args->hipDrvPointerGetAttributes.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDrvPointerGetAttributes.retval);
			break;

		#endif
		#if HAVE_hipModuleLaunchCooperativeKernelMultiDevice
		case HIP_API_ID_hipModuleLaunchCooperativeKernelMultiDevice :
			//	hipFunctionLaunchParams * launchParamsList ({
			//		hipFunction_t function (struct ihipModuleSymbol_t *);
			//		unsigned int gridDimX (unsigned int);
			//		unsigned int gridDimY (unsigned int);
			//		unsigned int gridDimZ (unsigned int);
			//		unsigned int blockDimX (unsigned int);
			//		unsigned int blockDimY (unsigned int);
			//		unsigned int blockDimZ (unsigned int);
			//		unsigned int sharedMemBytes (unsigned int);
			//		hipStream_t hStream (struct ihipStream_t *);
			//		void ** kernelParams (void **);
			//	});
			//	unsigned int numDevices (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFunctionLaunchParams * launchParamsList = %p", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList);
			if (args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int gridDimX = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.gridDimX);
				printf("\t\tunsigned int gridDimY = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.gridDimY);
				printf("\t\tunsigned int gridDimZ = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.gridDimZ);
				printf("\t\tunsigned int blockDimX = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.blockDimX);
				printf("\t\tunsigned int blockDimY = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.blockDimY);
				printf("\t\tunsigned int blockDimZ = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.blockDimZ);
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numDevices = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.numDevices);
			printf("\tunsigned int flags = %u\n", args->hipModuleLaunchCooperativeKernelMultiDevice.flags);
			printf("\thipError_t retval = %d\n", args->hipModuleLaunchCooperativeKernelMultiDevice.retval);
			break;

		#endif
		#if HAVE_hipModuleGetGlobal
		case HIP_API_ID_hipModuleGetGlobal :
			//	hipDeviceptr_t * dptr (void **);
			//	size_t * bytes (unsigned long*);
			//	hipModule_t hmod (struct ihipModule_t *);
			//	const char * name (const char *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t * dptr = %p", args->hipModuleGetGlobal.dptr);
			if (args->hipModuleGetGlobal.dptr != NULL) {
				printf("-> %p", args->hipModuleGetGlobal.dptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * bytes = %p", args->hipModuleGetGlobal.bytes);
			if (args->hipModuleGetGlobal.bytes != NULL) {
				printf(" -> %lu\n", args->hipModuleGetGlobal.bytes__ref.val);
			} else { printf("\n"); };
			printf("\thipModule_t hmod = %p", args->hipModuleGetGlobal.hmod);
			printf("\n");
			printf("\tconst char * name = %p", args->hipModuleGetGlobal.name);
			if (args->hipModuleGetGlobal.name != NULL) {
				printf(" -> %s\n", args->hipModuleGetGlobal.name__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleGetGlobal.retval);
			break;

		#endif
		#if HAVE_hipGraphEventRecordNodeGetEvent
		case HIP_API_ID_hipGraphEventRecordNodeGetEvent :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t * event_out (struct ihipEvent_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphEventRecordNodeGetEvent.node);
			printf("\n");
			printf("\thipEvent_t * event_out = %p", args->hipGraphEventRecordNodeGetEvent.event_out);
			if (args->hipGraphEventRecordNodeGetEvent.event_out != NULL) {
				printf(" -> %p\n", args->hipGraphEventRecordNodeGetEvent.event_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphEventRecordNodeGetEvent.retval);
			break;

		#endif
		#if HAVE_hipGraphInstantiate
		case HIP_API_ID_hipGraphInstantiate :
			//	hipGraphExec_t * pGraphExec (struct hipGraphExec **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * pErrorNode (struct hipGraphNode **);
			//	char * pLogBuffer (char *);
			//	size_t bufferSize (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t * pGraphExec = %p", args->hipGraphInstantiate.pGraphExec);
			if (args->hipGraphInstantiate.pGraphExec != NULL) {
				printf(" -> %p\n", args->hipGraphInstantiate.pGraphExec__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphInstantiate.graph);
			printf("\n");
			printf("\thipGraphNode_t * pErrorNode = %p", args->hipGraphInstantiate.pErrorNode);
			if (args->hipGraphInstantiate.pErrorNode != NULL) {
				printf(" -> %p\n", args->hipGraphInstantiate.pErrorNode__ref.val);
			} else { printf("\n"); };
			printf("\tchar * pLogBuffer = %p", args->hipGraphInstantiate.pLogBuffer);
			if (args->hipGraphInstantiate.pLogBuffer != NULL) {
				printf(" -> %s\n", args->hipGraphInstantiate.pLogBuffer__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t bufferSize = %lu\n", args->hipGraphInstantiate.bufferSize);
			printf("\thipError_t retval = %d\n", args->hipGraphInstantiate.retval);
			break;

		#endif
		#if HAVE_hipGraphRetainUserObject
		case HIP_API_ID_hipGraphRetainUserObject :
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphRetainUserObject.graph);
			printf("\n");
			printf("\thipUserObject_t object = %p", args->hipGraphRetainUserObject.object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->hipGraphRetainUserObject.count);
			printf("\tunsigned int flags = %u\n", args->hipGraphRetainUserObject.flags);
			printf("\thipError_t retval = %d\n", args->hipGraphRetainUserObject.retval);
			break;

		#endif
		#if HAVE_hipGraphMemAllocNodeGetParams
		case HIP_API_ID_hipGraphMemAllocNodeGetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemAllocNodeParams * pNodeParams ({
			//		hipMemPoolProps poolProps ({
			//			hipMemAllocationType allocType (enum hipMemAllocationType);
			//			hipMemAllocationHandleType handleTypes (enum hipMemAllocationHandleType);
			//			hipMemLocation location ({
			//				hipMemLocationType type (enum hipMemLocationType);
			//				int id (int);
			//			});
			//			void * win32SecurityAttributes (void *);
			//			size_t maxSize (unsigned long);
			//			unsigned char[56] reserved (unsigned char[56]);
			//		});
			//		size_t accessDescCount (unsigned long);
			//		size_t bytesize (unsigned long);
			//		void * dptr (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemAllocNodeGetParams.node);
			printf("\n");
			printf("\thipMemAllocNodeParams * pNodeParams = %p", args->hipGraphMemAllocNodeGetParams.pNodeParams);
			if (args->hipGraphMemAllocNodeGetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemPoolProps poolProps = {\n");
				printf("\t\t\thipMemAllocationType allocType = %d\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.poolProps.allocType);
				printf("\t\t\thipMemAllocationHandleType handleTypes = %d\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.poolProps.handleTypes);
				printf("\t\t\thipMemLocation location = {\n");
				printf("\t\t\t\thipMemLocationType type = %d\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.poolProps.location.type);
				printf("\t\t\t\tint id = %d\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.poolProps.location.id);
				printf("\t\t\t}\n");
				printf("\t\t\tsize_t maxSize = %lu\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.poolProps.maxSize);
				printf("\t\t\tunsigned char[56] reserved = %hhu\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.poolProps.reserved[0]);
				printf("\t\t}\n");
				printf("\t\tsize_t accessDescCount = %lu\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.accessDescCount);
				printf("\t\tsize_t bytesize = %lu\n", args->hipGraphMemAllocNodeGetParams.pNodeParams__ref.val.bytesize);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphMemAllocNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipStreamGetCaptureInfo
		case HIP_API_ID_hipStreamGetCaptureInfo :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	unsigned long long * pId (unsigned long long *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetCaptureInfo.stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->hipStreamGetCaptureInfo.pCaptureStatus);
			if (args->hipStreamGetCaptureInfo.pCaptureStatus != NULL) {
				printf(" -> %d\n", args->hipStreamGetCaptureInfo.pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * pId = %p", args->hipStreamGetCaptureInfo.pId);
			if (args->hipStreamGetCaptureInfo.pId != NULL) {
				printf(" -> %llu\n", args->hipStreamGetCaptureInfo.pId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetCaptureInfo.retval);
			break;

		#endif
		#if HAVE_hipCtxPopCurrent
		case HIP_API_ID_hipCtxPopCurrent :
			//	hipCtx_t * ctx (struct ihipCtx_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t * ctx = %p", args->hipCtxPopCurrent.ctx);
			if (args->hipCtxPopCurrent.ctx != NULL) {
				printf(" -> %p\n", args->hipCtxPopCurrent.ctx__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxPopCurrent.retval);
			break;

		#endif
		#if HAVE_hipPointerGetAttributes
		case HIP_API_ID_hipPointerGetAttributes :
			//	hipPointerAttribute_t * attributes ({
			//		enum hipMemoryType type (enum hipMemoryType);
			//		int device (int);
			//		void * devicePointer (void *);
			//		void * hostPointer (void *);
			//		int isManaged (int);
			//		unsigned int allocationFlags (unsigned int);
			//	});
			//	const void * ptr (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipPointerAttribute_t * attributes = %p", args->hipPointerGetAttributes.attributes);
			if (args->hipPointerGetAttributes.attributes != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipMemoryType type = %d\n", args->hipPointerGetAttributes.attributes__ref.val.type);
				printf("\t\tint device = %d\n", args->hipPointerGetAttributes.attributes__ref.val.device);
				printf("\t\tint isManaged = %d\n", args->hipPointerGetAttributes.attributes__ref.val.isManaged);
				printf("\t\tunsigned int allocationFlags = %u\n", args->hipPointerGetAttributes.attributes__ref.val.allocationFlags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * ptr = %p", args->hipPointerGetAttributes.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipPointerGetAttributes.retval);
			break;

		#endif
		#if HAVE_hipDeviceDisablePeerAccess
		case HIP_API_ID_hipDeviceDisablePeerAccess :
			//	int peerDeviceId (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint peerDeviceId = %d\n", args->hipDeviceDisablePeerAccess.peerDeviceId);
			printf("\thipError_t retval = %d\n", args->hipDeviceDisablePeerAccess.retval);
			break;

		#endif
		#if HAVE_hipMallocPitch
		case HIP_API_ID_hipMallocPitch :
			//	void ** ptr (void **);
			//	size_t * pitch (unsigned long*);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipMallocPitch.ptr);
			if (args->hipMallocPitch.ptr != NULL) {
				printf("-> %p", args->hipMallocPitch.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * pitch = %p", args->hipMallocPitch.pitch);
			if (args->hipMallocPitch.pitch != NULL) {
				printf(" -> %lu\n", args->hipMallocPitch.pitch__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t width = %lu\n", args->hipMallocPitch.width);
			printf("\tsize_t height = %lu\n", args->hipMallocPitch.height);
			printf("\thipError_t retval = %d\n", args->hipMallocPitch.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DFromArrayAsync
		case HIP_API_ID_hipMemcpy2DFromArrayAsync :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2DFromArrayAsync.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2DFromArrayAsync.dpitch);
			printf("\thipArray_const_t src = %p", args->hipMemcpy2DFromArrayAsync.src);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DFromArrayAsync.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DFromArrayAsync.hOffset);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DFromArrayAsync.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DFromArrayAsync.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DFromArrayAsync.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpy2DFromArrayAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DFromArrayAsync.retval);
			break;

		#endif
		#if HAVE_hipDeviceComputeCapability
		case HIP_API_ID_hipDeviceComputeCapability :
			//	int * major (int *);
			//	int * minor (int *);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * major = %p", args->hipDeviceComputeCapability.major);
			if (args->hipDeviceComputeCapability.major != NULL) {
				printf(" -> %d\n", args->hipDeviceComputeCapability.major__ref.val);
			} else { printf("\n"); };
			printf("\tint * minor = %p", args->hipDeviceComputeCapability.minor);
			if (args->hipDeviceComputeCapability.minor != NULL) {
				printf(" -> %d\n", args->hipDeviceComputeCapability.minor__ref.val);
			} else { printf("\n"); };
			printf("\thipDevice_t device = %d\n", args->hipDeviceComputeCapability.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceComputeCapability.retval);
			break;

		#endif
		#if HAVE_hipMemcpyHtoD
		case HIP_API_ID_hipMemcpyHtoD :
			//	hipDeviceptr_t dst (void *);
			//	void * src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dst = %p", args->hipMemcpyHtoD.dst);
			printf("\n");
			printf("\tvoid * src = %p", args->hipMemcpyHtoD.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyHtoD.sizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemcpyHtoD.retval);
			break;

		#endif
		#if HAVE_hipOccupancyMaxActiveBlocksPerMultiprocessor
		case HIP_API_ID_hipOccupancyMaxActiveBlocksPerMultiprocessor :
			//	int * numBlocks (int *);
			//	const void * f (const void *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * numBlocks = %p", args->hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks);
			if (args->hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks != NULL) {
				printf(" -> %d\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * f = %p", args->hipOccupancyMaxActiveBlocksPerMultiprocessor.f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessor.blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk);
			printf("\thipError_t retval = %d\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessor.retval);
			break;

		#endif
		#if HAVE_hipSignalExternalSemaphoresAsync
		case HIP_API_ID_hipSignalExternalSemaphoresAsync :
			//	const hipExternalSemaphore_t * extSemArray (const void * *);
			//	const hipExternalSemaphoreSignalParams * paramsArray ({
			//		struct (unnamed struct at header/hip/hip.h:1488:2) params ({
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	unsigned int numExtSems (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst hipExternalSemaphore_t * extSemArray = %p", args->hipSignalExternalSemaphoresAsync.extSemArray);
			if (args->hipSignalExternalSemaphoresAsync.extSemArray != NULL) {
				printf("-> %p", args->hipSignalExternalSemaphoresAsync.extSemArray__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalSemaphoreSignalParams * paramsArray = %p", args->hipSignalExternalSemaphoresAsync.paramsArray);
			if (args->hipSignalExternalSemaphoresAsync.paramsArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1488:2) params = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->hipSignalExternalSemaphoresAsync.paramsArray__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipSignalExternalSemaphoresAsync.paramsArray__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numExtSems = %u\n", args->hipSignalExternalSemaphoresAsync.numExtSems);
			printf("\thipStream_t stream = %p", args->hipSignalExternalSemaphoresAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipSignalExternalSemaphoresAsync.retval);
			break;

		#endif
		#if HAVE_hipArray3DGetDescriptor
		case HIP_API_ID_hipArray3DGetDescriptor :
			//	HIP_ARRAY3D_DESCRIPTOR * pArrayDescriptor ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//		unsigned int Flags (unsigned int);
			//	});
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			printf("\tHIP_ARRAY3D_DESCRIPTOR * pArrayDescriptor = %p", args->hipArray3DGetDescriptor.pArrayDescriptor);
			if (args->hipArray3DGetDescriptor.pArrayDescriptor != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->hipArray3DGetDescriptor.pArrayDescriptor__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->hipArray3DGetDescriptor.pArrayDescriptor__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->hipArray3DGetDescriptor.pArrayDescriptor__ref.val.Depth);
				printf("\t\tenum hipArray_Format Format = %d\n", args->hipArray3DGetDescriptor.pArrayDescriptor__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->hipArray3DGetDescriptor.pArrayDescriptor__ref.val.NumChannels);
				printf("\t\tunsigned int Flags = %u\n", args->hipArray3DGetDescriptor.pArrayDescriptor__ref.val.Flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_t array = %p", args->hipArray3DGetDescriptor.array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipArray3DGetDescriptor.retval);
			break;

		#endif
		#if HAVE___hipPopCallConfiguration
		case HIP_API_ID___hipPopCallConfiguration :
			//	dim3 * gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 * blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	size_t * sharedMem (unsigned long*);
			//	hipStream_t * stream (struct ihipStream_t **);
			//	hipError_t retval (enum hipError_t);
			printf("\tdim3 * gridDim = %p", args->__hipPopCallConfiguration.gridDim);
			if (args->__hipPopCallConfiguration.gridDim != NULL) {
				printf(" -> {\n");
				printf("\t\tuint32_t x = %u\n", args->__hipPopCallConfiguration.gridDim__ref.val.x);
				printf("\t\tuint32_t y = %u\n", args->__hipPopCallConfiguration.gridDim__ref.val.y);
				printf("\t\tuint32_t z = %u\n", args->__hipPopCallConfiguration.gridDim__ref.val.z);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tdim3 * blockDim = %p", args->__hipPopCallConfiguration.blockDim);
			if (args->__hipPopCallConfiguration.blockDim != NULL) {
				printf(" -> {\n");
				printf("\t\tuint32_t x = %u\n", args->__hipPopCallConfiguration.blockDim__ref.val.x);
				printf("\t\tuint32_t y = %u\n", args->__hipPopCallConfiguration.blockDim__ref.val.y);
				printf("\t\tuint32_t z = %u\n", args->__hipPopCallConfiguration.blockDim__ref.val.z);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t * sharedMem = %p", args->__hipPopCallConfiguration.sharedMem);
			if (args->__hipPopCallConfiguration.sharedMem != NULL) {
				printf(" -> %lu\n", args->__hipPopCallConfiguration.sharedMem__ref.val);
			} else { printf("\n"); };
			printf("\thipStream_t * stream = %p", args->__hipPopCallConfiguration.stream);
			if (args->__hipPopCallConfiguration.stream != NULL) {
				printf(" -> %p\n", args->__hipPopCallConfiguration.stream__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->__hipPopCallConfiguration.retval);
			break;

		#endif
		#if HAVE_hipDevicePrimaryCtxRelease
		case HIP_API_ID_hipDevicePrimaryCtxRelease :
			//	hipDevice_t dev (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDevice_t dev = %d\n", args->hipDevicePrimaryCtxRelease.dev);
			printf("\thipError_t retval = %d\n", args->hipDevicePrimaryCtxRelease.retval);
			break;

		#endif
		#if HAVE_hipLaunchCooperativeKernelMultiDevice
		case HIP_API_ID_hipLaunchCooperativeKernelMultiDevice :
			//	hipLaunchParams * launchParamsList ({
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** args (void **);
			//		size_t sharedMem (unsigned long);
			//		hipStream_t stream (struct ihipStream_t *);
			//	});
			//	int numDevices (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipLaunchParams * launchParamsList = %p", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList);
			if (args->hipLaunchCooperativeKernelMultiDevice.launchParamsList != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tsize_t sharedMem = %lu\n", args->hipLaunchCooperativeKernelMultiDevice.launchParamsList__ref.val.sharedMem);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint numDevices = %d\n", args->hipLaunchCooperativeKernelMultiDevice.numDevices);
			printf("\tunsigned int flags = %u\n", args->hipLaunchCooperativeKernelMultiDevice.flags);
			printf("\thipError_t retval = %d\n", args->hipLaunchCooperativeKernelMultiDevice.retval);
			break;

		#endif
		#if HAVE_hipFreeArray
		case HIP_API_ID_hipFreeArray :
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t array = %p", args->hipFreeArray.array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipFreeArray.retval);
			break;

		#endif
		#if HAVE_hipGraphMemsetNodeSetParams
		case HIP_API_ID_hipGraphMemsetNodeSetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipMemsetParams * pNodeParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemsetNodeSetParams.node);
			printf("\n");
			printf("\tconst hipMemsetParams * pNodeParams = %p", args->hipGraphMemsetNodeSetParams.pNodeParams);
			if (args->hipGraphMemsetNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->hipGraphMemsetNodeSetParams.pNodeParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->hipGraphMemsetNodeSetParams.pNodeParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->hipGraphMemsetNodeSetParams.pNodeParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->hipGraphMemsetNodeSetParams.pNodeParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->hipGraphMemsetNodeSetParams.pNodeParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphMemsetNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipMemPoolSetAccess
		case HIP_API_ID_hipMemPoolSetAccess :
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	const hipMemAccessDesc * desc_list ({
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		hipMemAccessFlags flags (enum hipMemAccessFlags);
			//	});
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolSetAccess.mem_pool);
			printf("\n");
			printf("\tconst hipMemAccessDesc * desc_list = %p", args->hipMemPoolSetAccess.desc_list);
			if (args->hipMemPoolSetAccess.desc_list != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->hipMemPoolSetAccess.desc_list__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->hipMemPoolSetAccess.desc_list__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\thipMemAccessFlags flags = %d\n", args->hipMemPoolSetAccess.desc_list__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t count = %lu\n", args->hipMemPoolSetAccess.count);
			printf("\thipError_t retval = %d\n", args->hipMemPoolSetAccess.retval);
			break;

		#endif
		#if HAVE_hipGetStreamDeviceId
		case HIP_API_ID_hipGetStreamDeviceId :
			//	hipStream_t stream (struct ihipStream_t *);
			//	int retval (int);
			printf("\thipStream_t stream = %p", args->hipGetStreamDeviceId.stream);
			printf("\n");
			printf("\tint retval = %d\n", args->hipGetStreamDeviceId.retval);
			break;

		#endif
		#if HAVE_hipExtStreamCreateWithCUMask
		case HIP_API_ID_hipExtStreamCreateWithCUMask :
			//	hipStream_t * stream (struct ihipStream_t **);
			//	uint32_t cuMaskSize (unsigned int);
			//	const uint32_t * cuMask (const unsigned int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t * stream = %p", args->hipExtStreamCreateWithCUMask.stream);
			if (args->hipExtStreamCreateWithCUMask.stream != NULL) {
				printf(" -> %p\n", args->hipExtStreamCreateWithCUMask.stream__ref.val);
			} else { printf("\n"); };
			printf("\tuint32_t cuMaskSize = %u\n", args->hipExtStreamCreateWithCUMask.cuMaskSize);
			printf("\tconst uint32_t * cuMask = %p", args->hipExtStreamCreateWithCUMask.cuMask);
			if (args->hipExtStreamCreateWithCUMask.cuMask != NULL) {
				printf(" -> %u\n", args->hipExtStreamCreateWithCUMask.cuMask__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipExtStreamCreateWithCUMask.retval);
			break;

		#endif
		#if HAVE_hipGetTextureObjectTextureDesc
		case HIP_API_ID_hipGetTextureObjectTextureDesc :
			//	hipTextureDesc * pTexDesc ({
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		int sRGB (int);
			//		float[4] borderColor (float[4]);
			//		int normalizedCoords (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//	});
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipTextureDesc * pTexDesc = %p", args->hipGetTextureObjectTextureDesc.pTexDesc);
			if (args->hipGetTextureObjectTextureDesc.pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.addressMode[0]);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.filterMode);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.readMode);
				printf("\t\tint sRGB = %d\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.sRGB);
				printf("\t\tfloat[4] borderColor = %f\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint normalizedCoords = %d\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.normalizedCoords);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipGetTextureObjectTextureDesc.pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t textureObject = %p", args->hipGetTextureObjectTextureDesc.textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetTextureObjectTextureDesc.retval);
			break;

		#endif
		#if HAVE_hipEventRecord_spt
		case HIP_API_ID_hipEventRecord_spt :
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t event = %p", args->hipEventRecord_spt.event);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipEventRecord_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipEventRecord_spt.retval);
			break;

		#endif
		#if HAVE_hipConfigureCall
		case HIP_API_ID_hipConfigureCall :
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	size_t sharedMem (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipConfigureCall.gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->hipConfigureCall.gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->hipConfigureCall.gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipConfigureCall.blockDim.x);
			printf("\t\tuint32_t y = %u\n", args->hipConfigureCall.blockDim.y);
			printf("\t\tuint32_t z = %u\n", args->hipConfigureCall.blockDim.z);
			printf("\t}\n");
			printf("\tsize_t sharedMem = %lu\n", args->hipConfigureCall.sharedMem);
			printf("\thipStream_t stream = %p", args->hipConfigureCall.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipConfigureCall.retval);
			break;

		#endif
		#if HAVE_hipMemcpyFromArray_spt
		case HIP_API_ID_hipMemcpyFromArray_spt :
			//	void * dst (void *);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffsetSrc (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyFromArray_spt.dst);
			printf("\n");
			printf("\thipArray_const_t src = %p", args->hipMemcpyFromArray_spt.src);
			printf("\n");
			printf("\tsize_t wOffsetSrc = %lu\n", args->hipMemcpyFromArray_spt.wOffsetSrc);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpyFromArray_spt.hOffset);
			printf("\tsize_t count = %lu\n", args->hipMemcpyFromArray_spt.count);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyFromArray_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyFromArray_spt.retval);
			break;

		#endif
		#if HAVE_hipModuleGetFunction
		case HIP_API_ID_hipModuleGetFunction :
			//	hipFunction_t * function (struct ihipModuleSymbol_t **);
			//	hipModule_t module (struct ihipModule_t *);
			//	const char * kname (const char *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFunction_t * function = %p", args->hipModuleGetFunction.function);
			if (args->hipModuleGetFunction.function != NULL) {
				printf(" -> %p\n", args->hipModuleGetFunction.function__ref.val);
			} else { printf("\n"); };
			printf("\thipModule_t module = %p", args->hipModuleGetFunction.module);
			printf("\n");
			printf("\tconst char * kname = %p", args->hipModuleGetFunction.kname);
			if (args->hipModuleGetFunction.kname != NULL) {
				printf(" -> %s\n", args->hipModuleGetFunction.kname__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleGetFunction.retval);
			break;

		#endif
		#if HAVE_hipFuncSetCacheConfig
		case HIP_API_ID_hipFuncSetCacheConfig :
			//	const void * func (const void *);
			//	hipFuncCache_t config (enum hipFuncCache_t);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * func = %p", args->hipFuncSetCacheConfig.func);
			printf("\n");
			printf("\thipFuncCache_t config = %d\n", args->hipFuncSetCacheConfig.config);
			printf("\thipError_t retval = %d\n", args->hipFuncSetCacheConfig.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetLimit
		case HIP_API_ID_hipDeviceGetLimit :
			//	size_t * pValue (unsigned long*);
			//	enum hipLimit_t limit (enum hipLimit_t);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * pValue = %p", args->hipDeviceGetLimit.pValue);
			if (args->hipDeviceGetLimit.pValue != NULL) {
				printf(" -> %lu\n", args->hipDeviceGetLimit.pValue__ref.val);
			} else { printf("\n"); };
			printf("\tenum hipLimit_t limit = %d\n", args->hipDeviceGetLimit.limit);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetLimit.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetMaxAnisotropy
		case HIP_API_ID_hipTexRefGetMaxAnisotropy :
			//	int * pmaxAnsio (int *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tint * pmaxAnsio = %p", args->hipTexRefGetMaxAnisotropy.pmaxAnsio);
			if (args->hipTexRefGetMaxAnisotropy.pmaxAnsio != NULL) {
				printf(" -> %d\n", args->hipTexRefGetMaxAnisotropy.pmaxAnsio__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetMaxAnisotropy.texRef);
			if (args->hipTexRefGetMaxAnisotropy.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetMaxAnisotropy.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetMaxAnisotropy.retval);
			break;

		#endif
		#if HAVE_hipLaunchKernel_spt
		case HIP_API_ID_hipLaunchKernel_spt :
			//	const void * function_address (const void *);
			//	dim3 numBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 dimBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** args (void **);
			//	size_t sharedMemBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * function_address = %p", args->hipLaunchKernel_spt.function_address);
			printf("\n");
			printf("\tdim3 numBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchKernel_spt.numBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchKernel_spt.numBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchKernel_spt.numBlocks.z);
			printf("\t}\n");
			printf("\tdim3 dimBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchKernel_spt.dimBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchKernel_spt.dimBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchKernel_spt.dimBlocks.z);
			printf("\t}\n");
			printf("\tvoid ** args = %p", args->hipLaunchKernel_spt.args);
			if (args->hipLaunchKernel_spt.args != NULL) {
				printf("-> %p", args->hipLaunchKernel_spt.args__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sharedMemBytes = %lu\n", args->hipLaunchKernel_spt.sharedMemBytes);
			printf("\thipStream_t stream = %p", args->hipLaunchKernel_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchKernel_spt.retval);
			break;

		#endif
		#if HAVE_hipStreamBeginCaptureToGraph
		case HIP_API_ID_hipStreamBeginCaptureToGraph :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * dependencies (const struct hipGraphNode * *);
			//	const hipGraphEdgeData * dependencyData ({
			//		unsigned char from_port (unsigned char);
			//		unsigned char[5] reserved (unsigned char[5]);
			//		unsigned char to_port (unsigned char);
			//		unsigned char type (unsigned char);
			//	});
			//	size_t numDependencies (unsigned long);
			//	hipStreamCaptureMode mode (enum hipStreamCaptureMode);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamBeginCaptureToGraph.stream);
			printf("\n");
			printf("\thipGraph_t graph = %p", args->hipStreamBeginCaptureToGraph.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * dependencies = %p", args->hipStreamBeginCaptureToGraph.dependencies);
			if (args->hipStreamBeginCaptureToGraph.dependencies != NULL) {
				printf(" -> %p\n", args->hipStreamBeginCaptureToGraph.dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphEdgeData * dependencyData = %p", args->hipStreamBeginCaptureToGraph.dependencyData);
			if (args->hipStreamBeginCaptureToGraph.dependencyData != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned char from_port = %hhu\n", args->hipStreamBeginCaptureToGraph.dependencyData__ref.val.from_port);
				printf("\t\tunsigned char[5] reserved = %hhu\n", args->hipStreamBeginCaptureToGraph.dependencyData__ref.val.reserved[0]);
				printf("\t\tunsigned char to_port = %hhu\n", args->hipStreamBeginCaptureToGraph.dependencyData__ref.val.to_port);
				printf("\t\tunsigned char type = %hhu\n", args->hipStreamBeginCaptureToGraph.dependencyData__ref.val.type);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipStreamBeginCaptureToGraph.numDependencies);
			printf("\thipStreamCaptureMode mode = %d\n", args->hipStreamBeginCaptureToGraph.mode);
			printf("\thipError_t retval = %d\n", args->hipStreamBeginCaptureToGraph.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetFormat
		case HIP_API_ID_hipTexRefGetFormat :
			//	hipArray_Format * pFormat (enum hipArray_Format*);
			//	int * pNumChannels (int *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_Format * pFormat = %p", args->hipTexRefGetFormat.pFormat);
			if (args->hipTexRefGetFormat.pFormat != NULL) {
				printf(" -> %d\n", args->hipTexRefGetFormat.pFormat__ref.val);
			} else { printf("\n"); };
			printf("\tint * pNumChannels = %p", args->hipTexRefGetFormat.pNumChannels);
			if (args->hipTexRefGetFormat.pNumChannels != NULL) {
				printf(" -> %d\n", args->hipTexRefGetFormat.pNumChannels__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetFormat.texRef);
			if (args->hipTexRefGetFormat.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetFormat.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetFormat.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetFormat.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetFormat.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetFormat.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetFormat.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetFormat.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetFormat.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetFormat.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetFormat.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetFormat.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetFormat.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetFormat.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetFormat.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetFormat.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetFormat.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetFormat.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetFormat.retval);
			break;

		#endif
		#if HAVE_hipStreamWaitValue64
		case HIP_API_ID_hipStreamWaitValue64 :
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint64_t value (unsigned long);
			//	unsigned int flags (unsigned int);
			//	uint64_t mask (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamWaitValue64.stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->hipStreamWaitValue64.ptr);
			printf("\n");
			printf("\tuint64_t value = %lu\n", args->hipStreamWaitValue64.value);
			printf("\tunsigned int flags = %u\n", args->hipStreamWaitValue64.flags);
			printf("\tuint64_t mask = %lu\n", args->hipStreamWaitValue64.mask);
			printf("\thipError_t retval = %d\n", args->hipStreamWaitValue64.retval);
			break;

		#endif
		#if HAVE_hipDevicePrimaryCtxRetain
		case HIP_API_ID_hipDevicePrimaryCtxRetain :
			//	hipCtx_t * pctx (struct ihipCtx_t **);
			//	hipDevice_t dev (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t * pctx = %p", args->hipDevicePrimaryCtxRetain.pctx);
			if (args->hipDevicePrimaryCtxRetain.pctx != NULL) {
				printf(" -> %p\n", args->hipDevicePrimaryCtxRetain.pctx__ref.val);
			} else { printf("\n"); };
			printf("\thipDevice_t dev = %d\n", args->hipDevicePrimaryCtxRetain.dev);
			printf("\thipError_t retval = %d\n", args->hipDevicePrimaryCtxRetain.retval);
			break;

		#endif
		#if HAVE_hipMallocManaged
		case HIP_API_ID_hipMallocManaged :
			//	void ** dev_ptr (void **);
			//	size_t size (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** dev_ptr = %p", args->hipMallocManaged.dev_ptr);
			if (args->hipMallocManaged.dev_ptr != NULL) {
				printf("-> %p", args->hipMallocManaged.dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMallocManaged.size);
			printf("\tunsigned int flags = %u\n", args->hipMallocManaged.flags);
			printf("\thipError_t retval = %d\n", args->hipMallocManaged.retval);
			break;

		#endif
		#if HAVE_hipStreamCreateWithPriority
		case HIP_API_ID_hipStreamCreateWithPriority :
			//	hipStream_t * stream (struct ihipStream_t **);
			//	unsigned int flags (unsigned int);
			//	int priority (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t * stream = %p", args->hipStreamCreateWithPriority.stream);
			if (args->hipStreamCreateWithPriority.stream != NULL) {
				printf(" -> %p\n", args->hipStreamCreateWithPriority.stream__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->hipStreamCreateWithPriority.flags);
			printf("\tint priority = %d\n", args->hipStreamCreateWithPriority.priority);
			printf("\thipError_t retval = %d\n", args->hipStreamCreateWithPriority.retval);
			break;

		#endif
		#if HAVE_hipStreamGetCaptureInfo_spt
		case HIP_API_ID_hipStreamGetCaptureInfo_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	unsigned long long * pId (unsigned long long *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetCaptureInfo_spt.stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->hipStreamGetCaptureInfo_spt.pCaptureStatus);
			if (args->hipStreamGetCaptureInfo_spt.pCaptureStatus != NULL) {
				printf(" -> %d\n", args->hipStreamGetCaptureInfo_spt.pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * pId = %p", args->hipStreamGetCaptureInfo_spt.pId);
			if (args->hipStreamGetCaptureInfo_spt.pId != NULL) {
				printf(" -> %llu\n", args->hipStreamGetCaptureInfo_spt.pId__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetCaptureInfo_spt.retval);
			break;

		#endif
		#if HAVE_hipGraphAddHostNode
		case HIP_API_ID_hipGraphAddHostNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipHostNodeParams * pNodeParams ({
			//		hipHostFn_t fn (void (*)(void *));
			//		void * userData (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddHostNode.pGraphNode);
			if (args->hipGraphAddHostNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddHostNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddHostNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddHostNode.pDependencies);
			if (args->hipGraphAddHostNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddHostNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddHostNode.numDependencies);
			printf("\tconst hipHostNodeParams * pNodeParams = %p", args->hipGraphAddHostNode.pNodeParams);
			if (args->hipGraphAddHostNode.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipHostFn_t fn = %p\n", args->hipGraphAddHostNode.pNodeParams__ref.val.fn);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddHostNode.retval);
			break;

		#endif
		#if HAVE_hipLaunchCooperativeKernel
		case HIP_API_ID_hipLaunchCooperativeKernel :
			//	const void * f (const void *);
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDimX ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** kernelParams (void **);
			//	unsigned int sharedMemBytes (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * f = %p", args->hipLaunchCooperativeKernel.f);
			printf("\n");
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchCooperativeKernel.gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchCooperativeKernel.gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchCooperativeKernel.gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDimX = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchCooperativeKernel.blockDimX.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchCooperativeKernel.blockDimX.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchCooperativeKernel.blockDimX.z);
			printf("\t}\n");
			printf("\tvoid ** kernelParams = %p", args->hipLaunchCooperativeKernel.kernelParams);
			if (args->hipLaunchCooperativeKernel.kernelParams != NULL) {
				printf("-> %p", args->hipLaunchCooperativeKernel.kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tunsigned int sharedMemBytes = %u\n", args->hipLaunchCooperativeKernel.sharedMemBytes);
			printf("\thipStream_t stream = %p", args->hipLaunchCooperativeKernel.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchCooperativeKernel.retval);
			break;

		#endif
		#if HAVE_hipHostRegister
		case HIP_API_ID_hipHostRegister :
			//	void * hostPtr (void *);
			//	size_t sizeBytes (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * hostPtr = %p", args->hipHostRegister.hostPtr);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipHostRegister.sizeBytes);
			printf("\tunsigned int flags = %u\n", args->hipHostRegister.flags);
			printf("\thipError_t retval = %d\n", args->hipHostRegister.retval);
			break;

		#endif
		#if HAVE_hipGetErrorName
		case HIP_API_ID_hipGetErrorName :
			//	hipError_t hip_error (enum hipError_t);
			//	const char * retval (const char *);
			printf("\thipError_t hip_error = %d\n", args->hipGetErrorName.hip_error);
			printf("\tconst char * retval = %p", args->hipGetErrorName.retval);
			if (args->hipGetErrorName.retval != NULL) {
				printf(" -> %s\n", args->hipGetErrorName.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipMemcpyToSymbol_spt
		case HIP_API_ID_hipMemcpyToSymbol_spt :
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * symbol = %p", args->hipMemcpyToSymbol_spt.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyToSymbol_spt.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyToSymbol_spt.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyToSymbol_spt.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyToSymbol_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyToSymbol_spt.retval);
			break;

		#endif
		#if HAVE_hipGraphMemsetNodeGetParams
		case HIP_API_ID_hipGraphMemsetNodeGetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemsetParams * pNodeParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemsetNodeGetParams.node);
			printf("\n");
			printf("\thipMemsetParams * pNodeParams = %p", args->hipGraphMemsetNodeGetParams.pNodeParams);
			if (args->hipGraphMemsetNodeGetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->hipGraphMemsetNodeGetParams.pNodeParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->hipGraphMemsetNodeGetParams.pNodeParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->hipGraphMemsetNodeGetParams.pNodeParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->hipGraphMemsetNodeGetParams.pNodeParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->hipGraphMemsetNodeGetParams.pNodeParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphMemsetNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipStreamWriteValue32
		case HIP_API_ID_hipStreamWriteValue32 :
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint32_t value (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamWriteValue32.stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->hipStreamWriteValue32.ptr);
			printf("\n");
			printf("\tuint32_t value = %u\n", args->hipStreamWriteValue32.value);
			printf("\tunsigned int flags = %u\n", args->hipStreamWriteValue32.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamWriteValue32.retval);
			break;

		#endif
		#if HAVE_hipStreamSynchronize_spt
		case HIP_API_ID_hipStreamSynchronize_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamSynchronize_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipStreamSynchronize_spt.retval);
			break;

		#endif
		#if HAVE_hipDeviceGraphMemTrim
		case HIP_API_ID_hipDeviceGraphMemTrim :
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint device = %d\n", args->hipDeviceGraphMemTrim.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceGraphMemTrim.retval);
			break;

		#endif
		#if HAVE_hipStreamDestroy
		case HIP_API_ID_hipStreamDestroy :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamDestroy.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipStreamDestroy.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetArray
		case HIP_API_ID_hipTexRefSetArray :
			//	textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipArray_const_t array (const struct hipArray *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * tex = %p", args->hipTexRefSetArray.tex);
			if (args->hipTexRefSetArray.tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetArray.tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetArray.tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetArray.tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetArray.tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetArray.tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetArray.tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetArray.tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetArray.tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetArray.tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetArray.tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetArray.tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetArray.tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetArray.tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetArray.tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetArray.tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetArray.tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetArray.tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_const_t array = %p", args->hipTexRefSetArray.array);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipTexRefSetArray.flags);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetArray.retval);
			break;

		#endif
		#if HAVE_hipMemcpyParam2DAsync
		case HIP_API_ID_hipMemcpyParam2DAsync :
			//	const hip_Memcpy2D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst hip_Memcpy2D * pCopy = %p", args->hipMemcpyParam2DAsync.pCopy);
			if (args->hipMemcpyParam2DAsync.pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.srcY);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.srcPitch);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.dstY);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.dstPitch);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->hipMemcpyParam2DAsync.pCopy__ref.val.Height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->hipMemcpyParam2DAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyParam2DAsync.retval);
			break;

		#endif
		#if HAVE_hipMemPoolExportPointer
		case HIP_API_ID_hipMemPoolExportPointer :
			//	hipMemPoolPtrExportData * export_data ({
			//		unsigned char[64] reserved (unsigned char[64]);
			//	});
			//	void * dev_ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPoolPtrExportData * export_data = %p", args->hipMemPoolExportPointer.export_data);
			if (args->hipMemPoolExportPointer.export_data != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned char[64] reserved = %hhu\n", args->hipMemPoolExportPointer.export_data__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tvoid * dev_ptr = %p", args->hipMemPoolExportPointer.dev_ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemPoolExportPointer.retval);
			break;

		#endif
		#if HAVE_hipGraphEventRecordNodeSetEvent
		case HIP_API_ID_hipGraphEventRecordNodeSetEvent :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphEventRecordNodeSetEvent.node);
			printf("\n");
			printf("\thipEvent_t event = %p", args->hipGraphEventRecordNodeSetEvent.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphEventRecordNodeSetEvent.retval);
			break;

		#endif
		#if HAVE_hipCtxDestroy
		case HIP_API_ID_hipCtxDestroy :
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t ctx = %p", args->hipCtxDestroy.ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipCtxDestroy.retval);
			break;

		#endif
		#if HAVE_hipArrayDestroy
		case HIP_API_ID_hipArrayDestroy :
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t array = %p", args->hipArrayDestroy.array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipArrayDestroy.retval);
			break;

		#endif
		#if HAVE_hipMemGetAllocationGranularity
		case HIP_API_ID_hipMemGetAllocationGranularity :
			//	size_t * granularity (unsigned long*);
			//	const hipMemAllocationProp * prop ({
			//		hipMemAllocationType type (enum hipMemAllocationType);
			//		hipMemAllocationHandleType requestedHandleType (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32HandleMetaData (void *);
			//		struct (unnamed struct at header/hip/hip.h:1616:2) allocFlags ({
			//		});
			//	});
			//	hipMemAllocationGranularity_flags option (enum hipMemAllocationGranularity_flags);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * granularity = %p", args->hipMemGetAllocationGranularity.granularity);
			if (args->hipMemGetAllocationGranularity.granularity != NULL) {
				printf(" -> %lu\n", args->hipMemGetAllocationGranularity.granularity__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipMemAllocationProp * prop = %p", args->hipMemGetAllocationGranularity.prop);
			if (args->hipMemGetAllocationGranularity.prop != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType type = %d\n", args->hipMemGetAllocationGranularity.prop__ref.val.type);
				printf("\t\thipMemAllocationHandleType requestedHandleType = %d\n", args->hipMemGetAllocationGranularity.prop__ref.val.requestedHandleType);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->hipMemGetAllocationGranularity.prop__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->hipMemGetAllocationGranularity.prop__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tstruct (unnamed struct at header/hip/hip.h:1616:2) allocFlags = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipMemAllocationGranularity_flags option = %d\n", args->hipMemGetAllocationGranularity.option);
			printf("\thipError_t retval = %d\n", args->hipMemGetAllocationGranularity.retval);
			break;

		#endif
		#if HAVE_hipGraphClone
		case HIP_API_ID_hipGraphClone :
			//	hipGraph_t * pGraphClone (struct ihipGraph **);
			//	hipGraph_t originalGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t * pGraphClone = %p", args->hipGraphClone.pGraphClone);
			if (args->hipGraphClone.pGraphClone != NULL) {
				printf(" -> %p\n", args->hipGraphClone.pGraphClone__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t originalGraph = %p", args->hipGraphClone.originalGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphClone.retval);
			break;

		#endif
		#if HAVE_hipMemset2DAsync_spt
		case HIP_API_ID_hipMemset2DAsync_spt :
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemset2DAsync_spt.dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->hipMemset2DAsync_spt.pitch);
			printf("\tint value = %d\n", args->hipMemset2DAsync_spt.value);
			printf("\tsize_t width = %lu\n", args->hipMemset2DAsync_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemset2DAsync_spt.height);
			printf("\thipStream_t stream = %p", args->hipMemset2DAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemset2DAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipBindTexture2D
		case HIP_API_ID_hipBindTexture2D :
			//	size_t * offset (unsigned long*);
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const void * devPtr (const void *);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	size_t pitch (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * offset = %p", args->hipBindTexture2D.offset);
			if (args->hipBindTexture2D.offset != NULL) {
				printf(" -> %lu\n", args->hipBindTexture2D.offset__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * tex = %p", args->hipBindTexture2D.tex);
			if (args->hipBindTexture2D.tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipBindTexture2D.tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipBindTexture2D.tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipBindTexture2D.tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipBindTexture2D.tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipBindTexture2D.tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipBindTexture2D.tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipBindTexture2D.tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipBindTexture2D.tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTexture2D.tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipBindTexture2D.tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipBindTexture2D.tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipBindTexture2D.tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipBindTexture2D.tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipBindTexture2D.tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipBindTexture2D.tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipBindTexture2D.tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipBindTexture2D.tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * devPtr = %p", args->hipBindTexture2D.devPtr);
			printf("\n");
			printf("\tconst hipChannelFormatDesc * desc = %p", args->hipBindTexture2D.desc);
			if (args->hipBindTexture2D.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipBindTexture2D.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipBindTexture2D.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipBindTexture2D.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipBindTexture2D.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTexture2D.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t width = %lu\n", args->hipBindTexture2D.width);
			printf("\tsize_t height = %lu\n", args->hipBindTexture2D.height);
			printf("\tsize_t pitch = %lu\n", args->hipBindTexture2D.pitch);
			printf("\thipError_t retval = %d\n", args->hipBindTexture2D.retval);
			break;

		#endif
		#if HAVE_hipArrayGetInfo
		case HIP_API_ID_hipArrayGetInfo :
			//	hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipExtent * extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	unsigned int * flags (unsigned int *);
			//	hipArray_t array (struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipChannelFormatDesc * desc = %p", args->hipArrayGetInfo.desc);
			if (args->hipArrayGetInfo.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipArrayGetInfo.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipArrayGetInfo.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipArrayGetInfo.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipArrayGetInfo.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipArrayGetInfo.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipExtent * extent = %p", args->hipArrayGetInfo.extent);
			if (args->hipArrayGetInfo.extent != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t width = %lu\n", args->hipArrayGetInfo.extent__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->hipArrayGetInfo.extent__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->hipArrayGetInfo.extent__ref.val.depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int * flags = %p", args->hipArrayGetInfo.flags);
			if (args->hipArrayGetInfo.flags != NULL) {
				printf(" -> %u\n", args->hipArrayGetInfo.flags__ref.val);
			} else { printf("\n"); };
			printf("\thipArray_t array = %p", args->hipArrayGetInfo.array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipArrayGetInfo.retval);
			break;

		#endif
		#if HAVE_hipGraphExternalSemaphoresSignalNodeGetParams
		case HIP_API_ID_hipGraphExternalSemaphoresSignalNodeGetParams :
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipExternalSemaphoreSignalNodeParams * params_out ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExternalSemaphoresSignalNodeGetParams.hNode);
			printf("\n");
			printf("\thipExternalSemaphoreSignalNodeParams * params_out = %p", args->hipGraphExternalSemaphoresSignalNodeGetParams.params_out);
			if (args->hipGraphExternalSemaphoresSignalNodeGetParams.params_out != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphExternalSemaphoresSignalNodeGetParams.params_out__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExternalSemaphoresSignalNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetStreamPriorityRange
		case HIP_API_ID_hipDeviceGetStreamPriorityRange :
			//	int * leastPriority (int *);
			//	int * greatestPriority (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * leastPriority = %p", args->hipDeviceGetStreamPriorityRange.leastPriority);
			if (args->hipDeviceGetStreamPriorityRange.leastPriority != NULL) {
				printf(" -> %d\n", args->hipDeviceGetStreamPriorityRange.leastPriority__ref.val);
			} else { printf("\n"); };
			printf("\tint * greatestPriority = %p", args->hipDeviceGetStreamPriorityRange.greatestPriority);
			if (args->hipDeviceGetStreamPriorityRange.greatestPriority != NULL) {
				printf(" -> %d\n", args->hipDeviceGetStreamPriorityRange.greatestPriority__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDeviceGetStreamPriorityRange.retval);
			break;

		#endif
		#if HAVE_hipGraphExecChildGraphNodeSetParams
		case HIP_API_ID_hipGraphExecChildGraphNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraph_t childGraph (struct ihipGraph *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecChildGraphNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecChildGraphNodeSetParams.node);
			printf("\n");
			printf("\thipGraph_t childGraph = %p", args->hipGraphExecChildGraphNodeSetParams.childGraph);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphExecChildGraphNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipMemset2D_spt
		case HIP_API_ID_hipMemset2D_spt :
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemset2D_spt.dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->hipMemset2D_spt.pitch);
			printf("\tint value = %d\n", args->hipMemset2D_spt.value);
			printf("\tsize_t width = %lu\n", args->hipMemset2D_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemset2D_spt.height);
			printf("\thipError_t retval = %d\n", args->hipMemset2D_spt.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetDefaultMemPool
		case HIP_API_ID_hipDeviceGetDefaultMemPool :
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t * mem_pool = %p", args->hipDeviceGetDefaultMemPool.mem_pool);
			if (args->hipDeviceGetDefaultMemPool.mem_pool != NULL) {
				printf(" -> %p\n", args->hipDeviceGetDefaultMemPool.mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tint device = %d\n", args->hipDeviceGetDefaultMemPool.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetDefaultMemPool.retval);
			break;

		#endif
		#if HAVE_hipCtxCreate
		case HIP_API_ID_hipCtxCreate :
			//	hipCtx_t * ctx (struct ihipCtx_t **);
			//	unsigned int flags (unsigned int);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t * ctx = %p", args->hipCtxCreate.ctx);
			if (args->hipCtxCreate.ctx != NULL) {
				printf(" -> %p\n", args->hipCtxCreate.ctx__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->hipCtxCreate.flags);
			printf("\thipDevice_t device = %d\n", args->hipCtxCreate.device);
			printf("\thipError_t retval = %d\n", args->hipCtxCreate.retval);
			break;

		#endif
		#if HAVE_hipStreamIsCapturing
		case HIP_API_ID_hipStreamIsCapturing :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamIsCapturing.stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->hipStreamIsCapturing.pCaptureStatus);
			if (args->hipStreamIsCapturing.pCaptureStatus != NULL) {
				printf(" -> %d\n", args->hipStreamIsCapturing.pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamIsCapturing.retval);
			break;

		#endif
		#if HAVE_hipStreamUpdateCaptureDependencies
		case HIP_API_ID_hipStreamUpdateCaptureDependencies :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipGraphNode_t * dependencies (struct hipGraphNode **);
			//	size_t numDependencies (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamUpdateCaptureDependencies.stream);
			printf("\n");
			printf("\thipGraphNode_t * dependencies = %p", args->hipStreamUpdateCaptureDependencies.dependencies);
			if (args->hipStreamUpdateCaptureDependencies.dependencies != NULL) {
				printf(" -> %p\n", args->hipStreamUpdateCaptureDependencies.dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipStreamUpdateCaptureDependencies.numDependencies);
			printf("\tunsigned int flags = %u\n", args->hipStreamUpdateCaptureDependencies.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamUpdateCaptureDependencies.retval);
			break;

		#endif
		#if HAVE_hipDeviceSynchronize
		case HIP_API_ID_hipDeviceSynchronize :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipDeviceSynchronize.retval);
			break;

		#endif
		#if HAVE_hipMemcpyFromSymbolAsync
		case HIP_API_ID_hipMemcpyFromSymbolAsync :
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyFromSymbolAsync.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipMemcpyFromSymbolAsync.symbol);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyFromSymbolAsync.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyFromSymbolAsync.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyFromSymbolAsync.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyFromSymbolAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyFromSymbolAsync.retval);
			break;

		#endif
		#if HAVE_hipGraphDestroyNode
		case HIP_API_ID_hipGraphDestroyNode :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphDestroyNode.node);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphDestroyNode.retval);
			break;

		#endif
		#if HAVE_hipUserObjectRetain
		case HIP_API_ID_hipUserObjectRetain :
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipUserObject_t object = %p", args->hipUserObjectRetain.object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->hipUserObjectRetain.count);
			printf("\thipError_t retval = %d\n", args->hipUserObjectRetain.retval);
			break;

		#endif
		#if HAVE_hipGraphExecEventWaitNodeSetEvent
		case HIP_API_ID_hipGraphExecEventWaitNodeSetEvent :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecEventWaitNodeSetEvent.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExecEventWaitNodeSetEvent.hNode);
			printf("\n");
			printf("\thipEvent_t event = %p", args->hipGraphExecEventWaitNodeSetEvent.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphExecEventWaitNodeSetEvent.retval);
			break;

		#endif
		#if HAVE_hipMemAddressReserve
		case HIP_API_ID_hipMemAddressReserve :
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	size_t alignment (unsigned long);
			//	void * addr (void *);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipMemAddressReserve.ptr);
			if (args->hipMemAddressReserve.ptr != NULL) {
				printf("-> %p", args->hipMemAddressReserve.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMemAddressReserve.size);
			printf("\tsize_t alignment = %lu\n", args->hipMemAddressReserve.alignment);
			printf("\tvoid * addr = %p", args->hipMemAddressReserve.addr);
			printf("\n");
			printf("\tunsigned long long flags = %llu\n", args->hipMemAddressReserve.flags);
			printf("\thipError_t retval = %d\n", args->hipMemAddressReserve.retval);
			break;

		#endif
		#if HAVE_hipGraphAddMemsetNode
		case HIP_API_ID_hipGraphAddMemsetNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipMemsetParams * pMemsetParams ({
			//		void * dst (void *);
			//		unsigned int elementSize (unsigned int);
			//		size_t height (unsigned long);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		size_t width (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemsetNode.pGraphNode);
			if (args->hipGraphAddMemsetNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemsetNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemsetNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemsetNode.pDependencies);
			if (args->hipGraphAddMemsetNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemsetNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemsetNode.numDependencies);
			printf("\tconst hipMemsetParams * pMemsetParams = %p", args->hipGraphAddMemsetNode.pMemsetParams);
			if (args->hipGraphAddMemsetNode.pMemsetParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int elementSize = %u\n", args->hipGraphAddMemsetNode.pMemsetParams__ref.val.elementSize);
				printf("\t\tsize_t height = %lu\n", args->hipGraphAddMemsetNode.pMemsetParams__ref.val.height);
				printf("\t\tsize_t pitch = %lu\n", args->hipGraphAddMemsetNode.pMemsetParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->hipGraphAddMemsetNode.pMemsetParams__ref.val.value);
				printf("\t\tsize_t width = %lu\n", args->hipGraphAddMemsetNode.pMemsetParams__ref.val.width);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemsetNode.retval);
			break;

		#endif
		#if HAVE_hipGraphicsResourceGetMappedPointer
		case HIP_API_ID_hipGraphicsResourceGetMappedPointer :
			//	void ** devPtr (void **);
			//	size_t * size (unsigned long*);
			//	hipGraphicsResource_t resource (struct _hipGraphicsResource*);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** devPtr = %p", args->hipGraphicsResourceGetMappedPointer.devPtr);
			if (args->hipGraphicsResourceGetMappedPointer.devPtr != NULL) {
				printf("-> %p", args->hipGraphicsResourceGetMappedPointer.devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * size = %p", args->hipGraphicsResourceGetMappedPointer.size);
			if (args->hipGraphicsResourceGetMappedPointer.size != NULL) {
				printf(" -> %lu\n", args->hipGraphicsResourceGetMappedPointer.size__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphicsResource_t resource = %p", args->hipGraphicsResourceGetMappedPointer.resource);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphicsResourceGetMappedPointer.retval);
			break;

		#endif
		#if HAVE_hipStreamBeginCapture_spt
		case HIP_API_ID_hipStreamBeginCapture_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureMode mode (enum hipStreamCaptureMode);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamBeginCapture_spt.stream);
			printf("\n");
			printf("\thipStreamCaptureMode mode = %d\n", args->hipStreamBeginCapture_spt.mode);
			printf("\thipError_t retval = %d\n", args->hipStreamBeginCapture_spt.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetUuid
		case HIP_API_ID_hipDeviceGetUuid :
			//	hipUUID * uuid ({
			//		char[16] bytes (char[16]);
			//	});
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipUUID * uuid = %p", args->hipDeviceGetUuid.uuid);
			if (args->hipDeviceGetUuid.uuid != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[16] bytes = %c\n", args->hipDeviceGetUuid.uuid__ref.val.bytes[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipDevice_t device = %d\n", args->hipDeviceGetUuid.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetUuid.retval);
			break;

		#endif
		#if HAVE_hipModuleLaunchKernel
		case HIP_API_ID_hipModuleLaunchKernel :
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	unsigned int gridDimX (unsigned int);
			//	unsigned int gridDimY (unsigned int);
			//	unsigned int gridDimZ (unsigned int);
			//	unsigned int blockDimX (unsigned int);
			//	unsigned int blockDimY (unsigned int);
			//	unsigned int blockDimZ (unsigned int);
			//	unsigned int sharedMemBytes (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	void ** kernelParams (void **);
			//	void ** extra (void **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFunction_t f = %p", args->hipModuleLaunchKernel.f);
			printf("\n");
			printf("\tunsigned int gridDimX = %u\n", args->hipModuleLaunchKernel.gridDimX);
			printf("\tunsigned int gridDimY = %u\n", args->hipModuleLaunchKernel.gridDimY);
			printf("\tunsigned int gridDimZ = %u\n", args->hipModuleLaunchKernel.gridDimZ);
			printf("\tunsigned int blockDimX = %u\n", args->hipModuleLaunchKernel.blockDimX);
			printf("\tunsigned int blockDimY = %u\n", args->hipModuleLaunchKernel.blockDimY);
			printf("\tunsigned int blockDimZ = %u\n", args->hipModuleLaunchKernel.blockDimZ);
			printf("\tunsigned int sharedMemBytes = %u\n", args->hipModuleLaunchKernel.sharedMemBytes);
			printf("\thipStream_t stream = %p", args->hipModuleLaunchKernel.stream);
			printf("\n");
			printf("\tvoid ** kernelParams = %p", args->hipModuleLaunchKernel.kernelParams);
			if (args->hipModuleLaunchKernel.kernelParams != NULL) {
				printf("-> %p", args->hipModuleLaunchKernel.kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tvoid ** extra = %p", args->hipModuleLaunchKernel.extra);
			if (args->hipModuleLaunchKernel.extra != NULL) {
				printf("-> %p", args->hipModuleLaunchKernel.extra__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleLaunchKernel.retval);
			break;

		#endif
		#if HAVE_hipGraphAddEmptyNode
		case HIP_API_ID_hipGraphAddEmptyNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddEmptyNode.pGraphNode);
			if (args->hipGraphAddEmptyNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddEmptyNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddEmptyNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddEmptyNode.pDependencies);
			if (args->hipGraphAddEmptyNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddEmptyNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddEmptyNode.numDependencies);
			printf("\thipError_t retval = %d\n", args->hipGraphAddEmptyNode.retval);
			break;

		#endif
		#if HAVE_hipMemRangeGetAttribute
		case HIP_API_ID_hipMemRangeGetAttribute :
			//	void * data (void *);
			//	size_t data_size (unsigned long);
			//	hipMemRangeAttribute attribute (enum hipMemRangeAttribute);
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * data = %p", args->hipMemRangeGetAttribute.data);
			printf("\n");
			printf("\tsize_t data_size = %lu\n", args->hipMemRangeGetAttribute.data_size);
			printf("\thipMemRangeAttribute attribute = %d\n", args->hipMemRangeGetAttribute.attribute);
			printf("\tconst void * dev_ptr = %p", args->hipMemRangeGetAttribute.dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipMemRangeGetAttribute.count);
			printf("\thipError_t retval = %d\n", args->hipMemRangeGetAttribute.retval);
			break;

		#endif
		#if HAVE_hipGraphInstantiateWithFlags
		case HIP_API_ID_hipGraphInstantiateWithFlags :
			//	hipGraphExec_t * pGraphExec (struct hipGraphExec **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t * pGraphExec = %p", args->hipGraphInstantiateWithFlags.pGraphExec);
			if (args->hipGraphInstantiateWithFlags.pGraphExec != NULL) {
				printf(" -> %p\n", args->hipGraphInstantiateWithFlags.pGraphExec__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphInstantiateWithFlags.graph);
			printf("\n");
			printf("\tunsigned long long flags = %llu\n", args->hipGraphInstantiateWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipGraphInstantiateWithFlags.retval);
			break;

		#endif
		#if HAVE_hipCtxPushCurrent
		case HIP_API_ID_hipCtxPushCurrent :
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t ctx = %p", args->hipCtxPushCurrent.ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipCtxPushCurrent.retval);
			break;

		#endif
		#if HAVE_hipCtxGetApiVersion
		case HIP_API_ID_hipCtxGetApiVersion :
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	int * apiVersion (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t ctx = %p", args->hipCtxGetApiVersion.ctx);
			printf("\n");
			printf("\tint * apiVersion = %p", args->hipCtxGetApiVersion.apiVersion);
			if (args->hipCtxGetApiVersion.apiVersion != NULL) {
				printf(" -> %d\n", args->hipCtxGetApiVersion.apiVersion__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxGetApiVersion.retval);
			break;

		#endif
		#if HAVE_hipBindTexture
		case HIP_API_ID_hipBindTexture :
			//	size_t * offset (unsigned long*);
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const void * devPtr (const void *);
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * offset = %p", args->hipBindTexture.offset);
			if (args->hipBindTexture.offset != NULL) {
				printf(" -> %lu\n", args->hipBindTexture.offset__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * tex = %p", args->hipBindTexture.tex);
			if (args->hipBindTexture.tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipBindTexture.tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipBindTexture.tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipBindTexture.tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipBindTexture.tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipBindTexture.tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipBindTexture.tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipBindTexture.tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipBindTexture.tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTexture.tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipBindTexture.tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipBindTexture.tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipBindTexture.tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipBindTexture.tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipBindTexture.tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipBindTexture.tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipBindTexture.tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipBindTexture.tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst void * devPtr = %p", args->hipBindTexture.devPtr);
			printf("\n");
			printf("\tconst hipChannelFormatDesc * desc = %p", args->hipBindTexture.desc);
			if (args->hipBindTexture.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipBindTexture.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipBindTexture.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipBindTexture.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipBindTexture.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTexture.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipBindTexture.size);
			printf("\thipError_t retval = %d\n", args->hipBindTexture.retval);
			break;

		#endif
		#if HAVE_hipStreamBeginCapture
		case HIP_API_ID_hipStreamBeginCapture :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureMode mode (enum hipStreamCaptureMode);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamBeginCapture.stream);
			printf("\n");
			printf("\thipStreamCaptureMode mode = %d\n", args->hipStreamBeginCapture.mode);
			printf("\thipError_t retval = %d\n", args->hipStreamBeginCapture.retval);
			break;

		#endif
		#if HAVE_hipProfilerStart
		case HIP_API_ID_hipProfilerStart :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipProfilerStart.retval);
			break;

		#endif
		#if HAVE_hipMemcpyHtoDAsync
		case HIP_API_ID_hipMemcpyHtoDAsync :
			//	hipDeviceptr_t dst (void *);
			//	void * src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dst = %p", args->hipMemcpyHtoDAsync.dst);
			printf("\n");
			printf("\tvoid * src = %p", args->hipMemcpyHtoDAsync.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyHtoDAsync.sizeBytes);
			printf("\thipStream_t stream = %p", args->hipMemcpyHtoDAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyHtoDAsync.retval);
			break;

		#endif
		#if HAVE_hipGetDeviceFlags
		case HIP_API_ID_hipGetDeviceFlags :
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int * flags = %p", args->hipGetDeviceFlags.flags);
			if (args->hipGetDeviceFlags.flags != NULL) {
				printf(" -> %u\n", args->hipGetDeviceFlags.flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGetDeviceFlags.retval);
			break;

		#endif
		#if HAVE_hipMemRangeGetAttributes
		case HIP_API_ID_hipMemRangeGetAttributes :
			//	void ** data (void **);
			//	size_t * data_sizes (unsigned long*);
			//	hipMemRangeAttribute * attributes (enum hipMemRangeAttribute*);
			//	size_t num_attributes (unsigned long);
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** data = %p", args->hipMemRangeGetAttributes.data);
			if (args->hipMemRangeGetAttributes.data != NULL) {
				printf("-> %p", args->hipMemRangeGetAttributes.data__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * data_sizes = %p", args->hipMemRangeGetAttributes.data_sizes);
			if (args->hipMemRangeGetAttributes.data_sizes != NULL) {
				printf(" -> %lu\n", args->hipMemRangeGetAttributes.data_sizes__ref.val);
			} else { printf("\n"); };
			printf("\thipMemRangeAttribute * attributes = %p", args->hipMemRangeGetAttributes.attributes);
			if (args->hipMemRangeGetAttributes.attributes != NULL) {
				printf(" -> %d\n", args->hipMemRangeGetAttributes.attributes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t num_attributes = %lu\n", args->hipMemRangeGetAttributes.num_attributes);
			printf("\tconst void * dev_ptr = %p", args->hipMemRangeGetAttributes.dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipMemRangeGetAttributes.count);
			printf("\thipError_t retval = %d\n", args->hipMemRangeGetAttributes.retval);
			break;

		#endif
		#if HAVE_hipDestroyExternalSemaphore
		case HIP_API_ID_hipDestroyExternalSemaphore :
			//	hipExternalSemaphore_t extSem (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipExternalSemaphore_t extSem = %p", args->hipDestroyExternalSemaphore.extSem);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDestroyExternalSemaphore.retval);
			break;

		#endif
		#if HAVE_hipIpcOpenEventHandle
		case HIP_API_ID_hipIpcOpenEventHandle :
			//	hipEvent_t * event (struct ihipEvent_t **);
			//	hipIpcEventHandle_t handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t * event = %p", args->hipIpcOpenEventHandle.event);
			if (args->hipIpcOpenEventHandle.event != NULL) {
				printf(" -> %p\n", args->hipIpcOpenEventHandle.event__ref.val);
			} else { printf("\n"); };
			printf("\thipIpcEventHandle_t handle = {\n");
			printf("\t\tchar[64] reserved = %c\n", args->hipIpcOpenEventHandle.handle.reserved[0]);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->hipIpcOpenEventHandle.retval);
			break;

		#endif
		#if HAVE_hipGraphUpload
		case HIP_API_ID_hipGraphUpload :
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t graphExec = %p", args->hipGraphUpload.graphExec);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipGraphUpload.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphUpload.retval);
			break;

		#endif
		#if HAVE_hipMallocAsync
		case HIP_API_ID_hipMallocAsync :
			//	void ** dev_ptr (void **);
			//	size_t size (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** dev_ptr = %p", args->hipMallocAsync.dev_ptr);
			if (args->hipMallocAsync.dev_ptr != NULL) {
				printf("-> %p", args->hipMallocAsync.dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMallocAsync.size);
			printf("\thipStream_t stream = %p", args->hipMallocAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMallocAsync.retval);
			break;

		#endif
		#if HAVE_hipOccupancyMaxPotentialBlockSize
		case HIP_API_ID_hipOccupancyMaxPotentialBlockSize :
			//	int * gridSize (int *);
			//	int * blockSize (int *);
			//	const void * f (const void *);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	int blockSizeLimit (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * gridSize = %p", args->hipOccupancyMaxPotentialBlockSize.gridSize);
			if (args->hipOccupancyMaxPotentialBlockSize.gridSize != NULL) {
				printf(" -> %d\n", args->hipOccupancyMaxPotentialBlockSize.gridSize__ref.val);
			} else { printf("\n"); };
			printf("\tint * blockSize = %p", args->hipOccupancyMaxPotentialBlockSize.blockSize);
			if (args->hipOccupancyMaxPotentialBlockSize.blockSize != NULL) {
				printf(" -> %d\n", args->hipOccupancyMaxPotentialBlockSize.blockSize__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * f = %p", args->hipOccupancyMaxPotentialBlockSize.f);
			printf("\n");
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipOccupancyMaxPotentialBlockSize.dynSharedMemPerBlk);
			printf("\tint blockSizeLimit = %d\n", args->hipOccupancyMaxPotentialBlockSize.blockSizeLimit);
			printf("\thipError_t retval = %d\n", args->hipOccupancyMaxPotentialBlockSize.retval);
			break;

		#endif
		#if HAVE_hipDestroyExternalMemory
		case HIP_API_ID_hipDestroyExternalMemory :
			//	hipExternalMemory_t extMem (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipExternalMemory_t extMem = %p", args->hipDestroyExternalMemory.extMem);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDestroyExternalMemory.retval);
			break;

		#endif
		#if HAVE_amd_dbgapi_get_build_name
		case HIP_API_ID_amd_dbgapi_get_build_name :
			//	const char * retval (const char *);
			printf("\tconst char * retval = %p", args->amd_dbgapi_get_build_name.retval);
			if (args->amd_dbgapi_get_build_name.retval != NULL) {
				printf(" -> %s\n", args->amd_dbgapi_get_build_name.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipGraphAddMemcpyNodeToSymbol
		case HIP_API_ID_hipGraphAddMemcpyNodeToSymbol :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemcpyNodeToSymbol.pGraphNode);
			if (args->hipGraphAddMemcpyNodeToSymbol.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNodeToSymbol.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemcpyNodeToSymbol.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemcpyNodeToSymbol.pDependencies);
			if (args->hipGraphAddMemcpyNodeToSymbol.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNodeToSymbol.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemcpyNodeToSymbol.numDependencies);
			printf("\tconst void * symbol = %p", args->hipGraphAddMemcpyNodeToSymbol.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipGraphAddMemcpyNodeToSymbol.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphAddMemcpyNodeToSymbol.count);
			printf("\tsize_t offset = %lu\n", args->hipGraphAddMemcpyNodeToSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphAddMemcpyNodeToSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemcpyNodeToSymbol.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetPCIBusId
		case HIP_API_ID_hipDeviceGetPCIBusId :
			//	char * pciBusId (char *);
			//	int len (int);
			//	int device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tchar * pciBusId = %p", args->hipDeviceGetPCIBusId.pciBusId);
			if (args->hipDeviceGetPCIBusId.pciBusId != NULL) {
				printf(" -> %s\n", args->hipDeviceGetPCIBusId.pciBusId__ref.val);
			} else { printf("\n"); };
			printf("\tint len = %d\n", args->hipDeviceGetPCIBusId.len);
			printf("\tint device = %d\n", args->hipDeviceGetPCIBusId.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetPCIBusId.retval);
			break;

		#endif
		#if HAVE_hipGetChannelDesc
		case HIP_API_ID_hipGetChannelDesc :
			//	hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipArray_const_t array (const struct hipArray *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipChannelFormatDesc * desc = %p", args->hipGetChannelDesc.desc);
			if (args->hipGetChannelDesc.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipGetChannelDesc.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipGetChannelDesc.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipGetChannelDesc.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipGetChannelDesc.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipGetChannelDesc.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_const_t array = %p", args->hipGetChannelDesc.array);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetChannelDesc.retval);
			break;

		#endif
		#if HAVE_hipDevicePrimaryCtxReset
		case HIP_API_ID_hipDevicePrimaryCtxReset :
			//	hipDevice_t dev (int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDevice_t dev = %d\n", args->hipDevicePrimaryCtxReset.dev);
			printf("\thipError_t retval = %d\n", args->hipDevicePrimaryCtxReset.retval);
			break;

		#endif
		#if HAVE_hipImportExternalMemory
		case HIP_API_ID_hipImportExternalMemory :
			//	hipExternalMemory_t * extMem_out (void **);
			//	const hipExternalMemoryHandleDesc * memHandleDesc ({
			//		hipExternalMemoryHandleType type (enum hipExternalMemoryHandleType_enum);
			//		union (unnamed union at header/hip/hip.h:1445:2) handle ({
			//		});
			//		unsigned long long size (unsigned long long);
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipExternalMemory_t * extMem_out = %p", args->hipImportExternalMemory.extMem_out);
			if (args->hipImportExternalMemory.extMem_out != NULL) {
				printf("-> %p", args->hipImportExternalMemory.extMem_out__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalMemoryHandleDesc * memHandleDesc = %p", args->hipImportExternalMemory.memHandleDesc);
			if (args->hipImportExternalMemory.memHandleDesc != NULL) {
				printf(" -> {\n");
				printf("\t\thipExternalMemoryHandleType type = %d\n", args->hipImportExternalMemory.memHandleDesc__ref.val.type);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1445:2) handle = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned long long size = %llu\n", args->hipImportExternalMemory.memHandleDesc__ref.val.size);
				printf("\t\tunsigned int flags = %u\n", args->hipImportExternalMemory.memHandleDesc__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipImportExternalMemory.memHandleDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipImportExternalMemory.retval);
			break;

		#endif
		#if HAVE_hipFuncSetSharedMemConfig
		case HIP_API_ID_hipFuncSetSharedMemConfig :
			//	const void * func (const void *);
			//	hipSharedMemConfig config (enum hipSharedMemConfig);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * func = %p", args->hipFuncSetSharedMemConfig.func);
			printf("\n");
			printf("\thipSharedMemConfig config = %d\n", args->hipFuncSetSharedMemConfig.config);
			printf("\thipError_t retval = %d\n", args->hipFuncSetSharedMemConfig.retval);
			break;

		#endif
		#if HAVE_hipStreamWaitEvent
		case HIP_API_ID_hipStreamWaitEvent :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamWaitEvent.stream);
			printf("\n");
			printf("\thipEvent_t event = %p", args->hipStreamWaitEvent.event);
			printf("\n");
			printf("\tunsigned int flags = %u\n", args->hipStreamWaitEvent.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamWaitEvent.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetMipmapLevelBias
		case HIP_API_ID_hipTexRefSetMipmapLevelBias :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	float bias (float);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetMipmapLevelBias.texRef);
			if (args->hipTexRefSetMipmapLevelBias.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetMipmapLevelBias.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tfloat bias = %f\n", args->hipTexRefSetMipmapLevelBias.bias);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetMipmapLevelBias.retval);
			break;

		#endif
		#if HAVE_hipMemPoolImportFromShareableHandle
		case HIP_API_ID_hipMemPoolImportFromShareableHandle :
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	void * shared_handle (void *);
			//	hipMemAllocationHandleType handle_type (enum hipMemAllocationHandleType);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t * mem_pool = %p", args->hipMemPoolImportFromShareableHandle.mem_pool);
			if (args->hipMemPoolImportFromShareableHandle.mem_pool != NULL) {
				printf(" -> %p\n", args->hipMemPoolImportFromShareableHandle.mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * shared_handle = %p", args->hipMemPoolImportFromShareableHandle.shared_handle);
			printf("\n");
			printf("\thipMemAllocationHandleType handle_type = %d\n", args->hipMemPoolImportFromShareableHandle.handle_type);
			printf("\tunsigned int flags = %u\n", args->hipMemPoolImportFromShareableHandle.flags);
			printf("\thipError_t retval = %d\n", args->hipMemPoolImportFromShareableHandle.retval);
			break;

		#endif
		#if HAVE_hipMemPoolExportToShareableHandle
		case HIP_API_ID_hipMemPoolExportToShareableHandle :
			//	void * shared_handle (void *);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemAllocationHandleType handle_type (enum hipMemAllocationHandleType);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * shared_handle = %p", args->hipMemPoolExportToShareableHandle.shared_handle);
			printf("\n");
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolExportToShareableHandle.mem_pool);
			printf("\n");
			printf("\thipMemAllocationHandleType handle_type = %d\n", args->hipMemPoolExportToShareableHandle.handle_type);
			printf("\tunsigned int flags = %u\n", args->hipMemPoolExportToShareableHandle.flags);
			printf("\thipError_t retval = %d\n", args->hipMemPoolExportToShareableHandle.retval);
			break;

		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParamsToSymbol
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParamsToSymbol :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecMemcpyNodeSetParamsToSymbol.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecMemcpyNodeSetParamsToSymbol.node);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipGraphExecMemcpyNodeSetParamsToSymbol.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipGraphExecMemcpyNodeSetParamsToSymbol.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphExecMemcpyNodeSetParamsToSymbol.count);
			printf("\tsize_t offset = %lu\n", args->hipGraphExecMemcpyNodeSetParamsToSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphExecMemcpyNodeSetParamsToSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphExecMemcpyNodeSetParamsToSymbol.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetMipmapFilterMode
		case HIP_API_ID_hipTexRefGetMipmapFilterMode :
			//	enum hipTextureFilterMode * pfm (enum hipTextureFilterMode *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tenum hipTextureFilterMode * pfm = %p", args->hipTexRefGetMipmapFilterMode.pfm);
			if (args->hipTexRefGetMipmapFilterMode.pfm != NULL) {
				printf(" -> %d\n", args->hipTexRefGetMipmapFilterMode.pfm__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetMipmapFilterMode.texRef);
			if (args->hipTexRefGetMipmapFilterMode.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetMipmapFilterMode.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetMipmapFilterMode.retval);
			break;

		#endif
		#if HAVE_hipGetProcAddress
		case HIP_API_ID_hipGetProcAddress :
			//	const char * symbol (const char *);
			//	void ** pfn (void **);
			//	int hipVersion (int);
			//	uint64_t flags (unsigned long);
			//	hipDriverProcAddressQueryResult * symbolStatus (enum hipDriverProcAddressQueryResult*);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst char * symbol = %p", args->hipGetProcAddress.symbol);
			if (args->hipGetProcAddress.symbol != NULL) {
				printf(" -> %s\n", args->hipGetProcAddress.symbol__ref.val);
			} else { printf("\n"); };
			printf("\tvoid ** pfn = %p", args->hipGetProcAddress.pfn);
			if (args->hipGetProcAddress.pfn != NULL) {
				printf("-> %p", args->hipGetProcAddress.pfn__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tint hipVersion = %d\n", args->hipGetProcAddress.hipVersion);
			printf("\tuint64_t flags = %lu\n", args->hipGetProcAddress.flags);
			printf("\thipDriverProcAddressQueryResult * symbolStatus = %p", args->hipGetProcAddress.symbolStatus);
			if (args->hipGetProcAddress.symbolStatus != NULL) {
				printf(" -> %d\n", args->hipGetProcAddress.symbolStatus__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGetProcAddress.retval);
			break;

		#endif
		#if HAVE_hipCreateTextureObject
		case HIP_API_ID_hipCreateTextureObject :
			//	hipTextureObject_t * pTexObject (struct __hip_texture **);
			//	const hipResourceDesc * pResDesc ({
			//		enum hipResourceType resType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:612:2) res ({
			//		});
			//	});
			//	const hipTextureDesc * pTexDesc ({
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		int sRGB (int);
			//		float[4] borderColor (float[4]);
			//		int normalizedCoords (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//	});
			//	const struct hipResourceViewDesc * pResViewDesc ({
			//		enum hipResourceViewFormat format (enum hipResourceViewFormat);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipTextureObject_t * pTexObject = %p", args->hipCreateTextureObject.pTexObject);
			if (args->hipCreateTextureObject.pTexObject != NULL) {
				printf(" -> %p\n", args->hipCreateTextureObject.pTexObject__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipResourceDesc * pResDesc = %p", args->hipCreateTextureObject.pResDesc);
			if (args->hipCreateTextureObject.pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceType resType = %d\n", args->hipCreateTextureObject.pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:612:2) res = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst hipTextureDesc * pTexDesc = %p", args->hipCreateTextureObject.pTexDesc);
			if (args->hipCreateTextureObject.pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipCreateTextureObject.pTexDesc__ref.val.addressMode[0]);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipCreateTextureObject.pTexDesc__ref.val.filterMode);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipCreateTextureObject.pTexDesc__ref.val.readMode);
				printf("\t\tint sRGB = %d\n", args->hipCreateTextureObject.pTexDesc__ref.val.sRGB);
				printf("\t\tfloat[4] borderColor = %f\n", args->hipCreateTextureObject.pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint normalizedCoords = %d\n", args->hipCreateTextureObject.pTexDesc__ref.val.normalizedCoords);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipCreateTextureObject.pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipCreateTextureObject.pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipCreateTextureObject.pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipCreateTextureObject.pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipCreateTextureObject.pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst struct hipResourceViewDesc * pResViewDesc = %p", args->hipCreateTextureObject.pResViewDesc);
			if (args->hipCreateTextureObject.pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceViewFormat format = %d\n", args->hipCreateTextureObject.pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->hipCreateTextureObject.pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->hipCreateTextureObject.pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->hipCreateTextureObject.pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->hipCreateTextureObject.pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->hipCreateTextureObject.pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->hipCreateTextureObject.pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->hipCreateTextureObject.pResViewDesc__ref.val.lastLayer);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCreateTextureObject.retval);
			break;

		#endif
		#if HAVE_hipGraphKernelNodeCopyAttributes
		case HIP_API_ID_hipGraphKernelNodeCopyAttributes :
			//	hipGraphNode_t hSrc (struct hipGraphNode *);
			//	hipGraphNode_t hDst (struct hipGraphNode *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hSrc = %p", args->hipGraphKernelNodeCopyAttributes.hSrc);
			printf("\n");
			printf("\thipGraphNode_t hDst = %p", args->hipGraphKernelNodeCopyAttributes.hDst);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphKernelNodeCopyAttributes.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetFlags
		case HIP_API_ID_hipTexRefGetFlags :
			//	unsigned int * pFlags (unsigned int *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int * pFlags = %p", args->hipTexRefGetFlags.pFlags);
			if (args->hipTexRefGetFlags.pFlags != NULL) {
				printf(" -> %u\n", args->hipTexRefGetFlags.pFlags__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetFlags.texRef);
			if (args->hipTexRefGetFlags.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetFlags.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetFlags.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetFlags.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetFlags.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetFlags.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetFlags.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetFlags.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetFlags.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetFlags.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetFlags.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetFlags.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetFlags.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetFlags.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetFlags.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetFlags.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetFlags.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetFlags.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetFlags.retval);
			break;

		#endif
		#if HAVE_hipDrvGraphAddMemcpyNode
		case HIP_API_ID_hipDrvGraphAddMemcpyNode :
			//	hipGraphNode_t * phGraphNode (struct hipGraphNode **);
			//	hipGraph_t hGraph (struct ihipGraph *);
			//	const hipGraphNode_t * dependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const HIP_MEMCPY3D * copyParams ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		size_t srcZ (unsigned long);
			//		size_t srcLOD (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t srcHeight (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		size_t dstZ (unsigned long);
			//		size_t dstLOD (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t dstHeight (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//	});
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * phGraphNode = %p", args->hipDrvGraphAddMemcpyNode.phGraphNode);
			if (args->hipDrvGraphAddMemcpyNode.phGraphNode != NULL) {
				printf(" -> %p\n", args->hipDrvGraphAddMemcpyNode.phGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t hGraph = %p", args->hipDrvGraphAddMemcpyNode.hGraph);
			printf("\n");
			printf("\tconst hipGraphNode_t * dependencies = %p", args->hipDrvGraphAddMemcpyNode.dependencies);
			if (args->hipDrvGraphAddMemcpyNode.dependencies != NULL) {
				printf(" -> %p\n", args->hipDrvGraphAddMemcpyNode.dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipDrvGraphAddMemcpyNode.numDependencies);
			printf("\tconst HIP_MEMCPY3D * copyParams = %p", args->hipDrvGraphAddMemcpyNode.copyParams);
			if (args->hipDrvGraphAddMemcpyNode.copyParams != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcY);
				printf("\t\tsize_t srcZ = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcZ);
				printf("\t\tsize_t srcLOD = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcLOD);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcPitch);
				printf("\t\tsize_t srcHeight = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.srcHeight);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstY);
				printf("\t\tsize_t dstZ = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstZ);
				printf("\t\tsize_t dstLOD = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstLOD);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstPitch);
				printf("\t\tsize_t dstHeight = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.dstHeight);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->hipDrvGraphAddMemcpyNode.copyParams__ref.val.Depth);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipCtx_t ctx = %p", args->hipDrvGraphAddMemcpyNode.ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDrvGraphAddMemcpyNode.retval);
			break;

		#endif
		#if HAVE_hipMemExportToShareableHandle
		case HIP_API_ID_hipMemExportToShareableHandle :
			//	void * shareableHandle (void *);
			//	hipMemGenericAllocationHandle_t handle (struct ihipMemGenericAllocationHandle *);
			//	hipMemAllocationHandleType handleType (enum hipMemAllocationHandleType);
			//	unsigned long long flags (unsigned long long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * shareableHandle = %p", args->hipMemExportToShareableHandle.shareableHandle);
			printf("\n");
			printf("\thipMemGenericAllocationHandle_t handle = %p", args->hipMemExportToShareableHandle.handle);
			printf("\n");
			printf("\thipMemAllocationHandleType handleType = %d\n", args->hipMemExportToShareableHandle.handleType);
			printf("\tunsigned long long flags = %llu\n", args->hipMemExportToShareableHandle.flags);
			printf("\thipError_t retval = %d\n", args->hipMemExportToShareableHandle.retval);
			break;

		#endif
		#if HAVE_hipGraphLaunch_spt
		case HIP_API_ID_hipGraphLaunch_spt :
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t graphExec = %p", args->hipGraphLaunch_spt.graphExec);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipGraphLaunch_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphLaunch_spt.retval);
			break;

		#endif
		#if HAVE_hipGraphMemcpyNodeSetParamsFromSymbol
		case HIP_API_ID_hipGraphMemcpyNodeSetParamsFromSymbol :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemcpyNodeSetParamsFromSymbol.node);
			printf("\n");
			printf("\tvoid * dst = %p", args->hipGraphMemcpyNodeSetParamsFromSymbol.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipGraphMemcpyNodeSetParamsFromSymbol.symbol);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphMemcpyNodeSetParamsFromSymbol.count);
			printf("\tsize_t offset = %lu\n", args->hipGraphMemcpyNodeSetParamsFromSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphMemcpyNodeSetParamsFromSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphMemcpyNodeSetParamsFromSymbol.retval);
			break;

		#endif
		#if HAVE_hipGraphNodeGetDependencies
		case HIP_API_ID_hipGraphNodeGetDependencies :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraphNode_t * pDependencies (struct hipGraphNode **);
			//	size_t * pNumDependencies (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphNodeGetDependencies.node);
			printf("\n");
			printf("\thipGraphNode_t * pDependencies = %p", args->hipGraphNodeGetDependencies.pDependencies);
			if (args->hipGraphNodeGetDependencies.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphNodeGetDependencies.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * pNumDependencies = %p", args->hipGraphNodeGetDependencies.pNumDependencies);
			if (args->hipGraphNodeGetDependencies.pNumDependencies != NULL) {
				printf(" -> %lu\n", args->hipGraphNodeGetDependencies.pNumDependencies__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphNodeGetDependencies.retval);
			break;

		#endif
		#if HAVE_hipMemcpy3D
		case HIP_API_ID_hipMemcpy3D :
			//	const struct hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst struct hipMemcpy3DParms * p = %p", args->hipMemcpy3D.p);
			if (args->hipMemcpy3D.p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3D.p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3D.p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3D.p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3D.p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3D.p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3D.p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3D.p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3D.p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3D.p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3D.p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3D.p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3D.p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipMemcpy3D.p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipMemcpy3D.p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipMemcpy3D.p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipMemcpy3D.p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemcpy3D.retval);
			break;

		#endif
		#if HAVE_hipGraphAddMemcpyNodeFromSymbol
		case HIP_API_ID_hipGraphAddMemcpyNodeFromSymbol :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	void * dst (void *);
			//	const void * symbol (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemcpyNodeFromSymbol.pGraphNode);
			if (args->hipGraphAddMemcpyNodeFromSymbol.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNodeFromSymbol.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemcpyNodeFromSymbol.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemcpyNodeFromSymbol.pDependencies);
			if (args->hipGraphAddMemcpyNodeFromSymbol.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNodeFromSymbol.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemcpyNodeFromSymbol.numDependencies);
			printf("\tvoid * dst = %p", args->hipGraphAddMemcpyNodeFromSymbol.dst);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipGraphAddMemcpyNodeFromSymbol.symbol);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphAddMemcpyNodeFromSymbol.count);
			printf("\tsize_t offset = %lu\n", args->hipGraphAddMemcpyNodeFromSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphAddMemcpyNodeFromSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemcpyNodeFromSymbol.retval);
			break;

		#endif
		#if HAVE_hipStreamGetPriority_spt
		case HIP_API_ID_hipStreamGetPriority_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	int * priority (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetPriority_spt.stream);
			printf("\n");
			printf("\tint * priority = %p", args->hipStreamGetPriority_spt.priority);
			if (args->hipStreamGetPriority_spt.priority != NULL) {
				printf(" -> %d\n", args->hipStreamGetPriority_spt.priority__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetPriority_spt.retval);
			break;

		#endif
		#if HAVE_hipModuleLoadData
		case HIP_API_ID_hipModuleLoadData :
			//	hipModule_t * module (struct ihipModule_t **);
			//	const void * image (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipModule_t * module = %p", args->hipModuleLoadData.module);
			if (args->hipModuleLoadData.module != NULL) {
				printf(" -> %p\n", args->hipModuleLoadData.module__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * image = %p", args->hipModuleLoadData.image);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipModuleLoadData.retval);
			break;

		#endif
		#if HAVE_hipSetDeviceFlags
		case HIP_API_ID_hipSetDeviceFlags :
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int flags = %u\n", args->hipSetDeviceFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipSetDeviceFlags.retval);
			break;

		#endif
		#if HAVE_hipExternalMemoryGetMappedBuffer
		case HIP_API_ID_hipExternalMemoryGetMappedBuffer :
			//	void ** devPtr (void **);
			//	hipExternalMemory_t extMem (void *);
			//	const hipExternalMemoryBufferDesc * bufferDesc ({
			//		unsigned long long offset (unsigned long long);
			//		unsigned long long size (unsigned long long);
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** devPtr = %p", args->hipExternalMemoryGetMappedBuffer.devPtr);
			if (args->hipExternalMemoryGetMappedBuffer.devPtr != NULL) {
				printf("-> %p", args->hipExternalMemoryGetMappedBuffer.devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipExternalMemory_t extMem = %p", args->hipExternalMemoryGetMappedBuffer.extMem);
			printf("\n");
			printf("\tconst hipExternalMemoryBufferDesc * bufferDesc = %p", args->hipExternalMemoryGetMappedBuffer.bufferDesc);
			if (args->hipExternalMemoryGetMappedBuffer.bufferDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned long long offset = %llu\n", args->hipExternalMemoryGetMappedBuffer.bufferDesc__ref.val.offset);
				printf("\t\tunsigned long long size = %llu\n", args->hipExternalMemoryGetMappedBuffer.bufferDesc__ref.val.size);
				printf("\t\tunsigned int flags = %u\n", args->hipExternalMemoryGetMappedBuffer.bufferDesc__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipExternalMemoryGetMappedBuffer.bufferDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipExternalMemoryGetMappedBuffer.retval);
			break;

		#endif
		#if HAVE_hipLaunchCooperativeKernel_spt
		case HIP_API_ID_hipLaunchCooperativeKernel_spt :
			//	const void * f (const void *);
			//	dim3 gridDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 blockDim ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** kernelParams (void **);
			//	uint32_t sharedMemBytes (unsigned int);
			//	hipStream_t hStream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * f = %p", args->hipLaunchCooperativeKernel_spt.f);
			printf("\n");
			printf("\tdim3 gridDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchCooperativeKernel_spt.gridDim.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchCooperativeKernel_spt.gridDim.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchCooperativeKernel_spt.gridDim.z);
			printf("\t}\n");
			printf("\tdim3 blockDim = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipLaunchCooperativeKernel_spt.blockDim.x);
			printf("\t\tuint32_t y = %u\n", args->hipLaunchCooperativeKernel_spt.blockDim.y);
			printf("\t\tuint32_t z = %u\n", args->hipLaunchCooperativeKernel_spt.blockDim.z);
			printf("\t}\n");
			printf("\tvoid ** kernelParams = %p", args->hipLaunchCooperativeKernel_spt.kernelParams);
			if (args->hipLaunchCooperativeKernel_spt.kernelParams != NULL) {
				printf("-> %p", args->hipLaunchCooperativeKernel_spt.kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tuint32_t sharedMemBytes = %u\n", args->hipLaunchCooperativeKernel_spt.sharedMemBytes);
			printf("\thipStream_t hStream = %p", args->hipLaunchCooperativeKernel_spt.hStream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchCooperativeKernel_spt.retval);
			break;

		#endif
		#if HAVE_hipLaunchHostFunc
		case HIP_API_ID_hipLaunchHostFunc :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipHostFn_t fn (void (*)(void *));
			//	void * userData (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipLaunchHostFunc.stream);
			printf("\n");
			printf("\thipHostFn_t fn = %p\n", args->hipLaunchHostFunc.fn);
			printf("\tvoid * userData = %p", args->hipLaunchHostFunc.userData);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchHostFunc.retval);
			break;

		#endif
		#if HAVE_hipMemcpyAsync_spt
		case HIP_API_ID_hipMemcpyAsync_spt :
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyAsync_spt.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyAsync_spt.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyAsync_spt.sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyAsync_spt.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipMemcpyPeer
		case HIP_API_ID_hipMemcpyPeer :
			//	void * dst (void *);
			//	int dstDeviceId (int);
			//	const void * src (const void *);
			//	int srcDeviceId (int);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpyPeer.dst);
			printf("\n");
			printf("\tint dstDeviceId = %d\n", args->hipMemcpyPeer.dstDeviceId);
			printf("\tconst void * src = %p", args->hipMemcpyPeer.src);
			printf("\n");
			printf("\tint srcDeviceId = %d\n", args->hipMemcpyPeer.srcDeviceId);
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyPeer.sizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemcpyPeer.retval);
			break;

		#endif
		#if HAVE_hipDeviceReset
		case HIP_API_ID_hipDeviceReset :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipDeviceReset.retval);
			break;

		#endif
		#if HAVE_hipMemAddressFree
		case HIP_API_ID_hipMemAddressFree :
			//	void * devPtr (void *);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * devPtr = %p", args->hipMemAddressFree.devPtr);
			printf("\n");
			printf("\tsize_t size = %lu\n", args->hipMemAddressFree.size);
			printf("\thipError_t retval = %d\n", args->hipMemAddressFree.retval);
			break;

		#endif
		#if HAVE_hipProfilerStop
		case HIP_API_ID_hipProfilerStop :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipProfilerStop.retval);
			break;

		#endif
		#if HAVE_hipGraphEventWaitNodeSetEvent
		case HIP_API_ID_hipGraphEventWaitNodeSetEvent :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphEventWaitNodeSetEvent.node);
			printf("\n");
			printf("\thipEvent_t event = %p", args->hipGraphEventWaitNodeSetEvent.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphEventWaitNodeSetEvent.retval);
			break;

		#endif
		#if HAVE_hipModuleLaunchCooperativeKernel
		case HIP_API_ID_hipModuleLaunchCooperativeKernel :
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	unsigned int gridDimX (unsigned int);
			//	unsigned int gridDimY (unsigned int);
			//	unsigned int gridDimZ (unsigned int);
			//	unsigned int blockDimX (unsigned int);
			//	unsigned int blockDimY (unsigned int);
			//	unsigned int blockDimZ (unsigned int);
			//	unsigned int sharedMemBytes (unsigned int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	void ** kernelParams (void **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFunction_t f = %p", args->hipModuleLaunchCooperativeKernel.f);
			printf("\n");
			printf("\tunsigned int gridDimX = %u\n", args->hipModuleLaunchCooperativeKernel.gridDimX);
			printf("\tunsigned int gridDimY = %u\n", args->hipModuleLaunchCooperativeKernel.gridDimY);
			printf("\tunsigned int gridDimZ = %u\n", args->hipModuleLaunchCooperativeKernel.gridDimZ);
			printf("\tunsigned int blockDimX = %u\n", args->hipModuleLaunchCooperativeKernel.blockDimX);
			printf("\tunsigned int blockDimY = %u\n", args->hipModuleLaunchCooperativeKernel.blockDimY);
			printf("\tunsigned int blockDimZ = %u\n", args->hipModuleLaunchCooperativeKernel.blockDimZ);
			printf("\tunsigned int sharedMemBytes = %u\n", args->hipModuleLaunchCooperativeKernel.sharedMemBytes);
			printf("\thipStream_t stream = %p", args->hipModuleLaunchCooperativeKernel.stream);
			printf("\n");
			printf("\tvoid ** kernelParams = %p", args->hipModuleLaunchCooperativeKernel.kernelParams);
			if (args->hipModuleLaunchCooperativeKernel.kernelParams != NULL) {
				printf("-> %p", args->hipModuleLaunchCooperativeKernel.kernelParams__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipModuleLaunchCooperativeKernel.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetName
		case HIP_API_ID_hipDeviceGetName :
			//	char * name (char *);
			//	int len (int);
			//	hipDevice_t device (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tchar * name = %p", args->hipDeviceGetName.name);
			if (args->hipDeviceGetName.name != NULL) {
				printf(" -> %s\n", args->hipDeviceGetName.name__ref.val);
			} else { printf("\n"); };
			printf("\tint len = %d\n", args->hipDeviceGetName.len);
			printf("\thipDevice_t device = %d\n", args->hipDeviceGetName.device);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetName.retval);
			break;

		#endif
		#if HAVE_hipGraphNodeSetEnabled
		case HIP_API_ID_hipGraphNodeSetEnabled :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	unsigned int isEnabled (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphNodeSetEnabled.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hipGraphNodeSetEnabled.hNode);
			printf("\n");
			printf("\tunsigned int isEnabled = %u\n", args->hipGraphNodeSetEnabled.isEnabled);
			printf("\thipError_t retval = %d\n", args->hipGraphNodeSetEnabled.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetAddressMode
		case HIP_API_ID_hipTexRefSetAddressMode :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	int dim (int);
			//	enum hipTextureAddressMode am (enum hipTextureAddressMode);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetAddressMode.texRef);
			if (args->hipTexRefSetAddressMode.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetAddressMode.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetAddressMode.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetAddressMode.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetAddressMode.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetAddressMode.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint dim = %d\n", args->hipTexRefSetAddressMode.dim);
			printf("\tenum hipTextureAddressMode am = %d\n", args->hipTexRefSetAddressMode.am);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetAddressMode.retval);
			break;

		#endif
		#if HAVE_hipEventSynchronize
		case HIP_API_ID_hipEventSynchronize :
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t event = %p", args->hipEventSynchronize.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipEventSynchronize.retval);
			break;

		#endif
		#if HAVE_hipGraphGetRootNodes
		case HIP_API_ID_hipGraphGetRootNodes :
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * pRootNodes (struct hipGraphNode **);
			//	size_t * pNumRootNodes (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphGetRootNodes.graph);
			printf("\n");
			printf("\thipGraphNode_t * pRootNodes = %p", args->hipGraphGetRootNodes.pRootNodes);
			if (args->hipGraphGetRootNodes.pRootNodes != NULL) {
				printf(" -> %p\n", args->hipGraphGetRootNodes.pRootNodes__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * pNumRootNodes = %p", args->hipGraphGetRootNodes.pNumRootNodes);
			if (args->hipGraphGetRootNodes.pNumRootNodes != NULL) {
				printf(" -> %lu\n", args->hipGraphGetRootNodes.pNumRootNodes__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphGetRootNodes.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DFromArray
		case HIP_API_ID_hipMemcpy2DFromArray :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2DFromArray.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2DFromArray.dpitch);
			printf("\thipArray_const_t src = %p", args->hipMemcpy2DFromArray.src);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DFromArray.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DFromArray.hOffset);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DFromArray.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DFromArray.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DFromArray.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DFromArray.retval);
			break;

		#endif
		#if HAVE_hipGraphExternalSemaphoresWaitNodeSetParams
		case HIP_API_ID_hipGraphExternalSemaphoresWaitNodeSetParams :
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreWaitNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExternalSemaphoresWaitNodeSetParams.hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreWaitNodeParams * nodeParams = %p", args->hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams);
			if (args->hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphExternalSemaphoresWaitNodeSetParams.nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExternalSemaphoresWaitNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipMemcpyDtoA
		case HIP_API_ID_hipMemcpyDtoA :
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	hipDeviceptr_t srcDevice (void *);
			//	size_t ByteCount (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dstArray = %p", args->hipMemcpyDtoA.dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->hipMemcpyDtoA.dstOffset);
			printf("\thipDeviceptr_t srcDevice = %p", args->hipMemcpyDtoA.srcDevice);
			printf("\n");
			printf("\tsize_t ByteCount = %lu\n", args->hipMemcpyDtoA.ByteCount);
			printf("\thipError_t retval = %d\n", args->hipMemcpyDtoA.retval);
			break;

		#endif
		#if HAVE_hipGraphMemcpyNodeGetParams
		case HIP_API_ID_hipGraphMemcpyNodeGetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemcpy3DParms * pNodeParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemcpyNodeGetParams.node);
			printf("\n");
			printf("\thipMemcpy3DParms * pNodeParams = %p", args->hipGraphMemcpyNodeGetParams.pNodeParams);
			if (args->hipGraphMemcpyNodeGetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipGraphMemcpyNodeGetParams.pNodeParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphMemcpyNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipMemcpy
		case HIP_API_ID_hipMemcpy :
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpy.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpy.sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy.retval);
			break;

		#endif
		#if HAVE_hipSetValidDevices
		case HIP_API_ID_hipSetValidDevices :
			//	int * device_arr (int *);
			//	int len (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * device_arr = %p", args->hipSetValidDevices.device_arr);
			if (args->hipSetValidDevices.device_arr != NULL) {
				printf(" -> %d\n", args->hipSetValidDevices.device_arr__ref.val);
			} else { printf("\n"); };
			printf("\tint len = %d\n", args->hipSetValidDevices.len);
			printf("\thipError_t retval = %d\n", args->hipSetValidDevices.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DAsync
		case HIP_API_ID_hipMemcpy2DAsync :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2DAsync.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2DAsync.dpitch);
			printf("\tconst void * src = %p", args->hipMemcpy2DAsync.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2DAsync.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DAsync.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DAsync.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DAsync.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpy2DAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DAsync.retval);
			break;

		#endif
		#if HAVE_hipGraphExecExternalSemaphoresWaitNodeSetParams
		case HIP_API_ID_hipGraphExecExternalSemaphoresWaitNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreWaitNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecExternalSemaphoresWaitNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExecExternalSemaphoresWaitNodeSetParams.hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreWaitNodeParams * nodeParams = %p", args->hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams);
			if (args->hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphExecExternalSemaphoresWaitNodeSetParams.nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecExternalSemaphoresWaitNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipStreamAttachMemAsync
		case HIP_API_ID_hipStreamAttachMemAsync :
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * dev_ptr (void *);
			//	size_t length (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamAttachMemAsync.stream);
			printf("\n");
			printf("\tvoid * dev_ptr = %p", args->hipStreamAttachMemAsync.dev_ptr);
			printf("\n");
			printf("\tsize_t length = %lu\n", args->hipStreamAttachMemAsync.length);
			printf("\tunsigned int flags = %u\n", args->hipStreamAttachMemAsync.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamAttachMemAsync.retval);
			break;

		#endif
		#if HAVE_hipMemset2DAsync
		case HIP_API_ID_hipMemset2DAsync :
			//	void * dst (void *);
			//	size_t pitch (unsigned long);
			//	int value (int);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemset2DAsync.dst);
			printf("\n");
			printf("\tsize_t pitch = %lu\n", args->hipMemset2DAsync.pitch);
			printf("\tint value = %d\n", args->hipMemset2DAsync.value);
			printf("\tsize_t width = %lu\n", args->hipMemset2DAsync.width);
			printf("\tsize_t height = %lu\n", args->hipMemset2DAsync.height);
			printf("\thipStream_t stream = %p", args->hipMemset2DAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemset2DAsync.retval);
			break;

		#endif
		#if HAVE_hipTexObjectGetResourceViewDesc
		case HIP_API_ID_hipTexObjectGetResourceViewDesc :
			//	HIP_RESOURCE_VIEW_DESC * pResViewDesc ({
			//		HIPresourceViewFormat format (enum HIPresourceViewFormat_enum);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\tHIP_RESOURCE_VIEW_DESC * pResViewDesc = %p", args->hipTexObjectGetResourceViewDesc.pResViewDesc);
			if (args->hipTexObjectGetResourceViewDesc.pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourceViewFormat format = %d\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.lastLayer);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipTexObjectGetResourceViewDesc.pResViewDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t texObject = %p", args->hipTexObjectGetResourceViewDesc.texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipTexObjectGetResourceViewDesc.retval);
			break;

		#endif
		#if HAVE_hipEventCreateWithFlags
		case HIP_API_ID_hipEventCreateWithFlags :
			//	hipEvent_t * event (struct ihipEvent_t **);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t * event = %p", args->hipEventCreateWithFlags.event);
			if (args->hipEventCreateWithFlags.event != NULL) {
				printf(" -> %p\n", args->hipEventCreateWithFlags.event__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->hipEventCreateWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipEventCreateWithFlags.retval);
			break;

		#endif
		#if HAVE_hipMipmappedArrayCreate
		case HIP_API_ID_hipMipmappedArrayCreate :
			//	hipMipmappedArray_t * pHandle ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	HIP_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//		unsigned int Flags (unsigned int);
			//	});
			//	unsigned int numMipmapLevels (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMipmappedArray_t * pHandle = %p", args->hipMipmappedArrayCreate.pHandle);
			if (args->hipMipmappedArrayCreate.pHandle != NULL) {
				printf("-> %p", args->hipMipmappedArrayCreate.pHandle__ref.ptr1);
				if (args->hipMipmappedArrayCreate.pHandle__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->hipMipmappedArrayCreate.pHandle__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->hipMipmappedArrayCreate.pHandle__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->hipMipmappedArrayCreate.pHandle__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->hipMipmappedArrayCreate.pHandle__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipMipmappedArrayCreate.pHandle__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->hipMipmappedArrayCreate.pHandle__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->hipMipmappedArrayCreate.pHandle__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tHIP_ARRAY3D_DESCRIPTOR * pMipmappedArrayDesc = %p", args->hipMipmappedArrayCreate.pMipmappedArrayDesc);
			if (args->hipMipmappedArrayCreate.pMipmappedArrayDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->hipMipmappedArrayCreate.pMipmappedArrayDesc__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->hipMipmappedArrayCreate.pMipmappedArrayDesc__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->hipMipmappedArrayCreate.pMipmappedArrayDesc__ref.val.Depth);
				printf("\t\tenum hipArray_Format Format = %d\n", args->hipMipmappedArrayCreate.pMipmappedArrayDesc__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->hipMipmappedArrayCreate.pMipmappedArrayDesc__ref.val.NumChannels);
				printf("\t\tunsigned int Flags = %u\n", args->hipMipmappedArrayCreate.pMipmappedArrayDesc__ref.val.Flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int numMipmapLevels = %u\n", args->hipMipmappedArrayCreate.numMipmapLevels);
			printf("\thipError_t retval = %d\n", args->hipMipmappedArrayCreate.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2D_spt
		case HIP_API_ID_hipMemcpy2D_spt :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2D_spt.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2D_spt.dpitch);
			printf("\tconst void * src = %p", args->hipMemcpy2D_spt.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2D_spt.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2D_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2D_spt.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2D_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2D_spt.retval);
			break;

		#endif
		#if HAVE_hipGraphAddMemcpyNode
		case HIP_API_ID_hipGraphAddMemcpyNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const hipMemcpy3DParms * pCopyParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemcpyNode.pGraphNode);
			if (args->hipGraphAddMemcpyNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemcpyNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemcpyNode.pDependencies);
			if (args->hipGraphAddMemcpyNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemcpyNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemcpyNode.numDependencies);
			printf("\tconst hipMemcpy3DParms * pCopyParams = %p", args->hipGraphAddMemcpyNode.pCopyParams);
			if (args->hipGraphAddMemcpyNode.pCopyParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipGraphAddMemcpyNode.pCopyParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemcpyNode.retval);
			break;

		#endif
		#if HAVE_hipMemcpyToSymbolAsync
		case HIP_API_ID_hipMemcpyToSymbolAsync :
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * symbol = %p", args->hipMemcpyToSymbolAsync.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyToSymbolAsync.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyToSymbolAsync.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyToSymbolAsync.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyToSymbolAsync.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpyToSymbolAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyToSymbolAsync.retval);
			break;

		#endif
		#if HAVE_hipMallocFromPoolAsync
		case HIP_API_ID_hipMallocFromPoolAsync :
			//	void ** dev_ptr (void **);
			//	size_t size (unsigned long);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** dev_ptr = %p", args->hipMallocFromPoolAsync.dev_ptr);
			if (args->hipMallocFromPoolAsync.dev_ptr != NULL) {
				printf("-> %p", args->hipMallocFromPoolAsync.dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMallocFromPoolAsync.size);
			printf("\thipMemPool_t mem_pool = %p", args->hipMallocFromPoolAsync.mem_pool);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipMallocFromPoolAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMallocFromPoolAsync.retval);
			break;

		#endif
		#if HAVE_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags
		case HIP_API_ID_hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags :
			//	int * numBlocks (int *);
			//	const void * f (const void *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * numBlocks = %p", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks);
			if (args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks != NULL) {
				printf(" -> %d\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * f = %p", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.dynSharedMemPerBlk);
			printf("\tunsigned int flags = %u\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipOccupancyMaxActiveBlocksPerMultiprocessorWithFlags.retval);
			break;

		#endif
		#if HAVE_hipGraphAddMemFreeNode
		case HIP_API_ID_hipGraphAddMemFreeNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	void * dev_ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemFreeNode.pGraphNode);
			if (args->hipGraphAddMemFreeNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemFreeNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemFreeNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemFreeNode.pDependencies);
			if (args->hipGraphAddMemFreeNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemFreeNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemFreeNode.numDependencies);
			printf("\tvoid * dev_ptr = %p", args->hipGraphAddMemFreeNode.dev_ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemFreeNode.retval);
			break;

		#endif
		#if HAVE_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor
		case HIP_API_ID_hipModuleOccupancyMaxActiveBlocksPerMultiprocessor :
			//	int * numBlocks (int *);
			//	hipFunction_t f (struct ihipModuleSymbol_t *);
			//	int blockSize (int);
			//	size_t dynSharedMemPerBlk (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * numBlocks = %p", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks);
			if (args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks != NULL) {
				printf(" -> %d\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.numBlocks__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_t f = %p", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.f);
			printf("\n");
			printf("\tint blockSize = %d\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.blockSize);
			printf("\tsize_t dynSharedMemPerBlk = %lu\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.dynSharedMemPerBlk);
			printf("\thipError_t retval = %d\n", args->hipModuleOccupancyMaxActiveBlocksPerMultiprocessor.retval);
			break;

		#endif
		#if HAVE_hipEventDestroy
		case HIP_API_ID_hipEventDestroy :
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t event = %p", args->hipEventDestroy.event);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipEventDestroy.retval);
			break;

		#endif
		#if HAVE_hipDeviceSetCacheConfig
		case HIP_API_ID_hipDeviceSetCacheConfig :
			//	hipFuncCache_t cacheConfig (enum hipFuncCache_t);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFuncCache_t cacheConfig = %d\n", args->hipDeviceSetCacheConfig.cacheConfig);
			printf("\thipError_t retval = %d\n", args->hipDeviceSetCacheConfig.retval);
			break;

		#endif
		#if HAVE_hipFree
		case HIP_API_ID_hipFree :
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipFree.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipFree.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DToArrayAsync_spt
		case HIP_API_ID_hipMemcpy2DToArrayAsync_spt :
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dst = %p", args->hipMemcpy2DToArrayAsync_spt.dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DToArrayAsync_spt.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DToArrayAsync_spt.hOffset);
			printf("\tconst void * src = %p", args->hipMemcpy2DToArrayAsync_spt.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2DToArrayAsync_spt.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DToArrayAsync_spt.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DToArrayAsync_spt.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DToArrayAsync_spt.kind);
			printf("\thipStream_t stream = %p", args->hipMemcpy2DToArrayAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DToArrayAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipCtxGetFlags
		case HIP_API_ID_hipCtxGetFlags :
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int * flags = %p", args->hipCtxGetFlags.flags);
			if (args->hipCtxGetFlags.flags != NULL) {
				printf(" -> %u\n", args->hipCtxGetFlags.flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxGetFlags.retval);
			break;

		#endif
		#if HAVE_hipGetSymbolAddress
		case HIP_API_ID_hipGetSymbolAddress :
			//	void ** devPtr (void **);
			//	const void * symbol (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** devPtr = %p", args->hipGetSymbolAddress.devPtr);
			if (args->hipGetSymbolAddress.devPtr != NULL) {
				printf("-> %p", args->hipGetSymbolAddress.devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst void * symbol = %p", args->hipGetSymbolAddress.symbol);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetSymbolAddress.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetAddress
		case HIP_API_ID_hipTexRefGetAddress :
			//	hipDeviceptr_t * dev_ptr (void **);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t * dev_ptr = %p", args->hipTexRefGetAddress.dev_ptr);
			if (args->hipTexRefGetAddress.dev_ptr != NULL) {
				printf("-> %p", args->hipTexRefGetAddress.dev_ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetAddress.texRef);
			if (args->hipTexRefGetAddress.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetAddress.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetAddress.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetAddress.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetAddress.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetAddress.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetAddress.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetAddress.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetAddress.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetAddress.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetAddress.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetAddress.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetAddress.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetAddress.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetAddress.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetAddress.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetAddress.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetAddress.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetAddress.retval);
			break;

		#endif
		#if HAVE_hipTexObjectCreate
		case HIP_API_ID_hipTexObjectCreate :
			//	hipTextureObject_t * pTexObject (struct __hip_texture **);
			//	const HIP_RESOURCE_DESC * pResDesc ({
			//		HIPresourcetype resType (enum HIPresourcetype_enum);
			//		union (unnamed union at header/hip/hip.h:635:2) res ({
			//		});
			//		unsigned int flags (unsigned int);
			//	});
			//	const HIP_TEXTURE_DESC * pTexDesc ({
			//		HIPaddress_mode[3] addressMode (enum HIPaddress_mode_enum[3]);
			//		HIPfilter_mode filterMode (enum HIPfilter_mode_enum);
			//		unsigned int flags (unsigned int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		HIPfilter_mode mipmapFilterMode (enum HIPfilter_mode_enum);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		float[4] borderColor (float[4]);
			//		int[12] reserved (int[12]);
			//	});
			//	const HIP_RESOURCE_VIEW_DESC * pResViewDesc ({
			//		HIPresourceViewFormat format (enum HIPresourceViewFormat_enum);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipTextureObject_t * pTexObject = %p", args->hipTexObjectCreate.pTexObject);
			if (args->hipTexObjectCreate.pTexObject != NULL) {
				printf(" -> %p\n", args->hipTexObjectCreate.pTexObject__ref.val);
			} else { printf("\n"); };
			printf("\tconst HIP_RESOURCE_DESC * pResDesc = %p", args->hipTexObjectCreate.pResDesc);
			if (args->hipTexObjectCreate.pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourcetype resType = %d\n", args->hipTexObjectCreate.pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:635:2) res = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->hipTexObjectCreate.pResDesc__ref.val.flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst HIP_TEXTURE_DESC * pTexDesc = %p", args->hipTexObjectCreate.pTexDesc);
			if (args->hipTexObjectCreate.pTexDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPaddress_mode[3] addressMode = %d\n", args->hipTexObjectCreate.pTexDesc__ref.val.addressMode[0]);
				printf("\t\tHIPfilter_mode filterMode = %d\n", args->hipTexObjectCreate.pTexDesc__ref.val.filterMode);
				printf("\t\tunsigned int flags = %u\n", args->hipTexObjectCreate.pTexDesc__ref.val.flags);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexObjectCreate.pTexDesc__ref.val.maxAnisotropy);
				printf("\t\tHIPfilter_mode mipmapFilterMode = %d\n", args->hipTexObjectCreate.pTexDesc__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexObjectCreate.pTexDesc__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexObjectCreate.pTexDesc__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexObjectCreate.pTexDesc__ref.val.maxMipmapLevelClamp);
				printf("\t\tfloat[4] borderColor = %f\n", args->hipTexObjectCreate.pTexDesc__ref.val.borderColor[0]);
				printf("\t\tint[12] reserved = %d\n", args->hipTexObjectCreate.pTexDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst HIP_RESOURCE_VIEW_DESC * pResViewDesc = %p", args->hipTexObjectCreate.pResViewDesc);
			if (args->hipTexObjectCreate.pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tHIPresourceViewFormat format = %d\n", args->hipTexObjectCreate.pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->hipTexObjectCreate.pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->hipTexObjectCreate.pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->hipTexObjectCreate.pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->hipTexObjectCreate.pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->hipTexObjectCreate.pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->hipTexObjectCreate.pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->hipTexObjectCreate.pResViewDesc__ref.val.lastLayer);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipTexObjectCreate.pResViewDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexObjectCreate.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetSharedMemConfig
		case HIP_API_ID_hipDeviceGetSharedMemConfig :
			//	hipSharedMemConfig * pConfig (enum hipSharedMemConfig*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipSharedMemConfig * pConfig = %p", args->hipDeviceGetSharedMemConfig.pConfig);
			if (args->hipDeviceGetSharedMemConfig.pConfig != NULL) {
				printf(" -> %d\n", args->hipDeviceGetSharedMemConfig.pConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDeviceGetSharedMemConfig.retval);
			break;

		#endif
		#if HAVE_hipMemcpyHtoAAsync
		case HIP_API_ID_hipMemcpyHtoAAsync :
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	const void * srcHost (const void *);
			//	size_t ByteCount (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dstArray = %p", args->hipMemcpyHtoAAsync.dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->hipMemcpyHtoAAsync.dstOffset);
			printf("\tconst void * srcHost = %p", args->hipMemcpyHtoAAsync.srcHost);
			printf("\n");
			printf("\tsize_t ByteCount = %lu\n", args->hipMemcpyHtoAAsync.ByteCount);
			printf("\thipStream_t stream = %p", args->hipMemcpyHtoAAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyHtoAAsync.retval);
			break;

		#endif
		#if HAVE_hipMemPoolGetAttribute
		case HIP_API_ID_hipMemPoolGetAttribute :
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipMemPoolAttr attr (enum hipMemPoolAttr);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolGetAttribute.mem_pool);
			printf("\n");
			printf("\thipMemPoolAttr attr = %d\n", args->hipMemPoolGetAttribute.attr);
			printf("\tvoid * value = %p", args->hipMemPoolGetAttribute.value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemPoolGetAttribute.retval);
			break;

		#endif
		#if HAVE_hipGraphAddMemAllocNode
		case HIP_API_ID_hipGraphAddMemAllocNode :
			//	hipGraphNode_t * pGraphNode (struct hipGraphNode **);
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * pDependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipMemAllocNodeParams * pNodeParams ({
			//		hipMemPoolProps poolProps ({
			//			hipMemAllocationType allocType (enum hipMemAllocationType);
			//			hipMemAllocationHandleType handleTypes (enum hipMemAllocationHandleType);
			//			hipMemLocation location ({
			//				hipMemLocationType type (enum hipMemLocationType);
			//				int id (int);
			//			});
			//			void * win32SecurityAttributes (void *);
			//			size_t maxSize (unsigned long);
			//			unsigned char[56] reserved (unsigned char[56]);
			//		});
			//		size_t accessDescCount (unsigned long);
			//		size_t bytesize (unsigned long);
			//		void * dptr (void *);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * pGraphNode = %p", args->hipGraphAddMemAllocNode.pGraphNode);
			if (args->hipGraphAddMemAllocNode.pGraphNode != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemAllocNode.pGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t graph = %p", args->hipGraphAddMemAllocNode.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * pDependencies = %p", args->hipGraphAddMemAllocNode.pDependencies);
			if (args->hipGraphAddMemAllocNode.pDependencies != NULL) {
				printf(" -> %p\n", args->hipGraphAddMemAllocNode.pDependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddMemAllocNode.numDependencies);
			printf("\thipMemAllocNodeParams * pNodeParams = %p", args->hipGraphAddMemAllocNode.pNodeParams);
			if (args->hipGraphAddMemAllocNode.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemPoolProps poolProps = {\n");
				printf("\t\t\thipMemAllocationType allocType = %d\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.poolProps.allocType);
				printf("\t\t\thipMemAllocationHandleType handleTypes = %d\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.poolProps.handleTypes);
				printf("\t\t\thipMemLocation location = {\n");
				printf("\t\t\t\thipMemLocationType type = %d\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.poolProps.location.type);
				printf("\t\t\t\tint id = %d\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.poolProps.location.id);
				printf("\t\t\t}\n");
				printf("\t\t\tsize_t maxSize = %lu\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.poolProps.maxSize);
				printf("\t\t\tunsigned char[56] reserved = %hhu\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.poolProps.reserved[0]);
				printf("\t\t}\n");
				printf("\t\tsize_t accessDescCount = %lu\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.accessDescCount);
				printf("\t\tsize_t bytesize = %lu\n", args->hipGraphAddMemAllocNode.pNodeParams__ref.val.bytesize);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphAddMemAllocNode.retval);
			break;

		#endif
		#if HAVE_hipMemRetainAllocationHandle
		case HIP_API_ID_hipMemRetainAllocationHandle :
			//	hipMemGenericAllocationHandle_t * handle (struct ihipMemGenericAllocationHandle **);
			//	void * addr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemGenericAllocationHandle_t * handle = %p", args->hipMemRetainAllocationHandle.handle);
			if (args->hipMemRetainAllocationHandle.handle != NULL) {
				printf(" -> %p\n", args->hipMemRetainAllocationHandle.handle__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * addr = %p", args->hipMemRetainAllocationHandle.addr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemRetainAllocationHandle.retval);
			break;

		#endif
		#if HAVE_hipGetFuncBySymbol
		case HIP_API_ID_hipGetFuncBySymbol :
			//	hipFunction_t * functionPtr (struct ihipModuleSymbol_t **);
			//	const void * symbolPtr (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipFunction_t * functionPtr = %p", args->hipGetFuncBySymbol.functionPtr);
			if (args->hipGetFuncBySymbol.functionPtr != NULL) {
				printf(" -> %p\n", args->hipGetFuncBySymbol.functionPtr__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * symbolPtr = %p", args->hipGetFuncBySymbol.symbolPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetFuncBySymbol.retval);
			break;

		#endif
		#if HAVE_hipDeviceSetMemPool
		case HIP_API_ID_hipDeviceSetMemPool :
			//	int device (int);
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint device = %d\n", args->hipDeviceSetMemPool.device);
			printf("\thipMemPool_t mem_pool = %p", args->hipDeviceSetMemPool.mem_pool);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDeviceSetMemPool.retval);
			break;

		#endif
		#if HAVE_hipDeviceSetLimit
		case HIP_API_ID_hipDeviceSetLimit :
			//	enum hipLimit_t limit (enum hipLimit_t);
			//	size_t value (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tenum hipLimit_t limit = %d\n", args->hipDeviceSetLimit.limit);
			printf("\tsize_t value = %lu\n", args->hipDeviceSetLimit.value);
			printf("\thipError_t retval = %d\n", args->hipDeviceSetLimit.retval);
			break;

		#endif
		#if HAVE_hipMemGetInfo
		case HIP_API_ID_hipMemGetInfo :
			//	size_t * free (unsigned long*);
			//	size_t * total (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * free = %p", args->hipMemGetInfo.free);
			if (args->hipMemGetInfo.free != NULL) {
				printf(" -> %lu\n", args->hipMemGetInfo.free__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * total = %p", args->hipMemGetInfo.total);
			if (args->hipMemGetInfo.total != NULL) {
				printf(" -> %lu\n", args->hipMemGetInfo.total__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemGetInfo.retval);
			break;

		#endif
		#if HAVE_hipMemcpyParam2D
		case HIP_API_ID_hipMemcpyParam2D :
			//	const hip_Memcpy2D * pCopy ({
			//		size_t srcXInBytes (unsigned long);
			//		size_t srcY (unsigned long);
			//		hipMemoryType srcMemoryType (enum hipMemoryType);
			//		const void * srcHost (const void *);
			//		hipDeviceptr_t srcDevice (void *);
			//		hipArray_t srcArray (struct hipArray *);
			//		size_t srcPitch (unsigned long);
			//		size_t dstXInBytes (unsigned long);
			//		size_t dstY (unsigned long);
			//		hipMemoryType dstMemoryType (enum hipMemoryType);
			//		void * dstHost (void *);
			//		hipDeviceptr_t dstDevice (void *);
			//		hipArray_t dstArray (struct hipArray *);
			//		size_t dstPitch (unsigned long);
			//		size_t WidthInBytes (unsigned long);
			//		size_t Height (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst hip_Memcpy2D * pCopy = %p", args->hipMemcpyParam2D.pCopy);
			if (args->hipMemcpyParam2D.pCopy != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t srcXInBytes = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.srcXInBytes);
				printf("\t\tsize_t srcY = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.srcY);
				printf("\t\thipMemoryType srcMemoryType = %d\n", args->hipMemcpyParam2D.pCopy__ref.val.srcMemoryType);
				printf("\t\tsize_t srcPitch = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.srcPitch);
				printf("\t\tsize_t dstXInBytes = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.dstXInBytes);
				printf("\t\tsize_t dstY = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.dstY);
				printf("\t\thipMemoryType dstMemoryType = %d\n", args->hipMemcpyParam2D.pCopy__ref.val.dstMemoryType);
				printf("\t\tsize_t dstPitch = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.dstPitch);
				printf("\t\tsize_t WidthInBytes = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.WidthInBytes);
				printf("\t\tsize_t Height = %lu\n", args->hipMemcpyParam2D.pCopy__ref.val.Height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemcpyParam2D.retval);
			break;

		#endif
		#if HAVE_hipGraphDebugDotPrint
		case HIP_API_ID_hipGraphDebugDotPrint :
			//	hipGraph_t graph (struct ihipGraph *);
			//	const char * path (const char *);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphDebugDotPrint.graph);
			printf("\n");
			printf("\tconst char * path = %p", args->hipGraphDebugDotPrint.path);
			if (args->hipGraphDebugDotPrint.path != NULL) {
				printf(" -> %s\n", args->hipGraphDebugDotPrint.path__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned int flags = %u\n", args->hipGraphDebugDotPrint.flags);
			printf("\thipError_t retval = %d\n", args->hipGraphDebugDotPrint.retval);
			break;

		#endif
		#if HAVE_hipDeviceSetGraphMemAttribute
		case HIP_API_ID_hipDeviceSetGraphMemAttribute :
			//	int device (int);
			//	hipGraphMemAttributeType attr (enum hipGraphMemAttributeType);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint device = %d\n", args->hipDeviceSetGraphMemAttribute.device);
			printf("\thipGraphMemAttributeType attr = %d\n", args->hipDeviceSetGraphMemAttribute.attr);
			printf("\tvoid * value = %p", args->hipDeviceSetGraphMemAttribute.value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDeviceSetGraphMemAttribute.retval);
			break;

		#endif
		#if HAVE_hipDrvGetErrorString
		case HIP_API_ID_hipDrvGetErrorString :
			//	hipError_t hipError (enum hipError_t);
			//	const char ** errorString (const char **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t hipError = %d\n", args->hipDrvGetErrorString.hipError);
			printf("\tconst char ** errorString = %p", args->hipDrvGetErrorString.errorString);
			if (args->hipDrvGetErrorString.errorString != NULL) {
				printf("-> %p", args->hipDrvGetErrorString.errorString__ref.ptr1);
				if (args->hipDrvGetErrorString.errorString__ref.ptr1 != NULL) {
					printf(" -> %s\n", args->hipDrvGetErrorString.errorString__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDrvGetErrorString.retval);
			break;

		#endif
		#if HAVE_hipMemcpyDtoDAsync
		case HIP_API_ID_hipMemcpyDtoDAsync :
			//	hipDeviceptr_t dst (void *);
			//	hipDeviceptr_t src (void *);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dst = %p", args->hipMemcpyDtoDAsync.dst);
			printf("\n");
			printf("\thipDeviceptr_t src = %p", args->hipMemcpyDtoDAsync.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyDtoDAsync.sizeBytes);
			printf("\thipStream_t stream = %p", args->hipMemcpyDtoDAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpyDtoDAsync.retval);
			break;

		#endif
		#if HAVE_hipCtxSynchronize
		case HIP_API_ID_hipCtxSynchronize :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipCtxSynchronize.retval);
			break;

		#endif
		#if HAVE_hipTexObjectDestroy
		case HIP_API_ID_hipTexObjectDestroy :
			//	hipTextureObject_t texObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipTextureObject_t texObject = %p", args->hipTexObjectDestroy.texObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipTexObjectDestroy.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetAddressMode
		case HIP_API_ID_hipTexRefGetAddressMode :
			//	enum hipTextureAddressMode * pam (enum hipTextureAddressMode *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	int dim (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tenum hipTextureAddressMode * pam = %p", args->hipTexRefGetAddressMode.pam);
			if (args->hipTexRefGetAddressMode.pam != NULL) {
				printf(" -> %d\n", args->hipTexRefGetAddressMode.pam__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetAddressMode.texRef);
			if (args->hipTexRefGetAddressMode.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetAddressMode.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetAddressMode.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetAddressMode.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetAddressMode.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetAddressMode.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tint dim = %d\n", args->hipTexRefGetAddressMode.dim);
			printf("\thipError_t retval = %d\n", args->hipTexRefGetAddressMode.retval);
			break;

		#endif
		#if HAVE___hipGetPCH
		case HIP_API_ID___hipGetPCH :
			//	const char ** pch (const char **);
			//	unsigned int * size (unsigned int *);
			printf("\tconst char ** pch = %p", args->__hipGetPCH.pch);
			if (args->__hipGetPCH.pch != NULL) {
				printf("-> %p", args->__hipGetPCH.pch__ref.ptr1);
				if (args->__hipGetPCH.pch__ref.ptr1 != NULL) {
					printf(" -> %s\n", args->__hipGetPCH.pch__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tunsigned int * size = %p", args->__hipGetPCH.size);
			if (args->__hipGetPCH.size != NULL) {
				printf(" -> %u\n", args->__hipGetPCH.size__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipStreamGetFlags
		case HIP_API_ID_hipStreamGetFlags :
			//	hipStream_t stream (struct ihipStream_t *);
			//	unsigned int * flags (unsigned int *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetFlags.stream);
			printf("\n");
			printf("\tunsigned int * flags = %p", args->hipStreamGetFlags.flags);
			if (args->hipStreamGetFlags.flags != NULL) {
				printf(" -> %u\n", args->hipStreamGetFlags.flags__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetFlags.retval);
			break;

		#endif
		#if HAVE_hipMemGetAccess
		case HIP_API_ID_hipMemGetAccess :
			//	unsigned long long * flags (unsigned long long *);
			//	const hipMemLocation * location ({
			//		hipMemLocationType type (enum hipMemLocationType);
			//		int id (int);
			//	});
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned long long * flags = %p", args->hipMemGetAccess.flags);
			if (args->hipMemGetAccess.flags != NULL) {
				printf(" -> %llu\n", args->hipMemGetAccess.flags__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipMemLocation * location = %p", args->hipMemGetAccess.location);
			if (args->hipMemGetAccess.location != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemLocationType type = %d\n", args->hipMemGetAccess.location__ref.val.type);
				printf("\t\tint id = %d\n", args->hipMemGetAccess.location__ref.val.id);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tvoid * ptr = %p", args->hipMemGetAccess.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemGetAccess.retval);
			break;

		#endif
		#if HAVE_hipMemcpyAtoA
		case HIP_API_ID_hipMemcpyAtoA :
			//	hipArray_t dstArray (struct hipArray *);
			//	size_t dstOffset (unsigned long);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t ByteCount (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dstArray = %p", args->hipMemcpyAtoA.dstArray);
			printf("\n");
			printf("\tsize_t dstOffset = %lu\n", args->hipMemcpyAtoA.dstOffset);
			printf("\thipArray_t srcArray = %p", args->hipMemcpyAtoA.srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->hipMemcpyAtoA.srcOffset);
			printf("\tsize_t ByteCount = %lu\n", args->hipMemcpyAtoA.ByteCount);
			printf("\thipError_t retval = %d\n", args->hipMemcpyAtoA.retval);
			break;

		#endif
		#if HAVE_hipMemcpyToSymbol
		case HIP_API_ID_hipMemcpyToSymbol :
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * symbol = %p", args->hipMemcpyToSymbol.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpyToSymbol.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpyToSymbol.sizeBytes);
			printf("\tsize_t offset = %lu\n", args->hipMemcpyToSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyToSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyToSymbol.retval);
			break;

		#endif
		#if HAVE_hipCtxSetCurrent
		case HIP_API_ID_hipCtxSetCurrent :
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipCtx_t ctx = %p", args->hipCtxSetCurrent.ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipCtxSetCurrent.retval);
			break;

		#endif
		#if HAVE_hipStreamQuery_spt
		case HIP_API_ID_hipStreamQuery_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamQuery_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipStreamQuery_spt.retval);
			break;

		#endif
		#if HAVE_hipGetSymbolSize
		case HIP_API_ID_hipGetSymbolSize :
			//	size_t * size (unsigned long*);
			//	const void * symbol (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tsize_t * size = %p", args->hipGetSymbolSize.size);
			if (args->hipGetSymbolSize.size != NULL) {
				printf(" -> %lu\n", args->hipGetSymbolSize.size__ref.val);
			} else { printf("\n"); };
			printf("\tconst void * symbol = %p", args->hipGetSymbolSize.symbol);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetSymbolSize.retval);
			break;

		#endif
		#if HAVE_hipMipmappedArrayGetLevel
		case HIP_API_ID_hipMipmappedArrayGetLevel :
			//	hipArray_t * pLevelArray (struct hipArray **);
			//	hipMipmappedArray_t hMipMappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	unsigned int level (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * pLevelArray = %p", args->hipMipmappedArrayGetLevel.pLevelArray);
			if (args->hipMipmappedArrayGetLevel.pLevelArray != NULL) {
				printf(" -> %p\n", args->hipMipmappedArrayGetLevel.pLevelArray__ref.val);
			} else { printf("\n"); };
			printf("\thipMipmappedArray_t hMipMappedArray = %p", args->hipMipmappedArrayGetLevel.hMipMappedArray);
			if (args->hipMipmappedArrayGetLevel.hMipMappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hipMipmappedArrayGetLevel.hMipMappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int level = %u\n", args->hipMipmappedArrayGetLevel.level);
			printf("\thipError_t retval = %d\n", args->hipMipmappedArrayGetLevel.retval);
			break;

		#endif
		#if HAVE_hipExternalMemoryGetMappedMipmappedArray
		case HIP_API_ID_hipExternalMemoryGetMappedMipmappedArray :
			//	hipMipmappedArray_t * mipmap ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	hipExternalMemory_t extMem (void *);
			//	const hipExternalMemoryMipmappedArrayDesc * mipmapDesc ({
			//		unsigned long long offset (unsigned long long);
			//		hipChannelFormatDesc formatDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int numLevels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipMipmappedArray_t * mipmap = %p", args->hipExternalMemoryGetMappedMipmappedArray.mipmap);
			if (args->hipExternalMemoryGetMappedMipmappedArray.mipmap != NULL) {
				printf("-> %p", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.ptr1);
				if (args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmap__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipExternalMemory_t extMem = %p", args->hipExternalMemoryGetMappedMipmappedArray.extMem);
			printf("\n");
			printf("\tconst hipExternalMemoryMipmappedArrayDesc * mipmapDesc = %p", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc);
			if (args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned long long offset = %llu\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.offset);
				printf("\t\thipChannelFormatDesc formatDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.formatDesc.x);
				printf("\t\t\tint y = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.formatDesc.y);
				printf("\t\t\tint z = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.formatDesc.z);
				printf("\t\t\tint w = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.formatDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.formatDesc.f);
				printf("\t\t}\n");
				printf("\t\thipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.flags);
				printf("\t\tunsigned int numLevels = %u\n", args->hipExternalMemoryGetMappedMipmappedArray.mipmapDesc__ref.val.numLevels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipExternalMemoryGetMappedMipmappedArray.retval);
			break;

		#endif
		#if HAVE_hipGraphExecMemcpyNodeSetParams
		case HIP_API_ID_hipGraphExecMemcpyNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipMemcpy3DParms * pNodeParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecMemcpyNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t node = %p", args->hipGraphExecMemcpyNodeSetParams.node);
			printf("\n");
			printf("\thipMemcpy3DParms * pNodeParams = %p", args->hipGraphExecMemcpyNodeSetParams.pNodeParams);
			if (args->hipGraphExecMemcpyNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipGraphExecMemcpyNodeSetParams.pNodeParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecMemcpyNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipUserObjectCreate
		case HIP_API_ID_hipUserObjectCreate :
			//	hipUserObject_t * object_out (struct hipUserObject **);
			//	void * ptr (void *);
			//	hipHostFn_t destroy (void (*)(void *));
			//	unsigned int initialRefcount (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipUserObject_t * object_out = %p", args->hipUserObjectCreate.object_out);
			if (args->hipUserObjectCreate.object_out != NULL) {
				printf(" -> %p\n", args->hipUserObjectCreate.object_out__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * ptr = %p", args->hipUserObjectCreate.ptr);
			printf("\n");
			printf("\thipHostFn_t destroy = %p\n", args->hipUserObjectCreate.destroy);
			printf("\tunsigned int initialRefcount = %u\n", args->hipUserObjectCreate.initialRefcount);
			printf("\tunsigned int flags = %u\n", args->hipUserObjectCreate.flags);
			printf("\thipError_t retval = %d\n", args->hipUserObjectCreate.retval);
			break;

		#endif
		#if HAVE_hipStreamGetCaptureInfo_v2
		case HIP_API_ID_hipStreamGetCaptureInfo_v2 :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * captureStatus_out (enum hipStreamCaptureStatus*);
			//	unsigned long long * id_out (unsigned long long *);
			//	hipGraph_t * graph_out (struct ihipGraph **);
			//	const hipGraphNode_t ** dependencies_out (const struct hipGraphNode * **);
			//	size_t * numDependencies_out (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetCaptureInfo_v2.stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * captureStatus_out = %p", args->hipStreamGetCaptureInfo_v2.captureStatus_out);
			if (args->hipStreamGetCaptureInfo_v2.captureStatus_out != NULL) {
				printf(" -> %d\n", args->hipStreamGetCaptureInfo_v2.captureStatus_out__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * id_out = %p", args->hipStreamGetCaptureInfo_v2.id_out);
			if (args->hipStreamGetCaptureInfo_v2.id_out != NULL) {
				printf(" -> %llu\n", args->hipStreamGetCaptureInfo_v2.id_out__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t * graph_out = %p", args->hipStreamGetCaptureInfo_v2.graph_out);
			if (args->hipStreamGetCaptureInfo_v2.graph_out != NULL) {
				printf(" -> %p\n", args->hipStreamGetCaptureInfo_v2.graph_out__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t ** dependencies_out = %p", args->hipStreamGetCaptureInfo_v2.dependencies_out);
			if (args->hipStreamGetCaptureInfo_v2.dependencies_out != NULL) {
				printf("-> %p", args->hipStreamGetCaptureInfo_v2.dependencies_out__ref.ptr1);
				if (args->hipStreamGetCaptureInfo_v2.dependencies_out__ref.ptr1 != NULL) {
					printf(" -> %p\n", args->hipStreamGetCaptureInfo_v2.dependencies_out__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tsize_t * numDependencies_out = %p", args->hipStreamGetCaptureInfo_v2.numDependencies_out);
			if (args->hipStreamGetCaptureInfo_v2.numDependencies_out != NULL) {
				printf(" -> %lu\n", args->hipStreamGetCaptureInfo_v2.numDependencies_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetCaptureInfo_v2.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetArray
		case HIP_API_ID_hipTexRefGetArray :
			//	hipArray_t * pArray (struct hipArray **);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * pArray = %p", args->hipTexRefGetArray.pArray);
			if (args->hipTexRefGetArray.pArray != NULL) {
				printf(" -> %p\n", args->hipTexRefGetArray.pArray__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetArray.texRef);
			if (args->hipTexRefGetArray.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetArray.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetArray.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetArray.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetArray.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetArray.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetArray.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetArray.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetArray.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetArray.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetArray.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetArray.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetArray.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetArray.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetArray.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetArray.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetArray.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetArray.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetArray.retval);
			break;

		#endif
		#if HAVE_hipImportExternalSemaphore
		case HIP_API_ID_hipImportExternalSemaphore :
			//	hipExternalSemaphore_t * extSem_out (void **);
			//	const hipExternalSemaphoreHandleDesc * semHandleDesc ({
			//		hipExternalSemaphoreHandleType type (enum hipExternalSemaphoreHandleType_enum);
			//		union (unnamed union at header/hip/hip.h:1475:2) handle ({
			//		});
			//		unsigned int flags (unsigned int);
			//		unsigned int[16] reserved (unsigned int[16]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipExternalSemaphore_t * extSem_out = %p", args->hipImportExternalSemaphore.extSem_out);
			if (args->hipImportExternalSemaphore.extSem_out != NULL) {
				printf("-> %p", args->hipImportExternalSemaphore.extSem_out__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tconst hipExternalSemaphoreHandleDesc * semHandleDesc = %p", args->hipImportExternalSemaphore.semHandleDesc);
			if (args->hipImportExternalSemaphore.semHandleDesc != NULL) {
				printf(" -> {\n");
				printf("\t\thipExternalSemaphoreHandleType type = %d\n", args->hipImportExternalSemaphore.semHandleDesc__ref.val.type);
				printf("\t\tunion (unnamed union at header/hip/hip.h:1475:2) handle = {\n");
				printf("\t\t}\n");
				printf("\t\tunsigned int flags = %u\n", args->hipImportExternalSemaphore.semHandleDesc__ref.val.flags);
				printf("\t\tunsigned int[16] reserved = %u\n", args->hipImportExternalSemaphore.semHandleDesc__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipImportExternalSemaphore.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetAttribute
		case HIP_API_ID_hipDeviceGetAttribute :
			//	int * pi (int *);
			//	hipDeviceAttribute_t attr (enum hipDeviceAttribute_t);
			//	int deviceId (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * pi = %p", args->hipDeviceGetAttribute.pi);
			if (args->hipDeviceGetAttribute.pi != NULL) {
				printf(" -> %d\n", args->hipDeviceGetAttribute.pi__ref.val);
			} else { printf("\n"); };
			printf("\thipDeviceAttribute_t attr = %d\n", args->hipDeviceGetAttribute.attr);
			printf("\tint deviceId = %d\n", args->hipDeviceGetAttribute.deviceId);
			printf("\thipError_t retval = %d\n", args->hipDeviceGetAttribute.retval);
			break;

		#endif
		#if HAVE_hipGraphMemFreeNodeGetParams
		case HIP_API_ID_hipGraphMemFreeNodeGetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	void * dev_ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemFreeNodeGetParams.node);
			printf("\n");
			printf("\tvoid * dev_ptr = %p", args->hipGraphMemFreeNodeGetParams.dev_ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphMemFreeNodeGetParams.retval);
			break;

		#endif
		#if HAVE_hipCtxGetSharedMemConfig
		case HIP_API_ID_hipCtxGetSharedMemConfig :
			//	hipSharedMemConfig * pConfig (enum hipSharedMemConfig*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipSharedMemConfig * pConfig = %p", args->hipCtxGetSharedMemConfig.pConfig);
			if (args->hipCtxGetSharedMemConfig.pConfig != NULL) {
				printf(" -> %d\n", args->hipCtxGetSharedMemConfig.pConfig__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxGetSharedMemConfig.retval);
			break;

		#endif
		#if HAVE_hipGraphMemcpyNodeSetParamsToSymbol
		case HIP_API_ID_hipGraphMemcpyNodeSetParamsToSymbol :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const void * symbol (const void *);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	size_t offset (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemcpyNodeSetParamsToSymbol.node);
			printf("\n");
			printf("\tconst void * symbol = %p", args->hipGraphMemcpyNodeSetParamsToSymbol.symbol);
			printf("\n");
			printf("\tconst void * src = %p", args->hipGraphMemcpyNodeSetParamsToSymbol.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipGraphMemcpyNodeSetParamsToSymbol.count);
			printf("\tsize_t offset = %lu\n", args->hipGraphMemcpyNodeSetParamsToSymbol.offset);
			printf("\thipMemcpyKind kind = %d\n", args->hipGraphMemcpyNodeSetParamsToSymbol.kind);
			printf("\thipError_t retval = %d\n", args->hipGraphMemcpyNodeSetParamsToSymbol.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DToArray
		case HIP_API_ID_hipMemcpy2DToArray :
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dst = %p", args->hipMemcpy2DToArray.dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpy2DToArray.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpy2DToArray.hOffset);
			printf("\tconst void * src = %p", args->hipMemcpy2DToArray.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2DToArray.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DToArray.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DToArray.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DToArray.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DToArray.retval);
			break;

		#endif
		#if HAVE_hipStreamIsCapturing_spt
		case HIP_API_ID_hipStreamIsCapturing_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * pCaptureStatus (enum hipStreamCaptureStatus*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamIsCapturing_spt.stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * pCaptureStatus = %p", args->hipStreamIsCapturing_spt.pCaptureStatus);
			if (args->hipStreamIsCapturing_spt.pCaptureStatus != NULL) {
				printf(" -> %d\n", args->hipStreamIsCapturing_spt.pCaptureStatus__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamIsCapturing_spt.retval);
			break;

		#endif
		#if HAVE_hipFreeHost
		case HIP_API_ID_hipFreeHost :
			//	void * ptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * ptr = %p", args->hipFreeHost.ptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipFreeHost.retval);
			break;

		#endif
		#if HAVE_hipGraphKernelNodeSetParams
		case HIP_API_ID_hipGraphKernelNodeSetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipKernelNodeParams * pNodeParams ({
			//		dim3 blockDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** extra (void **);
			//		void * func (void *);
			//		dim3 gridDim ({
			//			uint32_t x (unsigned int);
			//			uint32_t y (unsigned int);
			//			uint32_t z (unsigned int);
			//		});
			//		void ** kernelParams (void **);
			//		unsigned int sharedMemBytes (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphKernelNodeSetParams.node);
			printf("\n");
			printf("\tconst hipKernelNodeParams * pNodeParams = %p", args->hipGraphKernelNodeSetParams.pNodeParams);
			if (args->hipGraphKernelNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tdim3 blockDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.blockDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.blockDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.blockDim.z);
				printf("\t\t}\n");
				printf("\t\tdim3 gridDim = {\n");
				printf("\t\t\tuint32_t x = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.gridDim.x);
				printf("\t\t\tuint32_t y = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.gridDim.y);
				printf("\t\t\tuint32_t z = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.gridDim.z);
				printf("\t\t}\n");
				printf("\t\tunsigned int sharedMemBytes = %u\n", args->hipGraphKernelNodeSetParams.pNodeParams__ref.val.sharedMemBytes);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphKernelNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipMallocHost
		case HIP_API_ID_hipMallocHost :
			//	void ** ptr (void **);
			//	size_t size (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipMallocHost.ptr);
			if (args->hipMallocHost.ptr != NULL) {
				printf("-> %p", args->hipMallocHost.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t size = %lu\n", args->hipMallocHost.size);
			printf("\thipError_t retval = %d\n", args->hipMallocHost.retval);
			break;

		#endif
		#if HAVE_hipMemset3D_spt
		case HIP_API_ID_hipMemset3D_spt :
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->hipMemset3D_spt.pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->hipMemset3D_spt.pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->hipMemset3D_spt.pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->hipMemset3D_spt.value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMemset3D_spt.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMemset3D_spt.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMemset3D_spt.extent.depth);
			printf("\t}\n");
			printf("\thipError_t retval = %d\n", args->hipMemset3D_spt.retval);
			break;

		#endif
		#if HAVE_hipStreamGetCaptureInfo_v2_spt
		case HIP_API_ID_hipStreamGetCaptureInfo_v2_spt :
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipStreamCaptureStatus * captureStatus_out (enum hipStreamCaptureStatus*);
			//	unsigned long long * id_out (unsigned long long *);
			//	hipGraph_t * graph_out (struct ihipGraph **);
			//	const hipGraphNode_t ** dependencies_out (const struct hipGraphNode * **);
			//	size_t * numDependencies_out (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamGetCaptureInfo_v2_spt.stream);
			printf("\n");
			printf("\thipStreamCaptureStatus * captureStatus_out = %p", args->hipStreamGetCaptureInfo_v2_spt.captureStatus_out);
			if (args->hipStreamGetCaptureInfo_v2_spt.captureStatus_out != NULL) {
				printf(" -> %d\n", args->hipStreamGetCaptureInfo_v2_spt.captureStatus_out__ref.val);
			} else { printf("\n"); };
			printf("\tunsigned long long * id_out = %p", args->hipStreamGetCaptureInfo_v2_spt.id_out);
			if (args->hipStreamGetCaptureInfo_v2_spt.id_out != NULL) {
				printf(" -> %llu\n", args->hipStreamGetCaptureInfo_v2_spt.id_out__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t * graph_out = %p", args->hipStreamGetCaptureInfo_v2_spt.graph_out);
			if (args->hipStreamGetCaptureInfo_v2_spt.graph_out != NULL) {
				printf(" -> %p\n", args->hipStreamGetCaptureInfo_v2_spt.graph_out__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t ** dependencies_out = %p", args->hipStreamGetCaptureInfo_v2_spt.dependencies_out);
			if (args->hipStreamGetCaptureInfo_v2_spt.dependencies_out != NULL) {
				printf("-> %p", args->hipStreamGetCaptureInfo_v2_spt.dependencies_out__ref.ptr1);
				if (args->hipStreamGetCaptureInfo_v2_spt.dependencies_out__ref.ptr1 != NULL) {
					printf(" -> %p\n", args->hipStreamGetCaptureInfo_v2_spt.dependencies_out__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tsize_t * numDependencies_out = %p", args->hipStreamGetCaptureInfo_v2_spt.numDependencies_out);
			if (args->hipStreamGetCaptureInfo_v2_spt.numDependencies_out != NULL) {
				printf(" -> %lu\n", args->hipStreamGetCaptureInfo_v2_spt.numDependencies_out__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipStreamGetCaptureInfo_v2_spt.retval);
			break;

		#endif
		#if HAVE_hipGetTextureReference
		case HIP_API_ID_hipGetTextureReference :
			//	const textureReference ** texref ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	const void * symbol (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst textureReference ** texref = %p", args->hipGetTextureReference.texref);
			if (args->hipGetTextureReference.texref != NULL) {
				printf("-> %p", args->hipGetTextureReference.texref__ref.ptr1);
				if (args->hipGetTextureReference.texref__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tint normalized = %d\n", args->hipGetTextureReference.texref__ref.val.normalized);
					printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipGetTextureReference.texref__ref.val.readMode);
					printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipGetTextureReference.texref__ref.val.filterMode);
					printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipGetTextureReference.texref__ref.val.addressMode[0]);
					printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
					printf("\t\t\tint x = %d\n", args->hipGetTextureReference.texref__ref.val.channelDesc.x);
					printf("\t\t\tint y = %d\n", args->hipGetTextureReference.texref__ref.val.channelDesc.y);
					printf("\t\t\tint z = %d\n", args->hipGetTextureReference.texref__ref.val.channelDesc.z);
					printf("\t\t\tint w = %d\n", args->hipGetTextureReference.texref__ref.val.channelDesc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipGetTextureReference.texref__ref.val.channelDesc.f);
					printf("\t\t}\n");
					printf("\t\tint sRGB = %d\n", args->hipGetTextureReference.texref__ref.val.sRGB);
					printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipGetTextureReference.texref__ref.val.maxAnisotropy);
					printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipGetTextureReference.texref__ref.val.mipmapFilterMode);
					printf("\t\tfloat mipmapLevelBias = %f\n", args->hipGetTextureReference.texref__ref.val.mipmapLevelBias);
					printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipGetTextureReference.texref__ref.val.minMipmapLevelClamp);
					printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipGetTextureReference.texref__ref.val.maxMipmapLevelClamp);
					printf("\t\tint numChannels = %d\n", args->hipGetTextureReference.texref__ref.val.numChannels);
					printf("\t\tenum hipArray_Format format = %d\n", args->hipGetTextureReference.texref__ref.val.format);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tconst void * symbol = %p", args->hipGetTextureReference.symbol);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetTextureReference.retval);
			break;

		#endif
		#if HAVE_hipGraphExecExternalSemaphoresSignalNodeSetParams
		case HIP_API_ID_hipGraphExecExternalSemaphoresSignalNodeSetParams :
			//	hipGraphExec_t hGraphExec (struct hipGraphExec *);
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	const hipExternalSemaphoreSignalNodeParams * nodeParams ({
			//		hipExternalSemaphore_t * extSemArray (void **);
			//		unsigned int numExtSems (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t hGraphExec = %p", args->hipGraphExecExternalSemaphoresSignalNodeSetParams.hGraphExec);
			printf("\n");
			printf("\thipGraphNode_t hNode = %p", args->hipGraphExecExternalSemaphoresSignalNodeSetParams.hNode);
			printf("\n");
			printf("\tconst hipExternalSemaphoreSignalNodeParams * nodeParams = %p", args->hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams);
			if (args->hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tunsigned int numExtSems = %u\n", args->hipGraphExecExternalSemaphoresSignalNodeSetParams.nodeParams__ref.val.numExtSems);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphExecExternalSemaphoresSignalNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipGraphAddDependencies
		case HIP_API_ID_hipGraphAddDependencies :
			//	hipGraph_t graph (struct ihipGraph *);
			//	const hipGraphNode_t * from (const struct hipGraphNode * *);
			//	const hipGraphNode_t * to (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphAddDependencies.graph);
			printf("\n");
			printf("\tconst hipGraphNode_t * from = %p", args->hipGraphAddDependencies.from);
			if (args->hipGraphAddDependencies.from != NULL) {
				printf(" -> %p\n", args->hipGraphAddDependencies.from__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipGraphNode_t * to = %p", args->hipGraphAddDependencies.to);
			if (args->hipGraphAddDependencies.to != NULL) {
				printf(" -> %p\n", args->hipGraphAddDependencies.to__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipGraphAddDependencies.numDependencies);
			printf("\thipError_t retval = %d\n", args->hipGraphAddDependencies.retval);
			break;

		#endif
		#if HAVE_hipGraphNodeGetType
		case HIP_API_ID_hipGraphNodeGetType :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	hipGraphNodeType * pType (enum hipGraphNodeType*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphNodeGetType.node);
			printf("\n");
			printf("\thipGraphNodeType * pType = %p", args->hipGraphNodeGetType.pType);
			if (args->hipGraphNodeGetType.pType != NULL) {
				printf(" -> %d\n", args->hipGraphNodeGetType.pType__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphNodeGetType.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetBorderColor
		case HIP_API_ID_hipTexRefSetBorderColor :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	float * pBorderColor (float *);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetBorderColor.texRef);
			if (args->hipTexRefSetBorderColor.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetBorderColor.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetBorderColor.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetBorderColor.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetBorderColor.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetBorderColor.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tfloat * pBorderColor = %p", args->hipTexRefSetBorderColor.pBorderColor);
			if (args->hipTexRefSetBorderColor.pBorderColor != NULL) {
				printf(" -> %f\n", args->hipTexRefSetBorderColor.pBorderColor__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefSetBorderColor.retval);
			break;

		#endif
		#if HAVE_hipMemPrefetchAsync
		case HIP_API_ID_hipMemPrefetchAsync :
			//	const void * dev_ptr (const void *);
			//	size_t count (unsigned long);
			//	int device (int);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * dev_ptr = %p", args->hipMemPrefetchAsync.dev_ptr);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipMemPrefetchAsync.count);
			printf("\tint device = %d\n", args->hipMemPrefetchAsync.device);
			printf("\thipStream_t stream = %p", args->hipMemPrefetchAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemPrefetchAsync.retval);
			break;

		#endif
		#if HAVE_hipCtxGetDevice
		case HIP_API_ID_hipCtxGetDevice :
			//	hipDevice_t * device (int*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDevice_t * device = %p", args->hipCtxGetDevice.device);
			if (args->hipCtxGetDevice.device != NULL) {
				printf(" -> %d\n", args->hipCtxGetDevice.device__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCtxGetDevice.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2DArrayToArray
		case HIP_API_ID_hipMemcpy2DArrayToArray :
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffsetDst (unsigned long);
			//	size_t hOffsetDst (unsigned long);
			//	hipArray_const_t src (const struct hipArray *);
			//	size_t wOffsetSrc (unsigned long);
			//	size_t hOffsetSrc (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dst = %p", args->hipMemcpy2DArrayToArray.dst);
			printf("\n");
			printf("\tsize_t wOffsetDst = %lu\n", args->hipMemcpy2DArrayToArray.wOffsetDst);
			printf("\tsize_t hOffsetDst = %lu\n", args->hipMemcpy2DArrayToArray.hOffsetDst);
			printf("\thipArray_const_t src = %p", args->hipMemcpy2DArrayToArray.src);
			printf("\n");
			printf("\tsize_t wOffsetSrc = %lu\n", args->hipMemcpy2DArrayToArray.wOffsetSrc);
			printf("\tsize_t hOffsetSrc = %lu\n", args->hipMemcpy2DArrayToArray.hOffsetSrc);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2DArrayToArray.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2DArrayToArray.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2DArrayToArray.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2DArrayToArray.retval);
			break;

		#endif
		#if HAVE_hipUserObjectRelease
		case HIP_API_ID_hipUserObjectRelease :
			//	hipUserObject_t object (struct hipUserObject *);
			//	unsigned int count (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipUserObject_t object = %p", args->hipUserObjectRelease.object);
			printf("\n");
			printf("\tunsigned int count = %u\n", args->hipUserObjectRelease.count);
			printf("\thipError_t retval = %d\n", args->hipUserObjectRelease.retval);
			break;

		#endif
		#if HAVE_hipHostGetFlags
		case HIP_API_ID_hipHostGetFlags :
			//	unsigned int * flagsPtr (unsigned int *);
			//	void * hostPtr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tunsigned int * flagsPtr = %p", args->hipHostGetFlags.flagsPtr);
			if (args->hipHostGetFlags.flagsPtr != NULL) {
				printf(" -> %u\n", args->hipHostGetFlags.flagsPtr__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * hostPtr = %p", args->hipHostGetFlags.hostPtr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipHostGetFlags.retval);
			break;

		#endif
		#if HAVE_hipDrvGraphAddMemsetNode
		case HIP_API_ID_hipDrvGraphAddMemsetNode :
			//	hipGraphNode_t * phGraphNode (struct hipGraphNode **);
			//	hipGraph_t hGraph (struct ihipGraph *);
			//	const hipGraphNode_t * dependencies (const struct hipGraphNode * *);
			//	size_t numDependencies (unsigned long);
			//	const HIP_MEMSET_NODE_PARAMS * memsetParams ({
			//		hipDeviceptr_t dst (void *);
			//		size_t pitch (unsigned long);
			//		unsigned int value (unsigned int);
			//		unsigned int elementSize (unsigned int);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//	});
			//	hipCtx_t ctx (struct ihipCtx_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t * phGraphNode = %p", args->hipDrvGraphAddMemsetNode.phGraphNode);
			if (args->hipDrvGraphAddMemsetNode.phGraphNode != NULL) {
				printf(" -> %p\n", args->hipDrvGraphAddMemsetNode.phGraphNode__ref.val);
			} else { printf("\n"); };
			printf("\thipGraph_t hGraph = %p", args->hipDrvGraphAddMemsetNode.hGraph);
			printf("\n");
			printf("\tconst hipGraphNode_t * dependencies = %p", args->hipDrvGraphAddMemsetNode.dependencies);
			if (args->hipDrvGraphAddMemsetNode.dependencies != NULL) {
				printf(" -> %p\n", args->hipDrvGraphAddMemsetNode.dependencies__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t numDependencies = %lu\n", args->hipDrvGraphAddMemsetNode.numDependencies);
			printf("\tconst HIP_MEMSET_NODE_PARAMS * memsetParams = %p", args->hipDrvGraphAddMemsetNode.memsetParams);
			if (args->hipDrvGraphAddMemsetNode.memsetParams != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t pitch = %lu\n", args->hipDrvGraphAddMemsetNode.memsetParams__ref.val.pitch);
				printf("\t\tunsigned int value = %u\n", args->hipDrvGraphAddMemsetNode.memsetParams__ref.val.value);
				printf("\t\tunsigned int elementSize = %u\n", args->hipDrvGraphAddMemsetNode.memsetParams__ref.val.elementSize);
				printf("\t\tsize_t width = %lu\n", args->hipDrvGraphAddMemsetNode.memsetParams__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->hipDrvGraphAddMemsetNode.memsetParams__ref.val.height);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipCtx_t ctx = %p", args->hipDrvGraphAddMemsetNode.ctx);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDrvGraphAddMemsetNode.retval);
			break;

		#endif
		#if HAVE_hipMemcpyAtoD
		case HIP_API_ID_hipMemcpyAtoD :
			//	hipDeviceptr_t dstDevice (void *);
			//	hipArray_t srcArray (struct hipArray *);
			//	size_t srcOffset (unsigned long);
			//	size_t ByteCount (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dstDevice = %p", args->hipMemcpyAtoD.dstDevice);
			printf("\n");
			printf("\thipArray_t srcArray = %p", args->hipMemcpyAtoD.srcArray);
			printf("\n");
			printf("\tsize_t srcOffset = %lu\n", args->hipMemcpyAtoD.srcOffset);
			printf("\tsize_t ByteCount = %lu\n", args->hipMemcpyAtoD.ByteCount);
			printf("\thipError_t retval = %d\n", args->hipMemcpyAtoD.retval);
			break;

		#endif
		#if HAVE_hipMemPoolCreate
		case HIP_API_ID_hipMemPoolCreate :
			//	hipMemPool_t * mem_pool (struct ihipMemPoolHandle_t **);
			//	const hipMemPoolProps * pool_props ({
			//		hipMemAllocationType allocType (enum hipMemAllocationType);
			//		hipMemAllocationHandleType handleTypes (enum hipMemAllocationHandleType);
			//		hipMemLocation location ({
			//			hipMemLocationType type (enum hipMemLocationType);
			//			int id (int);
			//		});
			//		void * win32SecurityAttributes (void *);
			//		size_t maxSize (unsigned long);
			//		unsigned char[56] reserved (unsigned char[56]);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t * mem_pool = %p", args->hipMemPoolCreate.mem_pool);
			if (args->hipMemPoolCreate.mem_pool != NULL) {
				printf(" -> %p\n", args->hipMemPoolCreate.mem_pool__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipMemPoolProps * pool_props = %p", args->hipMemPoolCreate.pool_props);
			if (args->hipMemPoolCreate.pool_props != NULL) {
				printf(" -> {\n");
				printf("\t\thipMemAllocationType allocType = %d\n", args->hipMemPoolCreate.pool_props__ref.val.allocType);
				printf("\t\thipMemAllocationHandleType handleTypes = %d\n", args->hipMemPoolCreate.pool_props__ref.val.handleTypes);
				printf("\t\thipMemLocation location = {\n");
				printf("\t\t\thipMemLocationType type = %d\n", args->hipMemPoolCreate.pool_props__ref.val.location.type);
				printf("\t\t\tint id = %d\n", args->hipMemPoolCreate.pool_props__ref.val.location.id);
				printf("\t\t}\n");
				printf("\t\tsize_t maxSize = %lu\n", args->hipMemPoolCreate.pool_props__ref.val.maxSize);
				printf("\t\tunsigned char[56] reserved = %hhu\n", args->hipMemPoolCreate.pool_props__ref.val.reserved[0]);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMemPoolCreate.retval);
			break;

		#endif
		#if HAVE_hipKernelNameRef
		case HIP_API_ID_hipKernelNameRef :
			//	const hipFunction_t f (const struct ihipModuleSymbol_t *);
			//	const char * retval (const char *);
			printf("\tconst hipFunction_t f = %p", args->hipKernelNameRef.f);
			printf("\n");
			printf("\tconst char * retval = %p", args->hipKernelNameRef.retval);
			if (args->hipKernelNameRef.retval != NULL) {
				printf(" -> %s\n", args->hipKernelNameRef.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipMemset3DAsync
		case HIP_API_ID_hipMemset3DAsync :
			//	hipPitchedPtr pitchedDevPtr ({
			//		void * ptr (void *);
			//		size_t pitch (unsigned long);
			//		size_t xsize (unsigned long);
			//		size_t ysize (unsigned long);
			//	});
			//	int value (int);
			//	hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipPitchedPtr pitchedDevPtr = {\n");
			printf("\t\tsize_t pitch = %lu\n", args->hipMemset3DAsync.pitchedDevPtr.pitch);
			printf("\t\tsize_t xsize = %lu\n", args->hipMemset3DAsync.pitchedDevPtr.xsize);
			printf("\t\tsize_t ysize = %lu\n", args->hipMemset3DAsync.pitchedDevPtr.ysize);
			printf("\t}\n");
			printf("\tint value = %d\n", args->hipMemset3DAsync.value);
			printf("\thipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMemset3DAsync.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMemset3DAsync.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMemset3DAsync.extent.depth);
			printf("\t}\n");
			printf("\thipStream_t stream = %p", args->hipMemset3DAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemset3DAsync.retval);
			break;

		#endif
		#if HAVE_hipEventRecord
		case HIP_API_ID_hipEventRecord :
			//	hipEvent_t event (struct ihipEvent_t *);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipEvent_t event = %p", args->hipEventRecord.event);
			printf("\n");
			printf("\thipStream_t stream = %p", args->hipEventRecord.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipEventRecord.retval);
			break;

		#endif
		#if HAVE_hipMipmappedArrayDestroy
		case HIP_API_ID_hipMipmappedArrayDestroy :
			//	hipMipmappedArray_t hMipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipMipmappedArray_t hMipmappedArray = %p", args->hipMipmappedArrayDestroy.hMipmappedArray);
			if (args->hipMipmappedArrayDestroy.hMipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hipMipmappedArrayDestroy.hMipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipMipmappedArrayDestroy.retval);
			break;

		#endif
		#if HAVE_hipMemsetAsync_spt
		case HIP_API_ID_hipMemsetAsync_spt :
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemsetAsync_spt.dst);
			printf("\n");
			printf("\tint value = %d\n", args->hipMemsetAsync_spt.value);
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemsetAsync_spt.sizeBytes);
			printf("\thipStream_t stream = %p", args->hipMemsetAsync_spt.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemsetAsync_spt.retval);
			break;

		#endif
		#if HAVE_hipDevicePrimaryCtxSetFlags
		case HIP_API_ID_hipDevicePrimaryCtxSetFlags :
			//	hipDevice_t dev (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDevice_t dev = %d\n", args->hipDevicePrimaryCtxSetFlags.dev);
			printf("\tunsigned int flags = %u\n", args->hipDevicePrimaryCtxSetFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipDevicePrimaryCtxSetFlags.retval);
			break;

		#endif
		#if HAVE_hipPeekAtLastError
		case HIP_API_ID_hipPeekAtLastError :
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t retval = %d\n", args->hipPeekAtLastError.retval);
			break;

		#endif
		#if HAVE_hipDeviceGetGraphMemAttribute
		case HIP_API_ID_hipDeviceGetGraphMemAttribute :
			//	int device (int);
			//	hipGraphMemAttributeType attr (enum hipGraphMemAttributeType);
			//	void * value (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint device = %d\n", args->hipDeviceGetGraphMemAttribute.device);
			printf("\thipGraphMemAttributeType attr = %d\n", args->hipDeviceGetGraphMemAttribute.attr);
			printf("\tvoid * value = %p", args->hipDeviceGetGraphMemAttribute.value);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipDeviceGetGraphMemAttribute.retval);
			break;

		#endif
		#if HAVE_hipDrvGetErrorName
		case HIP_API_ID_hipDrvGetErrorName :
			//	hipError_t hipError (enum hipError_t);
			//	const char ** errorString (const char **);
			//	hipError_t retval (enum hipError_t);
			printf("\thipError_t hipError = %d\n", args->hipDrvGetErrorName.hipError);
			printf("\tconst char ** errorString = %p", args->hipDrvGetErrorName.errorString);
			if (args->hipDrvGetErrorName.errorString != NULL) {
				printf("-> %p", args->hipDrvGetErrorName.errorString__ref.ptr1);
				if (args->hipDrvGetErrorName.errorString__ref.ptr1 != NULL) {
					printf(" -> %s\n", args->hipDrvGetErrorName.errorString__ref.val);
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDrvGetErrorName.retval);
			break;

		#endif
		#if HAVE_hipMemcpy_spt
		case HIP_API_ID_hipMemcpy_spt :
			//	void * dst (void *);
			//	const void * src (const void *);
			//	size_t sizeBytes (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy_spt.dst);
			printf("\n");
			printf("\tconst void * src = %p", args->hipMemcpy_spt.src);
			printf("\n");
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemcpy_spt.sizeBytes);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy_spt.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy_spt.retval);
			break;

		#endif
		#if HAVE_hipCtxSetSharedMemConfig
		case HIP_API_ID_hipCtxSetSharedMemConfig :
			//	hipSharedMemConfig config (enum hipSharedMemConfig);
			//	hipError_t retval (enum hipError_t);
			printf("\thipSharedMemConfig config = %d\n", args->hipCtxSetSharedMemConfig.config);
			printf("\thipError_t retval = %d\n", args->hipCtxSetSharedMemConfig.retval);
			break;

		#endif
		#if HAVE_hipCreateSurfaceObject
		case HIP_API_ID_hipCreateSurfaceObject :
			//	hipSurfaceObject_t * pSurfObject (struct __hip_surface **);
			//	const hipResourceDesc * pResDesc ({
			//		enum hipResourceType resType (enum hipResourceType);
			//		union (unnamed union at header/hip/hip.h:612:2) res ({
			//		});
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipSurfaceObject_t * pSurfObject = %p", args->hipCreateSurfaceObject.pSurfObject);
			if (args->hipCreateSurfaceObject.pSurfObject != NULL) {
				printf(" -> %p\n", args->hipCreateSurfaceObject.pSurfObject__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipResourceDesc * pResDesc = %p", args->hipCreateSurfaceObject.pResDesc);
			if (args->hipCreateSurfaceObject.pResDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceType resType = %d\n", args->hipCreateSurfaceObject.pResDesc__ref.val.resType);
				printf("\t\tunion (unnamed union at header/hip/hip.h:612:2) res = {\n");
				printf("\t\t}\n");
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipCreateSurfaceObject.retval);
			break;

		#endif
		#if HAVE_hipGetMipmappedArrayLevel
		case HIP_API_ID_hipGetMipmappedArrayLevel :
			//	hipArray_t * levelArray (struct hipArray **);
			//	hipMipmappedArray_const_t mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	unsigned int level (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * levelArray = %p", args->hipGetMipmappedArrayLevel.levelArray);
			if (args->hipGetMipmappedArrayLevel.levelArray != NULL) {
				printf(" -> %p\n", args->hipGetMipmappedArrayLevel.levelArray__ref.val);
			} else { printf("\n"); };
			printf("\thipMipmappedArray_const_t mipmappedArray = %p", args->hipGetMipmappedArrayLevel.mipmappedArray);
			if (args->hipGetMipmappedArrayLevel.mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hipGetMipmappedArrayLevel.mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int level = %u\n", args->hipGetMipmappedArrayLevel.level);
			printf("\thipError_t retval = %d\n", args->hipGetMipmappedArrayLevel.retval);
			break;

		#endif
		#if HAVE_hipGraphExecDestroy
		case HIP_API_ID_hipGraphExecDestroy :
			//	hipGraphExec_t graphExec (struct hipGraphExec *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphExec_t graphExec = %p", args->hipGraphExecDestroy.graphExec);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphExecDestroy.retval);
			break;

		#endif
		#if HAVE_hipMemsetD32Async
		case HIP_API_ID_hipMemsetD32Async :
			//	hipDeviceptr_t dst (void *);
			//	int value (int);
			//	size_t count (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t dst = %p", args->hipMemsetD32Async.dst);
			printf("\n");
			printf("\tint value = %d\n", args->hipMemsetD32Async.value);
			printf("\tsize_t count = %lu\n", args->hipMemsetD32Async.count);
			printf("\thipStream_t stream = %p", args->hipMemsetD32Async.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemsetD32Async.retval);
			break;

		#endif
		#if HAVE_hipDeviceEnablePeerAccess
		case HIP_API_ID_hipDeviceEnablePeerAccess :
			//	int peerDeviceId (int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tint peerDeviceId = %d\n", args->hipDeviceEnablePeerAccess.peerDeviceId);
			printf("\tunsigned int flags = %u\n", args->hipDeviceEnablePeerAccess.flags);
			printf("\thipError_t retval = %d\n", args->hipDeviceEnablePeerAccess.retval);
			break;

		#endif
		#if HAVE_hipArray3DCreate
		case HIP_API_ID_hipArray3DCreate :
			//	hipArray_t * array (struct hipArray **);
			//	const HIP_ARRAY3D_DESCRIPTOR * pAllocateArray ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		size_t Depth (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//		unsigned int Flags (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * array = %p", args->hipArray3DCreate.array);
			if (args->hipArray3DCreate.array != NULL) {
				printf(" -> %p\n", args->hipArray3DCreate.array__ref.val);
			} else { printf("\n"); };
			printf("\tconst HIP_ARRAY3D_DESCRIPTOR * pAllocateArray = %p", args->hipArray3DCreate.pAllocateArray);
			if (args->hipArray3DCreate.pAllocateArray != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->hipArray3DCreate.pAllocateArray__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->hipArray3DCreate.pAllocateArray__ref.val.Height);
				printf("\t\tsize_t Depth = %lu\n", args->hipArray3DCreate.pAllocateArray__ref.val.Depth);
				printf("\t\tenum hipArray_Format Format = %d\n", args->hipArray3DCreate.pAllocateArray__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->hipArray3DCreate.pAllocateArray__ref.val.NumChannels);
				printf("\t\tunsigned int Flags = %u\n", args->hipArray3DCreate.pAllocateArray__ref.val.Flags);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipArray3DCreate.retval);
			break;

		#endif
		#if HAVE_hipIpcOpenMemHandle
		case HIP_API_ID_hipIpcOpenMemHandle :
			//	void ** devPtr (void **);
			//	hipIpcMemHandle_t handle ({
			//		char[64] reserved (char[64]);
			//	});
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** devPtr = %p", args->hipIpcOpenMemHandle.devPtr);
			if (args->hipIpcOpenMemHandle.devPtr != NULL) {
				printf("-> %p", args->hipIpcOpenMemHandle.devPtr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\thipIpcMemHandle_t handle = {\n");
			printf("\t\tchar[64] reserved = %c\n", args->hipIpcOpenMemHandle.handle.reserved[0]);
			printf("\t}\n");
			printf("\tunsigned int flags = %u\n", args->hipIpcOpenMemHandle.flags);
			printf("\thipError_t retval = %d\n", args->hipIpcOpenMemHandle.retval);
			break;

		#endif
		#if HAVE_hipMemPoolTrimTo
		case HIP_API_ID_hipMemPoolTrimTo :
			//	hipMemPool_t mem_pool (struct ihipMemPoolHandle_t *);
			//	size_t min_bytes_to_hold (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemPool_t mem_pool = %p", args->hipMemPoolTrimTo.mem_pool);
			printf("\n");
			printf("\tsize_t min_bytes_to_hold = %lu\n", args->hipMemPoolTrimTo.min_bytes_to_hold);
			printf("\thipError_t retval = %d\n", args->hipMemPoolTrimTo.retval);
			break;

		#endif
		#if HAVE_hipMemcpy2D
		case HIP_API_ID_hipMemcpy2D :
			//	void * dst (void *);
			//	size_t dpitch (unsigned long);
			//	const void * src (const void *);
			//	size_t spitch (unsigned long);
			//	size_t width (unsigned long);
			//	size_t height (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemcpy2D.dst);
			printf("\n");
			printf("\tsize_t dpitch = %lu\n", args->hipMemcpy2D.dpitch);
			printf("\tconst void * src = %p", args->hipMemcpy2D.src);
			printf("\n");
			printf("\tsize_t spitch = %lu\n", args->hipMemcpy2D.spitch);
			printf("\tsize_t width = %lu\n", args->hipMemcpy2D.width);
			printf("\tsize_t height = %lu\n", args->hipMemcpy2D.height);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpy2D.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpy2D.retval);
			break;

		#endif
		#if HAVE_hipFuncGetAttribute
		case HIP_API_ID_hipFuncGetAttribute :
			//	int * value (int *);
			//	hipFunction_attribute attrib (enum hipFunction_attribute);
			//	hipFunction_t hfunc (struct ihipModuleSymbol_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * value = %p", args->hipFuncGetAttribute.value);
			if (args->hipFuncGetAttribute.value != NULL) {
				printf(" -> %d\n", args->hipFuncGetAttribute.value__ref.val);
			} else { printf("\n"); };
			printf("\thipFunction_attribute attrib = %d\n", args->hipFuncGetAttribute.attrib);
			printf("\thipFunction_t hfunc = %p", args->hipFuncGetAttribute.hfunc);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipFuncGetAttribute.retval);
			break;

		#endif
		#if HAVE_hipBindTextureToMipmappedArray
		case HIP_API_ID_hipBindTextureToMipmappedArray :
			//	const textureReference * tex ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipMipmappedArray_const_t mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	const hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tconst textureReference * tex = %p", args->hipBindTextureToMipmappedArray.tex);
			if (args->hipBindTextureToMipmappedArray.tex != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipBindTextureToMipmappedArray.tex__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipBindTextureToMipmappedArray.tex__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipBindTextureToMipmappedArray.tex__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipBindTextureToMipmappedArray.tex__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipBindTextureToMipmappedArray.tex__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipMipmappedArray_const_t mipmappedArray = %p", args->hipBindTextureToMipmappedArray.mipmappedArray);
			if (args->hipBindTextureToMipmappedArray.mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hipBindTextureToMipmappedArray.mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tconst hipChannelFormatDesc * desc = %p", args->hipBindTextureToMipmappedArray.desc);
			if (args->hipBindTextureToMipmappedArray.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipBindTextureToMipmappedArray.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipBindTextureToMipmappedArray.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipBindTextureToMipmappedArray.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipBindTextureToMipmappedArray.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipBindTextureToMipmappedArray.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipBindTextureToMipmappedArray.retval);
			break;

		#endif
		#if HAVE_hipGraphicsMapResources
		case HIP_API_ID_hipGraphicsMapResources :
			//	int count (int);
			//	hipGraphicsResource_t * resources (struct _hipGraphicsResource**);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint count = %d\n", args->hipGraphicsMapResources.count);
			printf("\thipGraphicsResource_t * resources = %p", args->hipGraphicsMapResources.resources);
			if (args->hipGraphicsMapResources.resources != NULL) {
				printf(" -> %p\n", args->hipGraphicsMapResources.resources__ref.val);
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->hipGraphicsMapResources.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGraphicsMapResources.retval);
			break;

		#endif
		#if HAVE_hipArrayCreate
		case HIP_API_ID_hipArrayCreate :
			//	hipArray_t * pHandle (struct hipArray **);
			//	const HIP_ARRAY_DESCRIPTOR * pAllocateArray ({
			//		size_t Width (unsigned long);
			//		size_t Height (unsigned long);
			//		enum hipArray_Format Format (enum hipArray_Format);
			//		unsigned int NumChannels (unsigned int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t * pHandle = %p", args->hipArrayCreate.pHandle);
			if (args->hipArrayCreate.pHandle != NULL) {
				printf(" -> %p\n", args->hipArrayCreate.pHandle__ref.val);
			} else { printf("\n"); };
			printf("\tconst HIP_ARRAY_DESCRIPTOR * pAllocateArray = %p", args->hipArrayCreate.pAllocateArray);
			if (args->hipArrayCreate.pAllocateArray != NULL) {
				printf(" -> {\n");
				printf("\t\tsize_t Width = %lu\n", args->hipArrayCreate.pAllocateArray__ref.val.Width);
				printf("\t\tsize_t Height = %lu\n", args->hipArrayCreate.pAllocateArray__ref.val.Height);
				printf("\t\tenum hipArray_Format Format = %d\n", args->hipArrayCreate.pAllocateArray__ref.val.Format);
				printf("\t\tunsigned int NumChannels = %u\n", args->hipArrayCreate.pAllocateArray__ref.val.NumChannels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipArrayCreate.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetMaxAnisotropy
		case HIP_API_ID_hipTexRefSetMaxAnisotropy :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	unsigned int maxAniso (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetMaxAnisotropy.texRef);
			if (args->hipTexRefSetMaxAnisotropy.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetMaxAnisotropy.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int maxAniso = %u\n", args->hipTexRefSetMaxAnisotropy.maxAniso);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetMaxAnisotropy.retval);
			break;

		#endif
		#if HAVE_hipGraphKernelNodeGetAttribute
		case HIP_API_ID_hipGraphKernelNodeGetAttribute :
			//	hipGraphNode_t hNode (struct hipGraphNode *);
			//	hipLaunchAttributeID attr (enum hipLaunchAttributeID);
			//	hipLaunchAttributeValue * value ({
			//		hipAccessPolicyWindow accessPolicyWindow ({
			//			void * base_ptr (void *);
			//			hipAccessProperty hitProp (enum hipAccessProperty);
			//			float hitRatio (float);
			//			hipAccessProperty missProp (enum hipAccessProperty);
			//			size_t num_bytes (unsigned long);
			//		});
			//		int cooperative (int);
			//		int priority (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t hNode = %p", args->hipGraphKernelNodeGetAttribute.hNode);
			printf("\n");
			printf("\thipLaunchAttributeID attr = %d\n", args->hipGraphKernelNodeGetAttribute.attr);
			printf("\thipLaunchAttributeValue * value = %p", args->hipGraphKernelNodeGetAttribute.value);
			if (args->hipGraphKernelNodeGetAttribute.value != NULL) {
				printf(" -> {\n");
				printf("\t\thipAccessPolicyWindow accessPolicyWindow = {\n");
				printf("\t\t\thipAccessProperty hitProp = %d\n", args->hipGraphKernelNodeGetAttribute.value__ref.val.accessPolicyWindow.hitProp);
				printf("\t\t\tfloat hitRatio = %f\n", args->hipGraphKernelNodeGetAttribute.value__ref.val.accessPolicyWindow.hitRatio);
				printf("\t\t\thipAccessProperty missProp = %d\n", args->hipGraphKernelNodeGetAttribute.value__ref.val.accessPolicyWindow.missProp);
				printf("\t\t\tsize_t num_bytes = %lu\n", args->hipGraphKernelNodeGetAttribute.value__ref.val.accessPolicyWindow.num_bytes);
				printf("\t\t}\n");
				printf("\t\tint cooperative = %d\n", args->hipGraphKernelNodeGetAttribute.value__ref.val.cooperative);
				printf("\t\tint priority = %d\n", args->hipGraphKernelNodeGetAttribute.value__ref.val.priority);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphKernelNodeGetAttribute.retval);
			break;

		#endif
		#if HAVE_hipExtLaunchKernel
		case HIP_API_ID_hipExtLaunchKernel :
			//	const void * function_address (const void *);
			//	dim3 numBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	dim3 dimBlocks ({
			//		uint32_t x (unsigned int);
			//		uint32_t y (unsigned int);
			//		uint32_t z (unsigned int);
			//	});
			//	void ** args (void **);
			//	size_t sharedMemBytes (unsigned long);
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipEvent_t startEvent (struct ihipEvent_t *);
			//	hipEvent_t stopEvent (struct ihipEvent_t *);
			//	int flags (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * function_address = %p", args->hipExtLaunchKernel.function_address);
			printf("\n");
			printf("\tdim3 numBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipExtLaunchKernel.numBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->hipExtLaunchKernel.numBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->hipExtLaunchKernel.numBlocks.z);
			printf("\t}\n");
			printf("\tdim3 dimBlocks = {\n");
			printf("\t\tuint32_t x = %u\n", args->hipExtLaunchKernel.dimBlocks.x);
			printf("\t\tuint32_t y = %u\n", args->hipExtLaunchKernel.dimBlocks.y);
			printf("\t\tuint32_t z = %u\n", args->hipExtLaunchKernel.dimBlocks.z);
			printf("\t}\n");
			printf("\tvoid ** args = %p", args->hipExtLaunchKernel.args);
			if (args->hipExtLaunchKernel.args != NULL) {
				printf("-> %p", args->hipExtLaunchKernel.args__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sharedMemBytes = %lu\n", args->hipExtLaunchKernel.sharedMemBytes);
			printf("\thipStream_t stream = %p", args->hipExtLaunchKernel.stream);
			printf("\n");
			printf("\thipEvent_t startEvent = %p", args->hipExtLaunchKernel.startEvent);
			printf("\n");
			printf("\thipEvent_t stopEvent = %p", args->hipExtLaunchKernel.stopEvent);
			printf("\n");
			printf("\tint flags = %d\n", args->hipExtLaunchKernel.flags);
			printf("\thipError_t retval = %d\n", args->hipExtLaunchKernel.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetMipmapFilterMode
		case HIP_API_ID_hipTexRefSetMipmapFilterMode :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	enum hipTextureFilterMode fm (enum hipTextureFilterMode);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetMipmapFilterMode.texRef);
			if (args->hipTexRefSetMipmapFilterMode.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetMipmapFilterMode.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tenum hipTextureFilterMode fm = %d\n", args->hipTexRefSetMipmapFilterMode.fm);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetMipmapFilterMode.retval);
			break;

		#endif
		#if HAVE_hipMemImportFromShareableHandle
		case HIP_API_ID_hipMemImportFromShareableHandle :
			//	hipMemGenericAllocationHandle_t * handle (struct ihipMemGenericAllocationHandle **);
			//	void * osHandle (void *);
			//	hipMemAllocationHandleType shHandleType (enum hipMemAllocationHandleType);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMemGenericAllocationHandle_t * handle = %p", args->hipMemImportFromShareableHandle.handle);
			if (args->hipMemImportFromShareableHandle.handle != NULL) {
				printf(" -> %p\n", args->hipMemImportFromShareableHandle.handle__ref.val);
			} else { printf("\n"); };
			printf("\tvoid * osHandle = %p", args->hipMemImportFromShareableHandle.osHandle);
			printf("\n");
			printf("\thipMemAllocationHandleType shHandleType = %d\n", args->hipMemImportFromShareableHandle.shHandleType);
			printf("\thipError_t retval = %d\n", args->hipMemImportFromShareableHandle.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetFormat
		case HIP_API_ID_hipTexRefSetFormat :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipArray_Format fmt (enum hipArray_Format);
			//	int NumPackedComponents (int);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetFormat.texRef);
			if (args->hipTexRefSetFormat.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetFormat.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetFormat.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetFormat.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetFormat.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetFormat.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetFormat.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetFormat.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetFormat.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetFormat.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetFormat.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetFormat.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetFormat.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetFormat.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetFormat.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetFormat.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetFormat.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetFormat.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipArray_Format fmt = %d\n", args->hipTexRefSetFormat.fmt);
			printf("\tint NumPackedComponents = %d\n", args->hipTexRefSetFormat.NumPackedComponents);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetFormat.retval);
			break;

		#endif
		#if HAVE_amd_dbgapi_get_git_hash
		case HIP_API_ID_amd_dbgapi_get_git_hash :
			//	const char * retval (const char *);
			printf("\tconst char * retval = %p", args->amd_dbgapi_get_git_hash.retval);
			if (args->amd_dbgapi_get_git_hash.retval != NULL) {
				printf(" -> %s\n", args->amd_dbgapi_get_git_hash.retval__ref.val);
			} else { printf("\n"); };
			break;

		#endif
		#if HAVE_hipLaunchByPtr
		case HIP_API_ID_hipLaunchByPtr :
			//	const void * func (const void *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * func = %p", args->hipLaunchByPtr.func);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipLaunchByPtr.retval);
			break;

		#endif
		#if HAVE_amd_dbgapi_get_build_id
		case HIP_API_ID_amd_dbgapi_get_build_id :
			//	size_t retval (unsigned long);
			printf("\tsize_t retval = %lu\n", args->amd_dbgapi_get_build_id.retval);
			break;

		#endif
		#if HAVE_hipMemcpy3DAsync
		case HIP_API_ID_hipMemcpy3DAsync :
			//	const struct hipMemcpy3DParms * p ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipStream_t stream (struct ihipStream_t *);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst struct hipMemcpy3DParms * p = %p", args->hipMemcpy3DAsync.p);
			if (args->hipMemcpy3DAsync.p != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3DAsync.p__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3DAsync.p__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3DAsync.p__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3DAsync.p__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3DAsync.p__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3DAsync.p__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipMemcpy3DAsync.p__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipMemcpy3DAsync.p__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipMemcpy3DAsync.p__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipMemcpy3DAsync.p__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipMemcpy3DAsync.p__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipMemcpy3DAsync.p__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipMemcpy3DAsync.p__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipMemcpy3DAsync.p__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipMemcpy3DAsync.p__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipMemcpy3DAsync.p__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipStream_t stream = %p", args->hipMemcpy3DAsync.stream);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemcpy3DAsync.retval);
			break;

		#endif
		#if HAVE_hipGetTextureObjectResourceViewDesc
		case HIP_API_ID_hipGetTextureObjectResourceViewDesc :
			//	struct hipResourceViewDesc * pResViewDesc ({
			//		enum hipResourceViewFormat format (enum hipResourceViewFormat);
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//		unsigned int firstMipmapLevel (unsigned int);
			//		unsigned int lastMipmapLevel (unsigned int);
			//		unsigned int firstLayer (unsigned int);
			//		unsigned int lastLayer (unsigned int);
			//	});
			//	hipTextureObject_t textureObject (struct __hip_texture *);
			//	hipError_t retval (enum hipError_t);
			printf("\tstruct hipResourceViewDesc * pResViewDesc = %p", args->hipGetTextureObjectResourceViewDesc.pResViewDesc);
			if (args->hipGetTextureObjectResourceViewDesc.pResViewDesc != NULL) {
				printf(" -> {\n");
				printf("\t\tenum hipResourceViewFormat format = %d\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.format);
				printf("\t\tsize_t width = %lu\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.width);
				printf("\t\tsize_t height = %lu\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.height);
				printf("\t\tsize_t depth = %lu\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.depth);
				printf("\t\tunsigned int firstMipmapLevel = %u\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.firstMipmapLevel);
				printf("\t\tunsigned int lastMipmapLevel = %u\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.lastMipmapLevel);
				printf("\t\tunsigned int firstLayer = %u\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.firstLayer);
				printf("\t\tunsigned int lastLayer = %u\n", args->hipGetTextureObjectResourceViewDesc.pResViewDesc__ref.val.lastLayer);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipTextureObject_t textureObject = %p", args->hipGetTextureObjectResourceViewDesc.textureObject);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipGetTextureObjectResourceViewDesc.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetFilterMode
		case HIP_API_ID_hipTexRefSetFilterMode :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	enum hipTextureFilterMode fm (enum hipTextureFilterMode);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetFilterMode.texRef);
			if (args->hipTexRefSetFilterMode.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetFilterMode.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetFilterMode.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetFilterMode.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetFilterMode.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetFilterMode.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tenum hipTextureFilterMode fm = %d\n", args->hipTexRefSetFilterMode.fm);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetFilterMode.retval);
			break;

		#endif
		#if HAVE_hipDriverGetVersion
		case HIP_API_ID_hipDriverGetVersion :
			//	int * driverVersion (int *);
			//	hipError_t retval (enum hipError_t);
			printf("\tint * driverVersion = %p", args->hipDriverGetVersion.driverVersion);
			if (args->hipDriverGetVersion.driverVersion != NULL) {
				printf(" -> %d\n", args->hipDriverGetVersion.driverVersion__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipDriverGetVersion.retval);
			break;

		#endif
		#if HAVE_hipStreamWriteValue64
		case HIP_API_ID_hipStreamWriteValue64 :
			//	hipStream_t stream (struct ihipStream_t *);
			//	void * ptr (void *);
			//	uint64_t value (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipStream_t stream = %p", args->hipStreamWriteValue64.stream);
			printf("\n");
			printf("\tvoid * ptr = %p", args->hipStreamWriteValue64.ptr);
			printf("\n");
			printf("\tuint64_t value = %lu\n", args->hipStreamWriteValue64.value);
			printf("\tunsigned int flags = %u\n", args->hipStreamWriteValue64.flags);
			printf("\thipError_t retval = %d\n", args->hipStreamWriteValue64.retval);
			break;

		#endif
		#if HAVE_hipMallocMipmappedArray
		case HIP_API_ID_hipMallocMipmappedArray :
			//	hipMipmappedArray_t * mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	const struct hipChannelFormatDesc * desc ({
			//		int x (int);
			//		int y (int);
			//		int z (int);
			//		int w (int);
			//		enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//	});
			//	struct hipExtent extent ({
			//		size_t width (unsigned long);
			//		size_t height (unsigned long);
			//		size_t depth (unsigned long);
			//	});
			//	unsigned int numLevels (unsigned int);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\thipMipmappedArray_t * mipmappedArray = %p", args->hipMallocMipmappedArray.mipmappedArray);
			if (args->hipMallocMipmappedArray.mipmappedArray != NULL) {
				printf("-> %p", args->hipMallocMipmappedArray.mipmappedArray__ref.ptr1);
				if (args->hipMallocMipmappedArray.mipmappedArray__ref.ptr1 != NULL) {
					printf(" -> {\n");
					printf("\t\tstruct hipChannelFormatDesc desc = {\n");
					printf("\t\t\tint x = %d\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.desc.x);
					printf("\t\t\tint y = %d\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.desc.y);
					printf("\t\t\tint z = %d\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.desc.z);
					printf("\t\t\tint w = %d\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.desc.w);
					printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.desc.f);
					printf("\t\t}\n");
					printf("\t\tunsigned int type = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.type);
					printf("\t\tunsigned int width = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.width);
					printf("\t\tunsigned int height = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.height);
					printf("\t\tunsigned int depth = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.depth);
					printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.min_mipmap_level);
					printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.max_mipmap_level);
					printf("\t\tunsigned int flags = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.flags);
					printf("\t\tenum hipArray_Format format = %d\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.format);
					printf("\t\tunsigned int num_channels = %u\n", args->hipMallocMipmappedArray.mipmappedArray__ref.val.num_channels);
					printf("\t}\n");
				} else { printf("\n"); };
			} else { printf("\n"); };
			printf("\tconst struct hipChannelFormatDesc * desc = %p", args->hipMallocMipmappedArray.desc);
			if (args->hipMallocMipmappedArray.desc != NULL) {
				printf(" -> {\n");
				printf("\t\tint x = %d\n", args->hipMallocMipmappedArray.desc__ref.val.x);
				printf("\t\tint y = %d\n", args->hipMallocMipmappedArray.desc__ref.val.y);
				printf("\t\tint z = %d\n", args->hipMallocMipmappedArray.desc__ref.val.z);
				printf("\t\tint w = %d\n", args->hipMallocMipmappedArray.desc__ref.val.w);
				printf("\t\tenum hipChannelFormatKind f = %d\n", args->hipMallocMipmappedArray.desc__ref.val.f);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tstruct hipExtent extent = {\n");
			printf("\t\tsize_t width = %lu\n", args->hipMallocMipmappedArray.extent.width);
			printf("\t\tsize_t height = %lu\n", args->hipMallocMipmappedArray.extent.height);
			printf("\t\tsize_t depth = %lu\n", args->hipMallocMipmappedArray.extent.depth);
			printf("\t}\n");
			printf("\tunsigned int numLevels = %u\n", args->hipMallocMipmappedArray.numLevels);
			printf("\tunsigned int flags = %u\n", args->hipMallocMipmappedArray.flags);
			printf("\thipError_t retval = %d\n", args->hipMallocMipmappedArray.retval);
			break;

		#endif
		#if HAVE_hipMemset_spt
		case HIP_API_ID_hipMemset_spt :
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemset_spt.dst);
			printf("\n");
			printf("\tint value = %d\n", args->hipMemset_spt.value);
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemset_spt.sizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemset_spt.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetFlags
		case HIP_API_ID_hipTexRefSetFlags :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	unsigned int Flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetFlags.texRef);
			if (args->hipTexRefSetFlags.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetFlags.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetFlags.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetFlags.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetFlags.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetFlags.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetFlags.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetFlags.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetFlags.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetFlags.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetFlags.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetFlags.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetFlags.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetFlags.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetFlags.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetFlags.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetFlags.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetFlags.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int Flags = %u\n", args->hipTexRefSetFlags.Flags);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetFlags.retval);
			break;

		#endif
		#if HAVE_hipMemGetAddressRange
		case HIP_API_ID_hipMemGetAddressRange :
			//	hipDeviceptr_t * pbase (void **);
			//	size_t * psize (unsigned long*);
			//	hipDeviceptr_t dptr (void *);
			//	hipError_t retval (enum hipError_t);
			printf("\thipDeviceptr_t * pbase = %p", args->hipMemGetAddressRange.pbase);
			if (args->hipMemGetAddressRange.pbase != NULL) {
				printf("-> %p", args->hipMemGetAddressRange.pbase__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t * psize = %p", args->hipMemGetAddressRange.psize);
			if (args->hipMemGetAddressRange.psize != NULL) {
				printf(" -> %lu\n", args->hipMemGetAddressRange.psize__ref.val);
			} else { printf("\n"); };
			printf("\thipDeviceptr_t dptr = %p", args->hipMemGetAddressRange.dptr);
			printf("\n");
			printf("\thipError_t retval = %d\n", args->hipMemGetAddressRange.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetMipmapLevelClamp
		case HIP_API_ID_hipTexRefSetMipmapLevelClamp :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	float minMipMapLevelClamp (float);
			//	float maxMipMapLevelClamp (float);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetMipmapLevelClamp.texRef);
			if (args->hipTexRefSetMipmapLevelClamp.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetMipmapLevelClamp.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tfloat minMipMapLevelClamp = %f\n", args->hipTexRefSetMipmapLevelClamp.minMipMapLevelClamp);
			printf("\tfloat maxMipMapLevelClamp = %f\n", args->hipTexRefSetMipmapLevelClamp.maxMipMapLevelClamp);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetMipmapLevelClamp.retval);
			break;

		#endif
		#if HAVE_hipGraphMemcpyNodeSetParams
		case HIP_API_ID_hipGraphMemcpyNodeSetParams :
			//	hipGraphNode_t node (struct hipGraphNode *);
			//	const hipMemcpy3DParms * pNodeParams ({
			//		hipArray_t srcArray (struct hipArray *);
			//		struct hipPos srcPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr srcPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		hipArray_t dstArray (struct hipArray *);
			//		struct hipPos dstPos ({
			//			size_t x (unsigned long);
			//			size_t y (unsigned long);
			//			size_t z (unsigned long);
			//		});
			//		struct hipPitchedPtr dstPtr ({
			//			void * ptr (void *);
			//			size_t pitch (unsigned long);
			//			size_t xsize (unsigned long);
			//			size_t ysize (unsigned long);
			//		});
			//		struct hipExtent extent ({
			//			size_t width (unsigned long);
			//			size_t height (unsigned long);
			//			size_t depth (unsigned long);
			//		});
			//		enum hipMemcpyKind kind (enum hipMemcpyKind);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraphNode_t node = %p", args->hipGraphMemcpyNodeSetParams.node);
			printf("\n");
			printf("\tconst hipMemcpy3DParms * pNodeParams = %p", args->hipGraphMemcpyNodeSetParams.pNodeParams);
			if (args->hipGraphMemcpyNodeSetParams.pNodeParams != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipPos srcPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.srcPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.srcPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.srcPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr srcPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.srcPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.srcPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.srcPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipPos dstPos = {\n");
				printf("\t\t\tsize_t x = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.dstPos.x);
				printf("\t\t\tsize_t y = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.dstPos.y);
				printf("\t\t\tsize_t z = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.dstPos.z);
				printf("\t\t}\n");
				printf("\t\tstruct hipPitchedPtr dstPtr = {\n");
				printf("\t\t\tsize_t pitch = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.dstPtr.pitch);
				printf("\t\t\tsize_t xsize = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.dstPtr.xsize);
				printf("\t\t\tsize_t ysize = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.dstPtr.ysize);
				printf("\t\t}\n");
				printf("\t\tstruct hipExtent extent = {\n");
				printf("\t\t\tsize_t width = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.extent.width);
				printf("\t\t\tsize_t height = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.extent.height);
				printf("\t\t\tsize_t depth = %lu\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.extent.depth);
				printf("\t\t}\n");
				printf("\t\tenum hipMemcpyKind kind = %d\n", args->hipGraphMemcpyNodeSetParams.pNodeParams__ref.val.kind);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphMemcpyNodeSetParams.retval);
			break;

		#endif
		#if HAVE_hipGraphGetEdges
		case HIP_API_ID_hipGraphGetEdges :
			//	hipGraph_t graph (struct ihipGraph *);
			//	hipGraphNode_t * from (struct hipGraphNode **);
			//	hipGraphNode_t * to (struct hipGraphNode **);
			//	size_t * numEdges (unsigned long*);
			//	hipError_t retval (enum hipError_t);
			printf("\thipGraph_t graph = %p", args->hipGraphGetEdges.graph);
			printf("\n");
			printf("\thipGraphNode_t * from = %p", args->hipGraphGetEdges.from);
			if (args->hipGraphGetEdges.from != NULL) {
				printf(" -> %p\n", args->hipGraphGetEdges.from__ref.val);
			} else { printf("\n"); };
			printf("\thipGraphNode_t * to = %p", args->hipGraphGetEdges.to);
			if (args->hipGraphGetEdges.to != NULL) {
				printf(" -> %p\n", args->hipGraphGetEdges.to__ref.val);
			} else { printf("\n"); };
			printf("\tsize_t * numEdges = %p", args->hipGraphGetEdges.numEdges);
			if (args->hipGraphGetEdges.numEdges != NULL) {
				printf(" -> %lu\n", args->hipGraphGetEdges.numEdges__ref.val);
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipGraphGetEdges.retval);
			break;

		#endif
		#if HAVE_hipMemcpyToArray
		case HIP_API_ID_hipMemcpyToArray :
			//	hipArray_t dst (struct hipArray *);
			//	size_t wOffset (unsigned long);
			//	size_t hOffset (unsigned long);
			//	const void * src (const void *);
			//	size_t count (unsigned long);
			//	hipMemcpyKind kind (enum hipMemcpyKind);
			//	hipError_t retval (enum hipError_t);
			printf("\thipArray_t dst = %p", args->hipMemcpyToArray.dst);
			printf("\n");
			printf("\tsize_t wOffset = %lu\n", args->hipMemcpyToArray.wOffset);
			printf("\tsize_t hOffset = %lu\n", args->hipMemcpyToArray.hOffset);
			printf("\tconst void * src = %p", args->hipMemcpyToArray.src);
			printf("\n");
			printf("\tsize_t count = %lu\n", args->hipMemcpyToArray.count);
			printf("\thipMemcpyKind kind = %d\n", args->hipMemcpyToArray.kind);
			printf("\thipError_t retval = %d\n", args->hipMemcpyToArray.retval);
			break;

		#endif
		#if HAVE_hipExtMallocWithFlags
		case HIP_API_ID_hipExtMallocWithFlags :
			//	void ** ptr (void **);
			//	size_t sizeBytes (unsigned long);
			//	unsigned int flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid ** ptr = %p", args->hipExtMallocWithFlags.ptr);
			if (args->hipExtMallocWithFlags.ptr != NULL) {
				printf("-> %p", args->hipExtMallocWithFlags.ptr__ref.ptr1);
				printf("\n");
			} else { printf("\n"); };
			printf("\tsize_t sizeBytes = %lu\n", args->hipExtMallocWithFlags.sizeBytes);
			printf("\tunsigned int flags = %u\n", args->hipExtMallocWithFlags.flags);
			printf("\thipError_t retval = %d\n", args->hipExtMallocWithFlags.retval);
			break;

		#endif
		#if HAVE_hipFuncSetAttribute
		case HIP_API_ID_hipFuncSetAttribute :
			//	const void * func (const void *);
			//	hipFuncAttribute attr (enum hipFuncAttribute);
			//	int value (int);
			//	hipError_t retval (enum hipError_t);
			printf("\tconst void * func = %p", args->hipFuncSetAttribute.func);
			printf("\n");
			printf("\thipFuncAttribute attr = %d\n", args->hipFuncSetAttribute.attr);
			printf("\tint value = %d\n", args->hipFuncSetAttribute.value);
			printf("\thipError_t retval = %d\n", args->hipFuncSetAttribute.retval);
			break;

		#endif
		#if HAVE_hipChooseDeviceR0600
		case HIP_API_ID_hipChooseDeviceR0600 :
			//	int * device (int *);
			//	const hipDeviceProp_tR0600 * prop ({
			//		char[256] name (char[256]);
			//		hipUUID uuid ({
			//			char[16] bytes (char[16]);
			//		});
			//		char[8] luid (char[8]);
			//		unsigned int luidDeviceNodeMask (unsigned int);
			//		size_t totalGlobalMem (unsigned long);
			//		size_t sharedMemPerBlock (unsigned long);
			//		int regsPerBlock (int);
			//		int warpSize (int);
			//		size_t memPitch (unsigned long);
			//		int maxThreadsPerBlock (int);
			//		int[3] maxThreadsDim (int[3]);
			//		int[3] maxGridSize (int[3]);
			//		int clockRate (int);
			//		size_t totalConstMem (unsigned long);
			//		int major (int);
			//		int minor (int);
			//		size_t textureAlignment (unsigned long);
			//		size_t texturePitchAlignment (unsigned long);
			//		int deviceOverlap (int);
			//		int multiProcessorCount (int);
			//		int kernelExecTimeoutEnabled (int);
			//		int integrated (int);
			//		int canMapHostMemory (int);
			//		int computeMode (int);
			//		int maxTexture1D (int);
			//		int maxTexture1DMipmap (int);
			//		int maxTexture1DLinear (int);
			//		int[2] maxTexture2D (int[2]);
			//		int[2] maxTexture2DMipmap (int[2]);
			//		int[3] maxTexture2DLinear (int[3]);
			//		int[2] maxTexture2DGather (int[2]);
			//		int[3] maxTexture3D (int[3]);
			//		int[3] maxTexture3DAlt (int[3]);
			//		int maxTextureCubemap (int);
			//		int[2] maxTexture1DLayered (int[2]);
			//		int[3] maxTexture2DLayered (int[3]);
			//		int[2] maxTextureCubemapLayered (int[2]);
			//		int maxSurface1D (int);
			//		int[2] maxSurface2D (int[2]);
			//		int[3] maxSurface3D (int[3]);
			//		int[2] maxSurface1DLayered (int[2]);
			//		int[3] maxSurface2DLayered (int[3]);
			//		int maxSurfaceCubemap (int);
			//		int[2] maxSurfaceCubemapLayered (int[2]);
			//		size_t surfaceAlignment (unsigned long);
			//		int concurrentKernels (int);
			//		int ECCEnabled (int);
			//		int pciBusID (int);
			//		int pciDeviceID (int);
			//		int pciDomainID (int);
			//		int tccDriver (int);
			//		int asyncEngineCount (int);
			//		int unifiedAddressing (int);
			//		int memoryClockRate (int);
			//		int memoryBusWidth (int);
			//		int l2CacheSize (int);
			//		int persistingL2CacheMaxSize (int);
			//		int maxThreadsPerMultiProcessor (int);
			//		int streamPrioritiesSupported (int);
			//		int globalL1CacheSupported (int);
			//		int localL1CacheSupported (int);
			//		size_t sharedMemPerMultiprocessor (unsigned long);
			//		int regsPerMultiprocessor (int);
			//		int managedMemory (int);
			//		int isMultiGpuBoard (int);
			//		int multiGpuBoardGroupID (int);
			//		int hostNativeAtomicSupported (int);
			//		int singleToDoublePrecisionPerfRatio (int);
			//		int pageableMemoryAccess (int);
			//		int concurrentManagedAccess (int);
			//		int computePreemptionSupported (int);
			//		int canUseHostPointerForRegisteredMem (int);
			//		int cooperativeLaunch (int);
			//		int cooperativeMultiDeviceLaunch (int);
			//		size_t sharedMemPerBlockOptin (unsigned long);
			//		int pageableMemoryAccessUsesHostPageTables (int);
			//		int directManagedMemAccessFromHost (int);
			//		int maxBlocksPerMultiProcessor (int);
			//		int accessPolicyMaxWindowSize (int);
			//		size_t reservedSharedMemPerBlock (unsigned long);
			//		int hostRegisterSupported (int);
			//		int sparseHipArraySupported (int);
			//		int hostRegisterReadOnlySupported (int);
			//		int timelineSemaphoreInteropSupported (int);
			//		int memoryPoolsSupported (int);
			//		int gpuDirectRDMASupported (int);
			//		unsigned int gpuDirectRDMAFlushWritesOptions (unsigned int);
			//		int gpuDirectRDMAWritesOrdering (int);
			//		unsigned int memoryPoolSupportedHandleTypes (unsigned int);
			//		int deferredMappingHipArraySupported (int);
			//		int ipcEventSupported (int);
			//		int clusterLaunch (int);
			//		int unifiedFunctionPointers (int);
			//		int[63] reserved (int[63]);
			//		int[32] hipReserved (int[32]);
			//		char[256] gcnArchName (char[256]);
			//		size_t maxSharedMemoryPerMultiProcessor (unsigned long);
			//		int clockInstructionRate (int);
			//		hipDeviceArch_t arch ({
			//			unsigned int hasGlobalInt32Atomics (unsigned int);
			//			unsigned int hasGlobalFloatAtomicExch (unsigned int);
			//			unsigned int hasSharedInt32Atomics (unsigned int);
			//			unsigned int hasSharedFloatAtomicExch (unsigned int);
			//			unsigned int hasFloatAtomicAdd (unsigned int);
			//			unsigned int hasGlobalInt64Atomics (unsigned int);
			//			unsigned int hasSharedInt64Atomics (unsigned int);
			//			unsigned int hasDoubles (unsigned int);
			//			unsigned int hasWarpVote (unsigned int);
			//			unsigned int hasWarpBallot (unsigned int);
			//			unsigned int hasWarpShuffle (unsigned int);
			//			unsigned int hasFunnelShift (unsigned int);
			//			unsigned int hasThreadFenceSystem (unsigned int);
			//			unsigned int hasSyncThreadsExt (unsigned int);
			//			unsigned int hasSurfaceFuncs (unsigned int);
			//			unsigned int has3dGrid (unsigned int);
			//			unsigned int hasDynamicParallelism (unsigned int);
			//		});
			//		int cooperativeMultiDeviceUnmatchedFunc (int);
			//		int cooperativeMultiDeviceUnmatchedGridDim (int);
			//		int cooperativeMultiDeviceUnmatchedBlockDim (int);
			//		int cooperativeMultiDeviceUnmatchedSharedMem (int);
			//		int isLargeBar (int);
			//		int asicRevision (int);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tint * device = %p", args->hipChooseDeviceR0600.device);
			if (args->hipChooseDeviceR0600.device != NULL) {
				printf(" -> %d\n", args->hipChooseDeviceR0600.device__ref.val);
			} else { printf("\n"); };
			printf("\tconst hipDeviceProp_tR0600 * prop = %p", args->hipChooseDeviceR0600.prop);
			if (args->hipChooseDeviceR0600.prop != NULL) {
				printf(" -> {\n");
				printf("\t\tchar[256] name = %c\n", args->hipChooseDeviceR0600.prop__ref.val.name[0]);
				printf("\t\thipUUID uuid = {\n");
				printf("\t\t\tchar[16] bytes = %c\n", args->hipChooseDeviceR0600.prop__ref.val.uuid.bytes[0]);
				printf("\t\t}\n");
				printf("\t\tchar[8] luid = %c\n", args->hipChooseDeviceR0600.prop__ref.val.luid[0]);
				printf("\t\tunsigned int luidDeviceNodeMask = %u\n", args->hipChooseDeviceR0600.prop__ref.val.luidDeviceNodeMask);
				printf("\t\tsize_t totalGlobalMem = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.totalGlobalMem);
				printf("\t\tsize_t sharedMemPerBlock = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.sharedMemPerBlock);
				printf("\t\tint regsPerBlock = %d\n", args->hipChooseDeviceR0600.prop__ref.val.regsPerBlock);
				printf("\t\tint warpSize = %d\n", args->hipChooseDeviceR0600.prop__ref.val.warpSize);
				printf("\t\tsize_t memPitch = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.memPitch);
				printf("\t\tint maxThreadsPerBlock = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxThreadsPerBlock);
				printf("\t\tint[3] maxThreadsDim = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxThreadsDim[0]);
				printf("\t\tint[3] maxGridSize = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxGridSize[0]);
				printf("\t\tint clockRate = %d\n", args->hipChooseDeviceR0600.prop__ref.val.clockRate);
				printf("\t\tsize_t totalConstMem = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.totalConstMem);
				printf("\t\tint major = %d\n", args->hipChooseDeviceR0600.prop__ref.val.major);
				printf("\t\tint minor = %d\n", args->hipChooseDeviceR0600.prop__ref.val.minor);
				printf("\t\tsize_t textureAlignment = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.textureAlignment);
				printf("\t\tsize_t texturePitchAlignment = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.texturePitchAlignment);
				printf("\t\tint deviceOverlap = %d\n", args->hipChooseDeviceR0600.prop__ref.val.deviceOverlap);
				printf("\t\tint multiProcessorCount = %d\n", args->hipChooseDeviceR0600.prop__ref.val.multiProcessorCount);
				printf("\t\tint kernelExecTimeoutEnabled = %d\n", args->hipChooseDeviceR0600.prop__ref.val.kernelExecTimeoutEnabled);
				printf("\t\tint integrated = %d\n", args->hipChooseDeviceR0600.prop__ref.val.integrated);
				printf("\t\tint canMapHostMemory = %d\n", args->hipChooseDeviceR0600.prop__ref.val.canMapHostMemory);
				printf("\t\tint computeMode = %d\n", args->hipChooseDeviceR0600.prop__ref.val.computeMode);
				printf("\t\tint maxTexture1D = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture1D);
				printf("\t\tint maxTexture1DMipmap = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture1DMipmap);
				printf("\t\tint maxTexture1DLinear = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture1DLinear);
				printf("\t\tint[2] maxTexture2D = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture2D[0]);
				printf("\t\tint[2] maxTexture2DMipmap = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture2DMipmap[0]);
				printf("\t\tint[3] maxTexture2DLinear = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture2DLinear[0]);
				printf("\t\tint[2] maxTexture2DGather = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture2DGather[0]);
				printf("\t\tint[3] maxTexture3D = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture3D[0]);
				printf("\t\tint[3] maxTexture3DAlt = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture3DAlt[0]);
				printf("\t\tint maxTextureCubemap = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTextureCubemap);
				printf("\t\tint[2] maxTexture1DLayered = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture1DLayered[0]);
				printf("\t\tint[3] maxTexture2DLayered = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTexture2DLayered[0]);
				printf("\t\tint[2] maxTextureCubemapLayered = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxTextureCubemapLayered[0]);
				printf("\t\tint maxSurface1D = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurface1D);
				printf("\t\tint[2] maxSurface2D = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurface2D[0]);
				printf("\t\tint[3] maxSurface3D = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurface3D[0]);
				printf("\t\tint[2] maxSurface1DLayered = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurface1DLayered[0]);
				printf("\t\tint[3] maxSurface2DLayered = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurface2DLayered[0]);
				printf("\t\tint maxSurfaceCubemap = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurfaceCubemap);
				printf("\t\tint[2] maxSurfaceCubemapLayered = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxSurfaceCubemapLayered[0]);
				printf("\t\tsize_t surfaceAlignment = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.surfaceAlignment);
				printf("\t\tint concurrentKernels = %d\n", args->hipChooseDeviceR0600.prop__ref.val.concurrentKernels);
				printf("\t\tint ECCEnabled = %d\n", args->hipChooseDeviceR0600.prop__ref.val.ECCEnabled);
				printf("\t\tint pciBusID = %d\n", args->hipChooseDeviceR0600.prop__ref.val.pciBusID);
				printf("\t\tint pciDeviceID = %d\n", args->hipChooseDeviceR0600.prop__ref.val.pciDeviceID);
				printf("\t\tint pciDomainID = %d\n", args->hipChooseDeviceR0600.prop__ref.val.pciDomainID);
				printf("\t\tint tccDriver = %d\n", args->hipChooseDeviceR0600.prop__ref.val.tccDriver);
				printf("\t\tint asyncEngineCount = %d\n", args->hipChooseDeviceR0600.prop__ref.val.asyncEngineCount);
				printf("\t\tint unifiedAddressing = %d\n", args->hipChooseDeviceR0600.prop__ref.val.unifiedAddressing);
				printf("\t\tint memoryClockRate = %d\n", args->hipChooseDeviceR0600.prop__ref.val.memoryClockRate);
				printf("\t\tint memoryBusWidth = %d\n", args->hipChooseDeviceR0600.prop__ref.val.memoryBusWidth);
				printf("\t\tint l2CacheSize = %d\n", args->hipChooseDeviceR0600.prop__ref.val.l2CacheSize);
				printf("\t\tint persistingL2CacheMaxSize = %d\n", args->hipChooseDeviceR0600.prop__ref.val.persistingL2CacheMaxSize);
				printf("\t\tint maxThreadsPerMultiProcessor = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxThreadsPerMultiProcessor);
				printf("\t\tint streamPrioritiesSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.streamPrioritiesSupported);
				printf("\t\tint globalL1CacheSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.globalL1CacheSupported);
				printf("\t\tint localL1CacheSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.localL1CacheSupported);
				printf("\t\tsize_t sharedMemPerMultiprocessor = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.sharedMemPerMultiprocessor);
				printf("\t\tint regsPerMultiprocessor = %d\n", args->hipChooseDeviceR0600.prop__ref.val.regsPerMultiprocessor);
				printf("\t\tint managedMemory = %d\n", args->hipChooseDeviceR0600.prop__ref.val.managedMemory);
				printf("\t\tint isMultiGpuBoard = %d\n", args->hipChooseDeviceR0600.prop__ref.val.isMultiGpuBoard);
				printf("\t\tint multiGpuBoardGroupID = %d\n", args->hipChooseDeviceR0600.prop__ref.val.multiGpuBoardGroupID);
				printf("\t\tint hostNativeAtomicSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.hostNativeAtomicSupported);
				printf("\t\tint singleToDoublePrecisionPerfRatio = %d\n", args->hipChooseDeviceR0600.prop__ref.val.singleToDoublePrecisionPerfRatio);
				printf("\t\tint pageableMemoryAccess = %d\n", args->hipChooseDeviceR0600.prop__ref.val.pageableMemoryAccess);
				printf("\t\tint concurrentManagedAccess = %d\n", args->hipChooseDeviceR0600.prop__ref.val.concurrentManagedAccess);
				printf("\t\tint computePreemptionSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.computePreemptionSupported);
				printf("\t\tint canUseHostPointerForRegisteredMem = %d\n", args->hipChooseDeviceR0600.prop__ref.val.canUseHostPointerForRegisteredMem);
				printf("\t\tint cooperativeLaunch = %d\n", args->hipChooseDeviceR0600.prop__ref.val.cooperativeLaunch);
				printf("\t\tint cooperativeMultiDeviceLaunch = %d\n", args->hipChooseDeviceR0600.prop__ref.val.cooperativeMultiDeviceLaunch);
				printf("\t\tsize_t sharedMemPerBlockOptin = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.sharedMemPerBlockOptin);
				printf("\t\tint pageableMemoryAccessUsesHostPageTables = %d\n", args->hipChooseDeviceR0600.prop__ref.val.pageableMemoryAccessUsesHostPageTables);
				printf("\t\tint directManagedMemAccessFromHost = %d\n", args->hipChooseDeviceR0600.prop__ref.val.directManagedMemAccessFromHost);
				printf("\t\tint maxBlocksPerMultiProcessor = %d\n", args->hipChooseDeviceR0600.prop__ref.val.maxBlocksPerMultiProcessor);
				printf("\t\tint accessPolicyMaxWindowSize = %d\n", args->hipChooseDeviceR0600.prop__ref.val.accessPolicyMaxWindowSize);
				printf("\t\tsize_t reservedSharedMemPerBlock = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.reservedSharedMemPerBlock);
				printf("\t\tint hostRegisterSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.hostRegisterSupported);
				printf("\t\tint sparseHipArraySupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.sparseHipArraySupported);
				printf("\t\tint hostRegisterReadOnlySupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.hostRegisterReadOnlySupported);
				printf("\t\tint timelineSemaphoreInteropSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.timelineSemaphoreInteropSupported);
				printf("\t\tint memoryPoolsSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.memoryPoolsSupported);
				printf("\t\tint gpuDirectRDMASupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.gpuDirectRDMASupported);
				printf("\t\tunsigned int gpuDirectRDMAFlushWritesOptions = %u\n", args->hipChooseDeviceR0600.prop__ref.val.gpuDirectRDMAFlushWritesOptions);
				printf("\t\tint gpuDirectRDMAWritesOrdering = %d\n", args->hipChooseDeviceR0600.prop__ref.val.gpuDirectRDMAWritesOrdering);
				printf("\t\tunsigned int memoryPoolSupportedHandleTypes = %u\n", args->hipChooseDeviceR0600.prop__ref.val.memoryPoolSupportedHandleTypes);
				printf("\t\tint deferredMappingHipArraySupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.deferredMappingHipArraySupported);
				printf("\t\tint ipcEventSupported = %d\n", args->hipChooseDeviceR0600.prop__ref.val.ipcEventSupported);
				printf("\t\tint clusterLaunch = %d\n", args->hipChooseDeviceR0600.prop__ref.val.clusterLaunch);
				printf("\t\tint unifiedFunctionPointers = %d\n", args->hipChooseDeviceR0600.prop__ref.val.unifiedFunctionPointers);
				printf("\t\tint[63] reserved = %d\n", args->hipChooseDeviceR0600.prop__ref.val.reserved[0]);
				printf("\t\tint[32] hipReserved = %d\n", args->hipChooseDeviceR0600.prop__ref.val.hipReserved[0]);
				printf("\t\tchar[256] gcnArchName = %c\n", args->hipChooseDeviceR0600.prop__ref.val.gcnArchName[0]);
				printf("\t\tsize_t maxSharedMemoryPerMultiProcessor = %lu\n", args->hipChooseDeviceR0600.prop__ref.val.maxSharedMemoryPerMultiProcessor);
				printf("\t\tint clockInstructionRate = %d\n", args->hipChooseDeviceR0600.prop__ref.val.clockInstructionRate);
				printf("\t\thipDeviceArch_t arch = {\n");
				printf("\t\t\tunsigned int hasGlobalInt32Atomics = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasGlobalInt32Atomics);
				printf("\t\t\tunsigned int hasGlobalFloatAtomicExch = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasGlobalFloatAtomicExch);
				printf("\t\t\tunsigned int hasSharedInt32Atomics = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasSharedInt32Atomics);
				printf("\t\t\tunsigned int hasSharedFloatAtomicExch = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasSharedFloatAtomicExch);
				printf("\t\t\tunsigned int hasFloatAtomicAdd = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasFloatAtomicAdd);
				printf("\t\t\tunsigned int hasGlobalInt64Atomics = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasGlobalInt64Atomics);
				printf("\t\t\tunsigned int hasSharedInt64Atomics = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasSharedInt64Atomics);
				printf("\t\t\tunsigned int hasDoubles = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasDoubles);
				printf("\t\t\tunsigned int hasWarpVote = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasWarpVote);
				printf("\t\t\tunsigned int hasWarpBallot = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasWarpBallot);
				printf("\t\t\tunsigned int hasWarpShuffle = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasWarpShuffle);
				printf("\t\t\tunsigned int hasFunnelShift = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasFunnelShift);
				printf("\t\t\tunsigned int hasThreadFenceSystem = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasThreadFenceSystem);
				printf("\t\t\tunsigned int hasSyncThreadsExt = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasSyncThreadsExt);
				printf("\t\t\tunsigned int hasSurfaceFuncs = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasSurfaceFuncs);
				printf("\t\t\tunsigned int has3dGrid = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.has3dGrid);
				printf("\t\t\tunsigned int hasDynamicParallelism = %u\n", args->hipChooseDeviceR0600.prop__ref.val.arch.hasDynamicParallelism);
				printf("\t\t}\n");
				printf("\t\tint cooperativeMultiDeviceUnmatchedFunc = %d\n", args->hipChooseDeviceR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedFunc);
				printf("\t\tint cooperativeMultiDeviceUnmatchedGridDim = %d\n", args->hipChooseDeviceR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedGridDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedBlockDim = %d\n", args->hipChooseDeviceR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedBlockDim);
				printf("\t\tint cooperativeMultiDeviceUnmatchedSharedMem = %d\n", args->hipChooseDeviceR0600.prop__ref.val.cooperativeMultiDeviceUnmatchedSharedMem);
				printf("\t\tint isLargeBar = %d\n", args->hipChooseDeviceR0600.prop__ref.val.isLargeBar);
				printf("\t\tint asicRevision = %d\n", args->hipChooseDeviceR0600.prop__ref.val.asicRevision);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipChooseDeviceR0600.retval);
			break;

		#endif
		#if HAVE_hipTexRefSetMipmappedArray
		case HIP_API_ID_hipTexRefSetMipmappedArray :
			//	textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	struct hipMipmappedArray * mipmappedArray ({
			//		void * data (void *);
			//		struct hipChannelFormatDesc desc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		unsigned int type (unsigned int);
			//		unsigned int width (unsigned int);
			//		unsigned int height (unsigned int);
			//		unsigned int depth (unsigned int);
			//		unsigned int min_mipmap_level (unsigned int);
			//		unsigned int max_mipmap_level (unsigned int);
			//		unsigned int flags (unsigned int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//		unsigned int num_channels (unsigned int);
			//	});
			//	unsigned int Flags (unsigned int);
			//	hipError_t retval (enum hipError_t);
			printf("\ttextureReference * texRef = %p", args->hipTexRefSetMipmappedArray.texRef);
			if (args->hipTexRefSetMipmappedArray.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetMipmappedArray.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tstruct hipMipmappedArray * mipmappedArray = %p", args->hipTexRefSetMipmappedArray.mipmappedArray);
			if (args->hipTexRefSetMipmappedArray.mipmappedArray != NULL) {
				printf(" -> {\n");
				printf("\t\tstruct hipChannelFormatDesc desc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.desc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.desc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.desc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.desc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.desc.f);
				printf("\t\t}\n");
				printf("\t\tunsigned int type = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.type);
				printf("\t\tunsigned int width = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.width);
				printf("\t\tunsigned int height = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.height);
				printf("\t\tunsigned int depth = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.depth);
				printf("\t\tunsigned int min_mipmap_level = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.min_mipmap_level);
				printf("\t\tunsigned int max_mipmap_level = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.max_mipmap_level);
				printf("\t\tunsigned int flags = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.flags);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.format);
				printf("\t\tunsigned int num_channels = %u\n", args->hipTexRefSetMipmappedArray.mipmappedArray__ref.val.num_channels);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\tunsigned int Flags = %u\n", args->hipTexRefSetMipmappedArray.Flags);
			printf("\thipError_t retval = %d\n", args->hipTexRefSetMipmappedArray.retval);
			break;

		#endif
		#if HAVE_hipMemset
		case HIP_API_ID_hipMemset :
			//	void * dst (void *);
			//	int value (int);
			//	size_t sizeBytes (unsigned long);
			//	hipError_t retval (enum hipError_t);
			printf("\tvoid * dst = %p", args->hipMemset.dst);
			printf("\n");
			printf("\tint value = %d\n", args->hipMemset.value);
			printf("\tsize_t sizeBytes = %lu\n", args->hipMemset.sizeBytes);
			printf("\thipError_t retval = %d\n", args->hipMemset.retval);
			break;

		#endif
		#if HAVE_hipTexRefGetMipmapLevelClamp
		case HIP_API_ID_hipTexRefGetMipmapLevelClamp :
			//	float * pminMipmapLevelClamp (float *);
			//	float * pmaxMipmapLevelClamp (float *);
			//	const textureReference * texRef ({
			//		int normalized (int);
			//		enum hipTextureReadMode readMode (enum hipTextureReadMode);
			//		enum hipTextureFilterMode filterMode (enum hipTextureFilterMode);
			//		enum hipTextureAddressMode[3] addressMode (enum hipTextureAddressMode[3]);
			//		struct hipChannelFormatDesc channelDesc ({
			//			int x (int);
			//			int y (int);
			//			int z (int);
			//			int w (int);
			//			enum hipChannelFormatKind f (enum hipChannelFormatKind);
			//		});
			//		int sRGB (int);
			//		unsigned int maxAnisotropy (unsigned int);
			//		enum hipTextureFilterMode mipmapFilterMode (enum hipTextureFilterMode);
			//		float mipmapLevelBias (float);
			//		float minMipmapLevelClamp (float);
			//		float maxMipmapLevelClamp (float);
			//		hipTextureObject_t textureObject (struct __hip_texture *);
			//		int numChannels (int);
			//		enum hipArray_Format format (enum hipArray_Format);
			//	});
			//	hipError_t retval (enum hipError_t);
			printf("\tfloat * pminMipmapLevelClamp = %p", args->hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp);
			if (args->hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp != NULL) {
				printf(" -> %f\n", args->hipTexRefGetMipmapLevelClamp.pminMipmapLevelClamp__ref.val);
			} else { printf("\n"); };
			printf("\tfloat * pmaxMipmapLevelClamp = %p", args->hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp);
			if (args->hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp != NULL) {
				printf(" -> %f\n", args->hipTexRefGetMipmapLevelClamp.pmaxMipmapLevelClamp__ref.val);
			} else { printf("\n"); };
			printf("\tconst textureReference * texRef = %p", args->hipTexRefGetMipmapLevelClamp.texRef);
			if (args->hipTexRefGetMipmapLevelClamp.texRef != NULL) {
				printf(" -> {\n");
				printf("\t\tint normalized = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.normalized);
				printf("\t\tenum hipTextureReadMode readMode = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.readMode);
				printf("\t\tenum hipTextureFilterMode filterMode = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.filterMode);
				printf("\t\tenum hipTextureAddressMode[3] addressMode = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.addressMode[0]);
				printf("\t\tstruct hipChannelFormatDesc channelDesc = {\n");
				printf("\t\t\tint x = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.channelDesc.x);
				printf("\t\t\tint y = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.channelDesc.y);
				printf("\t\t\tint z = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.channelDesc.z);
				printf("\t\t\tint w = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.channelDesc.w);
				printf("\t\t\tenum hipChannelFormatKind f = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.channelDesc.f);
				printf("\t\t}\n");
				printf("\t\tint sRGB = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.sRGB);
				printf("\t\tunsigned int maxAnisotropy = %u\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.maxAnisotropy);
				printf("\t\tenum hipTextureFilterMode mipmapFilterMode = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.mipmapFilterMode);
				printf("\t\tfloat mipmapLevelBias = %f\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.mipmapLevelBias);
				printf("\t\tfloat minMipmapLevelClamp = %f\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.minMipmapLevelClamp);
				printf("\t\tfloat maxMipmapLevelClamp = %f\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.maxMipmapLevelClamp);
				printf("\t\tint numChannels = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.numChannels);
				printf("\t\tenum hipArray_Format format = %d\n", args->hipTexRefGetMipmapLevelClamp.texRef__ref.val.format);
				printf("\t}\n");
			} else { printf("\n"); };
			printf("\thipError_t retval = %d\n", args->hipTexRefGetMipmapLevelClamp.retval);
			break;

		#endif
        default : break;
    }
}